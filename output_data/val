protected static long getCPtr(SWIGTYPE_p_p_btSoftBody obj) {return (obj == null) ? 0 : obj.swigCPtr;}protected static long getCPtr(SWIGTYPE_p_PHY_ScalarType obj) {return (obj == null) ? 0 : obj.swigCPtr;}public MeasuredDimension calcMeasures(int widthMeasureSpec, int heightMeasureSpec) {return new MeasuredDimension(width, height);}public boolean isDone() {return future.isDone();}
public T get() {try {return future.get();} catch (InterruptedException ex) {return null;} catch (ExecutionException ex) {throw new GdxRuntimeException(ex.getCause());}}protected void begin() {value = start;}
protected void update(float percent) {value = (int) (start + (end - start) * percent);}
public int getValue() {return value;}
public void setValue(int value) {this.value = value;}
public int getStart() {return start;}
public void setStart(int start) {this.start = start;}
public int getEnd() {return end;}
public void setEnd(int end) {this.end = end;}public Dependency getDependency(ProjectDependency gdx) {return gdxDependencies.get(gdx);}
public String[] getDependencies(ProjectType type) {switch(type) {case CORE:return coreDependencies;case DESKTOP:return desktopDependencies;case ANDROID:return androidDependencies;case IOS:return iosDependencies;case HTML:return gwtDependencies;}return null;}
public String[] getGwtInherits() {return gwtInherits;}
public String getDescription() {return description;}
public String getName() {return name;}
public String[] getPlugins() {return plugins;}public void addBody(Body argBody) {bodies.add(argBody);if (bodies.size() == 1) {bodyA = argBody;}if (bodies.size() == 2) {bodyB = argBody;}}
public void addBodyAndJoint(Body argBody, DistanceJoint argJoint) {addBody(argBody);if (joints == null) {joints = new ArrayList<DistanceJoint>();}joints.add(argJoint);}public Vector2 getLocalAnchorA() {Vec2 localAnchor = joint.getLocalAnchorA();localAnchorA.set(localAnchor.x, localAnchor.y);return localAnchorA;}
public Vector2 getLocalAnchorB() {Vec2 localAnchor = joint.getLocalAnchorB();localAnchorB.set(localAnchor.x, localAnchor.y);return localAnchorB;}
public void setMaxForce(float force) {joint.setMaxForce(force);}
public float getMaxForce() {return joint.getMaxForce();}
public void setMaxTorque(float torque) {joint.setMaxTorque(torque);}
public float getMaxTorque() {return joint.getMaxTorque();}public Shader getShader(Renderable renderable) {Shader suggestedShader = renderable.shader;if (suggestedShader != null && suggestedShader.canRender(renderable))return suggestedShader;for (Shader shader : shaders) {if (shader.canRender(renderable))return shader;}final Shader shader = createShader(renderable);shader.init();shaders.add(shader);return shader;}
public void dispose() {for (Shader shader : shaders) {shader.dispose();}shaders.clear();}public static FloatAttribute createShininess(float value) {return new FloatAttribute(Shininess, value);}
public static FloatAttribute createAlphaTest(float value) {return new FloatAttribute(AlphaTest, value);}
public Attribute copy() {return new FloatAttribute(type, value);}
public int hashCode() {int result = super.hashCode();result = 977 * result + NumberUtils.floatToRawIntBits(value);return result;}
public int compareTo(Attribute o) {if (type != o.type)return (int) (type - o.type);final float v = ((FloatAttribute) o).value;return MathUtils.isEqual(value, v) ? 0 : value < v ? -1 : 1;}protected static long getCPtr(SWIGTYPE_p_btAlignedObjectArrayT_GrahamVector3_t obj) {return (obj == null) ? 0 : obj.swigCPtr;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btShortIntIndexData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btShortIntIndexData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setValue(short value) {CollisionJNI.btShortIntIndexData_value_set(swigCPtr, this, value);}
public short getValue() {return CollisionJNI.btShortIntIndexData_value_get(swigCPtr, this);}
public void setPad(String value) {CollisionJNI.btShortIntIndexData_pad_set(swigCPtr, this, value);}
public String getPad() {return CollisionJNI.btShortIntIndexData_pad_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btPolyhedralConvexAabbCachingShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btPolyhedralConvexAabbCachingShape obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btPolyhedralConvexAabbCachingShape(swigCPtr);}swigCPtr = 0;}super.delete();}
public void getNonvirtualAabb(Matrix4 trans, Vector3 aabbMin, Vector3 aabbMax, float margin) {CollisionJNI.btPolyhedralConvexAabbCachingShape_getNonvirtualAabb(swigCPtr, this, trans, aabbMin, aabbMax, margin);}
public void recalcLocalAabb() {CollisionJNI.btPolyhedralConvexAabbCachingShape_recalcLocalAabb(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btEigen obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_btEigen(swigCPtr);}swigCPtr = 0;}super.delete();}
public static int system(Matrix3 a, SWIGTYPE_p_btMatrix3x3 vectors, btVector3 values) {return SoftbodyJNI.btEigen_system__SWIG_0(a, SWIGTYPE_p_btMatrix3x3.getCPtr(vectors), btVector3.getCPtr(values), values);}
public static int system(Matrix3 a, SWIGTYPE_p_btMatrix3x3 vectors) {return SoftbodyJNI.btEigen_system__SWIG_1(a, SWIGTYPE_p_btMatrix3x3.getCPtr(vectors));}static ReadOnlyIntArrayBuffer copy(IntArrayBuffer other, int markOfOther) {ReadOnlyIntArrayBuffer buf = new ReadOnlyIntArrayBuffer(other.capacity(), other.backingArray, other.offset);buf.limit = other.limit();buf.position = other.position();buf.mark = markOfOther;return buf;}
public IntBuffer asReadOnlyBuffer() {return duplicate();}
public IntBuffer compact() {throw new ReadOnlyBufferException();}
public IntBuffer duplicate() {return copy(this, mark);}
public boolean isReadOnly() {return true;}
protected int[] protectedArray() {throw new ReadOnlyBufferException();}
protected int protectedArrayOffset() {throw new ReadOnlyBufferException();}
protected boolean protectedHasArray() {return false;}
public IntBuffer put(int c) {throw new ReadOnlyBufferException();}
public IntBuffer put(int index, int c) {throw new ReadOnlyBufferException();}
public IntBuffer put(IntBuffer buf) {throw new ReadOnlyBufferException();}
public final IntBuffer put(int[] src, int off, int len) {throw new ReadOnlyBufferException();}
public IntBuffer slice() {return new ReadOnlyIntArrayBuffer(remaining(), backingArray, offset + position);}public void update(int screenWidth, int screenHeight, boolean centerCamera) {Vector2 scaled = scaling.apply(getWorldWidth(), getWorldHeight(), screenWidth, screenHeight);int viewportWidth = Math.round(scaled.x);int viewportHeight = Math.round(scaled.y);// Center.setScreenBounds((screenWidth - viewportWidth) / 2, (screenHeight - viewportHeight) / 2, viewportWidth, viewportHeight);apply(centerCamera);}
public Scaling getScaling() {return scaling;}
public void setScaling(Scaling scaling) {this.scaling = scaling;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(GdxCollisionObjectBridge obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_GdxCollisionObjectBridge(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setUserValue(int value) {CollisionJNI.GdxCollisionObjectBridge_userValue_set(swigCPtr, this, value);}
public int getUserValue() {return CollisionJNI.GdxCollisionObjectBridge_userValue_get(swigCPtr, this);}
public void setContactCallbackFlag(int value) {CollisionJNI.GdxCollisionObjectBridge_contactCallbackFlag_set(swigCPtr, this, value);}
public int getContactCallbackFlag() {return CollisionJNI.GdxCollisionObjectBridge_contactCallbackFlag_get(swigCPtr, this);}
public void setContactCallbackFilter(int value) {CollisionJNI.GdxCollisionObjectBridge_contactCallbackFilter_set(swigCPtr, this, value);}
public int getContactCallbackFilter() {return CollisionJNI.GdxCollisionObjectBridge_contactCallbackFilter_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btIntIndexData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btIntIndexData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setValue(int value) {CollisionJNI.btIntIndexData_value_set(swigCPtr, this, value);}
public int getValue() {return CollisionJNI.btIntIndexData_value_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(DynamicsJNI.btFixedConstraint_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btFixedConstraint obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btFixedConstraint(swigCPtr);}swigCPtr = 0;}super.delete();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.ClosestNotMeConvexResultCallback_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(ClosestNotMeConvexResultCallback obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_ClosestNotMeConvexResultCallback(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setMe(btCollisionObject value) {CollisionJNI.ClosestNotMeConvexResultCallback_me_set(swigCPtr, this, btCollisionObject.getCPtr(value), value);}
public btCollisionObject getMe() {return btCollisionObject.getInstance(CollisionJNI.ClosestNotMeConvexResultCallback_me_get(swigCPtr, this), false);}
public void setAllowedPenetration(float value) {CollisionJNI.ClosestNotMeConvexResultCallback_allowedPenetration_set(swigCPtr, this, value);}
public float getAllowedPenetration() {return CollisionJNI.ClosestNotMeConvexResultCallback_allowedPenetration_get(swigCPtr, this);}
public boolean needsCollision(btBroadphaseProxy proxy0) {return CollisionJNI.ClosestNotMeConvexResultCallback_needsCollision(swigCPtr, this, btBroadphaseProxy.getCPtr(proxy0), proxy0);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btTriangleMeshShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btTriangleMeshShape obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btTriangleMeshShape(swigCPtr);}swigCPtr = 0;}super.delete();}
public Vector3 localGetSupportingVertex(Vector3 vec) {return CollisionJNI.btTriangleMeshShape_localGetSupportingVertex(swigCPtr, this, vec);}
public Vector3 localGetSupportingVertexWithoutMargin(Vector3 vec) {return CollisionJNI.btTriangleMeshShape_localGetSupportingVertexWithoutMargin(swigCPtr, this, vec);}
public void recalcLocalAabb() {CollisionJNI.btTriangleMeshShape_recalcLocalAabb(swigCPtr, this);}
public btStridingMeshInterface getMeshInterface() {long cPtr = CollisionJNI.btTriangleMeshShape_getMeshInterface__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : new btStridingMeshInterface(cPtr, false);}
public Vector3 getLocalAabbMin() {return CollisionJNI.btTriangleMeshShape_getLocalAabbMin(swigCPtr, this);}
public Vector3 getLocalAabbMax() {return CollisionJNI.btTriangleMeshShape_getLocalAabbMax(swigCPtr, this);}protected void stopped() {LwjglAWTFrame.this.dispose();}
protected void setTitle(String title) {LwjglAWTFrame.this.setTitle(title);}
protected void setDisplayMode(int width, int height) {LwjglAWTFrame.this.getContentPane().setPreferredSize(new Dimension(width, height));LwjglAWTFrame.this.getContentPane().invalidate();LwjglAWTFrame.this.pack();LwjglAWTFrame.this.setLocationRelativeTo(null);updateSize(width, height);}
protected void resize(int width, int height) {updateSize(width, height);}
protected void start() {LwjglAWTFrame.this.start();}
public void setHaltOnShutdown(boolean halt) {if (halt) {if (shutdownHook != null)return;shutdownHook = new Thread() {
public void run() {// Because fuck you, deadlock causing Swing shutdown hooks.Runtime.getRuntime().halt(0);}};Runtime.getRuntime().addShutdownHook(shutdownHook);} else if (shutdownHook != null) {Runtime.getRuntime().removeShutdownHook(shutdownHook);shutdownHook = null;}}
public void run() {// Because fuck you, deadlock causing Swing shutdown hooks.Runtime.getRuntime().halt(0);}
protected void initialize() {}
protected void start() {}
public void updateSize(int width, int height) {}
public LwjglAWTCanvas getLwjglAWTCanvas() {return lwjglAWTCanvas;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(DynamicsJNI.btSimpleDynamicsWorld_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btSimpleDynamicsWorld obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btSimpleDynamicsWorld(swigCPtr);}swigCPtr = 0;}super.delete();}
public int stepSimulation(float timeStep, int maxSubSteps, float fixedTimeStep) {return DynamicsJNI.btSimpleDynamicsWorld_stepSimulation__SWIG_0(swigCPtr, this, timeStep, maxSubSteps, fixedTimeStep);}
public int stepSimulation(float timeStep, int maxSubSteps) {return DynamicsJNI.btSimpleDynamicsWorld_stepSimulation__SWIG_1(swigCPtr, this, timeStep, maxSubSteps);}
public int stepSimulation(float timeStep) {return DynamicsJNI.btSimpleDynamicsWorld_stepSimulation__SWIG_2(swigCPtr, this, timeStep);}
public void addRigidBody(btRigidBody body) {DynamicsJNI.btSimpleDynamicsWorld_addRigidBody__SWIG_0(swigCPtr, this, btRigidBody.getCPtr(body), body);}
public void addRigidBody(btRigidBody body, short group, short mask) {DynamicsJNI.btSimpleDynamicsWorld_addRigidBody__SWIG_1(swigCPtr, this, btRigidBody.getCPtr(body), body, group, mask);}public void create() {skin = new Skin(Gdx.files.internal("data/uiskin.json"));image2 = new TextureRegion(new Texture(Gdx.files.internal("data/badlogic.jpg")));ui = new Stage();Gdx.input.setInputProcessor(ui);root = new Table();root.setSize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());ui.addActor(root);root.debug();Image image = new Image(image2);image.setScaling(Scaling.fill);root.add(image).width(image2.getRegionWidth()).height(image2.getRegionHeight());}
public void dispose() {ui.dispose();skin.dispose();image2.getTexture().dispose();}
public void render() {Gdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);ui.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));ui.draw();}
public void resize(int width, int height) {ui.getViewport().update(width, height, true);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btDbvtProxy_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btDbvtProxy obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btDbvtProxy(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setLeaf(btDbvtNode value) {CollisionJNI.btDbvtProxy_leaf_set(swigCPtr, this, btDbvtNode.getCPtr(value), value);}
public btDbvtNode getLeaf() {long cPtr = CollisionJNI.btDbvtProxy_leaf_get(swigCPtr, this);return (cPtr == 0) ? null : new btDbvtNode(cPtr, false);}
public void setLinks(SWIGTYPE_p_p_btDbvtProxy value) {CollisionJNI.btDbvtProxy_links_set(swigCPtr, this, SWIGTYPE_p_p_btDbvtProxy.getCPtr(value));}
public SWIGTYPE_p_p_btDbvtProxy getLinks() {long cPtr = CollisionJNI.btDbvtProxy_links_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_p_btDbvtProxy(cPtr, false);}
public void setStage(int value) {CollisionJNI.btDbvtProxy_stage_set(swigCPtr, this, value);}
public int getStage() {return CollisionJNI.btDbvtProxy_stage_get(swigCPtr, this);}public final int capacity() {return capacity;}
public final Buffer clear() {position = 0;mark = UNSET_MARK;limit = capacity;return this;}
public final Buffer flip() {limit = position;position = 0;mark = UNSET_MARK;return this;}
public final boolean hasRemaining() {return position < limit;}
public final int limit() {return limit;}
public final Buffer limit(int newLimit) {if (newLimit < 0 || newLimit > capacity) {throw new IllegalArgumentException();}limit = newLimit;if (position > newLimit) {position = newLimit;}if ((mark != UNSET_MARK) && (mark > newLimit)) {mark = UNSET_MARK;}return this;}
public final Buffer mark() {mark = position;return this;}
public final int position() {return position;}
public final Buffer position(int newPosition) {if (newPosition < 0 || newPosition > limit) {throw new IllegalArgumentException();}position = newPosition;if ((mark != UNSET_MARK) && (mark > position)) {mark = UNSET_MARK;}return this;}
public final int remaining() {return limit - position;}
public final Buffer reset() {if (mark == UNSET_MARK) {throw new InvalidMarkException();}position = mark;return this;}
public final Buffer rewind() {position = 0;mark = UNSET_MARK;return this;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btMultiSphereShapeData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btMultiSphereShapeData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setConvexInternalShapeData(btConvexInternalShapeData value) {CollisionJNI.btMultiSphereShapeData_convexInternalShapeData_set(swigCPtr, this, btConvexInternalShapeData.getCPtr(value), value);}
public btConvexInternalShapeData getConvexInternalShapeData() {long cPtr = CollisionJNI.btMultiSphereShapeData_convexInternalShapeData_get(swigCPtr, this);return (cPtr == 0) ? null : new btConvexInternalShapeData(cPtr, false);}
public void setLocalPositionArrayPtr(btPositionAndRadius value) {CollisionJNI.btMultiSphereShapeData_localPositionArrayPtr_set(swigCPtr, this, btPositionAndRadius.getCPtr(value), value);}
public btPositionAndRadius getLocalPositionArrayPtr() {long cPtr = CollisionJNI.btMultiSphereShapeData_localPositionArrayPtr_get(swigCPtr, this);return (cPtr == 0) ? null : new btPositionAndRadius(cPtr, false);}
public void setLocalPositionArraySize(int value) {CollisionJNI.btMultiSphereShapeData_localPositionArraySize_set(swigCPtr, this, value);}
public int getLocalPositionArraySize() {return CollisionJNI.btMultiSphereShapeData_localPositionArraySize_get(swigCPtr, this);}
public void setPadding(String value) {CollisionJNI.btMultiSphereShapeData_padding_set(swigCPtr, this, value);}
public String getPadding() {return CollisionJNI.btMultiSphereShapeData_padding_get(swigCPtr, this);}public void init() {spawnShapeValue.init();}
public void allocateChannels() {positionChannel = controller.particles.addChannel(ParticleChannels.Position);}
public void start() {spawnShapeValue.start();}
public void activateParticles(int startIndex, int count) {for (int i = startIndex * positionChannel.strideSize, c = i + count * positionChannel.strideSize; i < c; i += positionChannel.strideSize) {spawnShapeValue.spawn(TMP_V1, controller.emitter.percent);TMP_V1.mul(controller.transform);positionChannel.data[i + ParticleChannels.XOffset] = TMP_V1.x;positionChannel.data[i + ParticleChannels.YOffset] = TMP_V1.y;positionChannel.data[i + ParticleChannels.ZOffset] = TMP_V1.z;}}
public SpawnInfluencer copy() {return new SpawnInfluencer(this);}
public void write(Json json) {json.writeValue("spawnShape", spawnShapeValue, SpawnShapeValue.class);}
public void read(Json json, JsonValue jsonData) {spawnShapeValue = json.readValue("spawnShape", SpawnShapeValue.class, jsonData);}
public void save(AssetManager manager, ResourceData data) {spawnShapeValue.save(manager, data);}
public void load(AssetManager manager, ResourceData data) {spawnShapeValue.load(manager, data);}public void initialize(Body bodyA, Body bodyB, Vector2 anchor) {this.bodyA = bodyA;this.bodyB = bodyB;localAnchorA.set(bodyA.getLocalPoint(anchor));localAnchorB.set(bodyB.getLocalPoint(anchor));}
public org.jbox2d.dynamics.joints.JointDef toJBox2d() {org.jbox2d.dynamics.joints.FrictionJointDef jd = new org.jbox2d.dynamics.joints.FrictionJointDef();jd.bodyA = bodyA.body;jd.bodyB = bodyB.body;jd.collideConnected = collideConnected;jd.localAnchorA.set(localAnchorA.x, localAnchorA.y);jd.localAnchorB.set(localAnchorB.x, localAnchorB.y);jd.maxForce = maxForce;jd.maxTorque = maxTorque;jd.type = org.jbox2d.dynamics.joints.JointType.FRICTION;return jd;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(SoftbodyJNI.btSoftRigidCollisionAlgorithm_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btSoftRigidCollisionAlgorithm obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_btSoftRigidCollisionAlgorithm(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(SoftbodyJNI.btSoftRigidCollisionAlgorithm_CreateFunc_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(CreateFunc obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_btSoftRigidCollisionAlgorithm_CreateFunc(swigCPtr);}swigCPtr = 0;}super.delete();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btTriangleCallback obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btTriangleCallback(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void swigDirectorDisconnect() {swigCMemOwn = false;delete();}
public void swigReleaseOwnership() {swigCMemOwn = false;CollisionJNI.btTriangleCallback_change_ownership(this, swigCPtr, false);}
public void swigTakeOwnership() {swigCMemOwn = true;CollisionJNI.btTriangleCallback_change_ownership(this, swigCPtr, true);}
public void processTriangle(btVector3 triangle, int partId, int triangleIndex) {CollisionJNI.btTriangleCallback_processTriangle(swigCPtr, this, btVector3.getCPtr(triangle), triangle, partId, triangleIndex);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(GIM_TRIANGLE_CONTACT obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_GIM_TRIANGLE_CONTACT(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setPenetration_depth(float value) {CollisionJNI.GIM_TRIANGLE_CONTACT_penetration_depth_set(swigCPtr, this, value);}
public float getPenetration_depth() {return CollisionJNI.GIM_TRIANGLE_CONTACT_penetration_depth_get(swigCPtr, this);}
public void setPoint_count(int value) {CollisionJNI.GIM_TRIANGLE_CONTACT_point_count_set(swigCPtr, this, value);}
public int getPoint_count() {return CollisionJNI.GIM_TRIANGLE_CONTACT_point_count_get(swigCPtr, this);}
public void setSeparating_normal(btVector4 value) {CollisionJNI.GIM_TRIANGLE_CONTACT_separating_normal_set(swigCPtr, this, btVector4.getCPtr(value), value);}
public btVector4 getSeparating_normal() {long cPtr = CollisionJNI.GIM_TRIANGLE_CONTACT_separating_normal_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector4(cPtr, false);}
public void setPoints(btVector3 value) {CollisionJNI.GIM_TRIANGLE_CONTACT_points_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getPoints() {long cPtr = CollisionJNI.GIM_TRIANGLE_CONTACT_points_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void copy_from(GIM_TRIANGLE_CONTACT other) {CollisionJNI.GIM_TRIANGLE_CONTACT_copy_from(swigCPtr, this, GIM_TRIANGLE_CONTACT.getCPtr(other), other);}
public void merge_points(btVector4 plane, float margin, btVector3 points, int point_count) {CollisionJNI.GIM_TRIANGLE_CONTACT_merge_points(swigCPtr, this, btVector4.getCPtr(plane), plane, margin, btVector3.getCPtr(points), points, point_count);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btOptimizedBvhNodeDoubleData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btOptimizedBvhNodeDoubleData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setAabbMinOrg(btVector3DoubleData value) {CollisionJNI.btOptimizedBvhNodeDoubleData_aabbMinOrg_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAabbMinOrg() {long cPtr = CollisionJNI.btOptimizedBvhNodeDoubleData_aabbMinOrg_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAabbMaxOrg(btVector3DoubleData value) {CollisionJNI.btOptimizedBvhNodeDoubleData_aabbMaxOrg_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAabbMaxOrg() {long cPtr = CollisionJNI.btOptimizedBvhNodeDoubleData_aabbMaxOrg_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setEscapeIndex(int value) {CollisionJNI.btOptimizedBvhNodeDoubleData_escapeIndex_set(swigCPtr, this, value);}
public int getEscapeIndex() {return CollisionJNI.btOptimizedBvhNodeDoubleData_escapeIndex_get(swigCPtr, this);}
public void setSubPart(int value) {CollisionJNI.btOptimizedBvhNodeDoubleData_subPart_set(swigCPtr, this, value);}
public int getSubPart() {return CollisionJNI.btOptimizedBvhNodeDoubleData_subPart_get(swigCPtr, this);}
public void setTriangleIndex(int value) {CollisionJNI.btOptimizedBvhNodeDoubleData_triangleIndex_set(swigCPtr, this, value);}
public int getTriangleIndex() {return CollisionJNI.btOptimizedBvhNodeDoubleData_triangleIndex_get(swigCPtr, this);}
public void setPad(String value) {CollisionJNI.btOptimizedBvhNodeDoubleData_pad_set(swigCPtr, this, value);}
public String getPad() {return CollisionJNI.btOptimizedBvhNodeDoubleData_pad_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btDynamicsWorldDoubleData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btDynamicsWorldDoubleData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setSolverInfo(btContactSolverInfoDoubleData value) {DynamicsJNI.btDynamicsWorldDoubleData_solverInfo_set(swigCPtr, this, btContactSolverInfoDoubleData.getCPtr(value), value);}
public btContactSolverInfoDoubleData getSolverInfo() {long cPtr = DynamicsJNI.btDynamicsWorldDoubleData_solverInfo_get(swigCPtr, this);return (cPtr == 0) ? null : new btContactSolverInfoDoubleData(cPtr, false);}
public void setGravity(btVector3DoubleData value) {DynamicsJNI.btDynamicsWorldDoubleData_gravity_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getGravity() {long cPtr = DynamicsJNI.btDynamicsWorldDoubleData_gravity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}public static void main(String[] argv) {GdxTest test = new FreeTypeMetricsTest();LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();config.r = config.g = config.b = config.a = 8;//config.height = 241;config.width = 960;config.height = 600;new LwjglApplication(test, config);}public void mark(int readLimit) {throw new IOException();}
public boolean markSupported() {return false;}
public int read() {synchronized (lock) {char charArray[] = new char[1];if (read(charArray, 0, 1) != -1) {return charArray[0];}return -1;}}
public int read(char buf[]) {return read(buf, 0, buf.length);}
public boolean ready() {return false;}
public void reset() {throw new IOException();}
public long skip(long count) {if (count < 0) {throw new IllegalArgumentException();}synchronized (lock) {long skipped = 0;int toRead = count < 512 ? (int) count : 512;char charsSkipped[] = new char[toRead];while (skipped < count) {int read = read(charsSkipped, 0, toRead);if (read == -1) {return skipped;}skipped += read;if (read < toRead) {return skipped;}if (count - skipped < toRead) {toRead = (int) (count - skipped);}}return skipped;}}
public int read(CharBuffer target) {if (null == target) {throw new NullPointerException();}int length = target.length();char[] buf = new char[length];length = Math.min(length, read(buf));if (length > 0) {target.put(buf, 0, length);}return length;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btDbvtAabbMm obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btDbvtAabbMm(swigCPtr);}swigCPtr = 0;}super.delete();}
public Vector3 Center() {return CollisionJNI.btDbvtAabbMm_Center(swigCPtr, this);}
public Vector3 Lengths() {return CollisionJNI.btDbvtAabbMm_Lengths(swigCPtr, this);}
public Vector3 Extents() {return CollisionJNI.btDbvtAabbMm_Extents(swigCPtr, this);}
public Vector3 Mins() {return CollisionJNI.btDbvtAabbMm_Mins(swigCPtr, this);}
public Vector3 Maxs() {return CollisionJNI.btDbvtAabbMm_Maxs(swigCPtr, this);}
public static btDbvtAabbMm FromCE(Vector3 c, Vector3 e) {return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromCE(c, e), true);}
public static btDbvtAabbMm FromCR(Vector3 c, float r) {return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromCR(c, r), true);}
public static btDbvtAabbMm FromMM(Vector3 mi, Vector3 mx) {return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromMM(mi, mx), true);}
public static btDbvtAabbMm FromPoints(btVector3 pts, int n) {return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromPoints__SWIG_0(btVector3.getCPtr(pts), pts, n), true);}
public static btDbvtAabbMm FromPoints(SWIGTYPE_p_p_btVector3 ppts, int n) {return new btDbvtAabbMm(CollisionJNI.btDbvtAabbMm_FromPoints__SWIG_1(SWIGTYPE_p_p_btVector3.getCPtr(ppts), n), true);}
public void Expand(Vector3 e) {CollisionJNI.btDbvtAabbMm_Expand(swigCPtr, this, e);}
public void SignedExpand(Vector3 e) {CollisionJNI.btDbvtAabbMm_SignedExpand(swigCPtr, this, e);}
public boolean Contain(btDbvtAabbMm a) {return CollisionJNI.btDbvtAabbMm_Contain(swigCPtr, this, btDbvtAabbMm.getCPtr(a), a);}
public int Classify(Vector3 n, float o, int s) {return CollisionJNI.btDbvtAabbMm_Classify(swigCPtr, this, n, o, s);}
public float ProjectMinimum(Vector3 v, long signs) {return CollisionJNI.btDbvtAabbMm_ProjectMinimum(swigCPtr, this, v, signs);}
public Vector3 tMins() {return CollisionJNI.btDbvtAabbMm_tMins(swigCPtr, this);}
public Vector3 tMaxs() {return CollisionJNI.btDbvtAabbMm_tMaxs(swigCPtr, this);}public float getMinWidth() {return getPrefWidth();}
public float getMinHeight() {return getPrefHeight();}
public float getPrefWidth() {return 0;}
public float getPrefHeight() {return 0;}
public float getMaxWidth() {return 0;}
public float getMaxHeight() {return 0;}
public void setLayoutEnabled(boolean enabled) {if (layoutEnabled == enabled)return;layoutEnabled = enabled;setLayoutEnabled(this, enabled);}
private void setLayoutEnabled(Group parent, boolean enabled) {SnapshotArray<Actor> children = parent.getChildren();for (int i = 0, n = children.size; i < n; i++) {Actor actor = children.get(i);if (actor instanceof Layout)((Layout) actor).setLayoutEnabled(enabled);else if (//actor instanceof Group)setLayoutEnabled((Group) actor, enabled);}}
public void validate() {if (!layoutEnabled)return;Group parent = getParent();if (fillParent && parent != null) {float parentWidth, parentHeight;Stage stage = getStage();if (stage != null && parent == stage.getRoot()) {parentWidth = stage.getWidth();parentHeight = stage.getHeight();} else {parentWidth = parent.getWidth();parentHeight = parent.getHeight();}if (getWidth() != parentWidth || getHeight() != parentHeight) {setWidth(parentWidth);setHeight(parentHeight);invalidate();}}if (!needsLayout)return;needsLayout = false;layout();}
public boolean needsLayout() {return needsLayout;}
public void invalidate() {needsLayout = true;}
public void invalidateHierarchy() {invalidate();Group parent = getParent();if (parent instanceof Layout)((Layout) parent).invalidateHierarchy();}
protected void childrenChanged() {invalidateHierarchy();}
protected void sizeChanged() {invalidate();}
public void pack() {setSize(getPrefWidth(), getPrefHeight());validate();// calls invalidateHierarchy() in layout() if its pref height has changed.if (needsLayout) {setSize(getPrefWidth(), getPrefHeight());validate();}}
public void setFillParent(boolean fillParent) {this.fillParent = fillParent;}
public void layout() {}
public void draw(Batch batch, float parentAlpha) {validate();super.draw(batch, parentAlpha);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btDispatcherInfo obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btDispatcherInfo(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setTimeStep(float value) {CollisionJNI.btDispatcherInfo_timeStep_set(swigCPtr, this, value);}
public float getTimeStep() {return CollisionJNI.btDispatcherInfo_timeStep_get(swigCPtr, this);}
public void setStepCount(int value) {CollisionJNI.btDispatcherInfo_stepCount_set(swigCPtr, this, value);}
public int getStepCount() {return CollisionJNI.btDispatcherInfo_stepCount_get(swigCPtr, this);}
public void setDispatchFunc(int value) {CollisionJNI.btDispatcherInfo_dispatchFunc_set(swigCPtr, this, value);}
public int getDispatchFunc() {return CollisionJNI.btDispatcherInfo_dispatchFunc_get(swigCPtr, this);}
public void setTimeOfImpact(float value) {CollisionJNI.btDispatcherInfo_timeOfImpact_set(swigCPtr, this, value);}
public float getTimeOfImpact() {return CollisionJNI.btDispatcherInfo_timeOfImpact_get(swigCPtr, this);}
public void setUseContinuous(boolean value) {CollisionJNI.btDispatcherInfo_useContinuous_set(swigCPtr, this, value);}
public boolean getUseContinuous() {return CollisionJNI.btDispatcherInfo_useContinuous_get(swigCPtr, this);}
public void setDebugDraw(btIDebugDraw value) {CollisionJNI.btDispatcherInfo_debugDraw_set(swigCPtr, this, btIDebugDraw.getCPtr(value), value);}
public btIDebugDraw getDebugDraw() {long cPtr = CollisionJNI.btDispatcherInfo_debugDraw_get(swigCPtr, this);return (cPtr == 0) ? null : new btIDebugDraw(cPtr, false);}
public void setEnableSatConvex(boolean value) {CollisionJNI.btDispatcherInfo_enableSatConvex_set(swigCPtr, this, value);}
public boolean getEnableSatConvex() {return CollisionJNI.btDispatcherInfo_enableSatConvex_get(swigCPtr, this);}
public void setEnableSPU(boolean value) {CollisionJNI.btDispatcherInfo_enableSPU_set(swigCPtr, this, value);}
public boolean getEnableSPU() {return CollisionJNI.btDispatcherInfo_enableSPU_get(swigCPtr, this);}
public void setUseEpa(boolean value) {CollisionJNI.btDispatcherInfo_useEpa_set(swigCPtr, this, value);}
public boolean getUseEpa() {return CollisionJNI.btDispatcherInfo_useEpa_get(swigCPtr, this);}
public void setAllowedCcdPenetration(float value) {CollisionJNI.btDispatcherInfo_allowedCcdPenetration_set(swigCPtr, this, value);}
public float getAllowedCcdPenetration() {return CollisionJNI.btDispatcherInfo_allowedCcdPenetration_get(swigCPtr, this);}
public void setUseConvexConservativeDistanceUtil(boolean value) {CollisionJNI.btDispatcherInfo_useConvexConservativeDistanceUtil_set(swigCPtr, this, value);}
public boolean getUseConvexConservativeDistanceUtil() {return CollisionJNI.btDispatcherInfo_useConvexConservativeDistanceUtil_get(swigCPtr, this);}
public void setConvexConservativeDistanceThreshold(float value) {CollisionJNI.btDispatcherInfo_convexConservativeDistanceThreshold_set(swigCPtr, this, value);}
public float getConvexConservativeDistanceThreshold() {return CollisionJNI.btDispatcherInfo_convexConservativeDistanceThreshold_get(swigCPtr, this);}public void create() {font = new BitmapFont();camera = new OrthographicCamera(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());controller = new OrthoCamController(camera);Gdx.input.setInputProcessor(controller);Pixmap pixmap = new Pixmap(32, 32, Format.RGB565);pixmap.setColor(1, 0, 0, 1);pixmap.fill();pixmap.setColor(0, 1, 0, 1);pixmap.drawLine(0, 0, 32, 32);pixmap.drawLine(0, 32, 32, 0);ETC1Data encodedImage = ETC1.encodeImagePKM(pixmap);pixmap.dispose();pixmap = ETC1.decodeImage(encodedImage, Format.RGB565);encodedImage.dispose();img1 = new Texture(pixmap);img2 = new Texture("data/test.etc1");batch = new SpriteBatch();pixmap.dispose();}
public void render() {Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);camera.update();batch.setProjectionMatrix(camera.combined);batch.begin();batch.draw(img2, -100, 0);batch.draw(img1, 0, 0);batch.end();batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());batch.begin();font.draw(batch, "fps: " + Gdx.graphics.getFramesPerSecond(), 0, 30);batch.end();}
public void dispose() {batch.dispose();font.dispose();img1.dispose();img2.dispose();}public ByteBuffer asReadOnlyBuffer() {return this;}
byte[] protectedArray() {throw new UnsupportedOperationException();}
int protectedArrayOffset() {throw new UnsupportedOperationException();}
boolean protectedHasArray() {throw new UnsupportedOperationException();}
public ByteBuffer compact() {return this;}
public ByteBuffer duplicate() {return this;}
public byte get() {return get(position++);}
public byte get(int index) {return get(s, index);}
public final double getDouble() {return Numbers.longBitsToDouble(getLong());}
public final double getDouble(int index) {return Numbers.longBitsToDouble(getLong(index));}
public final float getFloat() {return Numbers.intBitsToFloat(getInt());}
public final float getFloat(int index) {return Numbers.intBitsToFloat(getInt(index));}
public final int getInt() {int newPosition = position + 4;int result = loadInt(position);position = newPosition;return result;}
public final int getInt(int index) {return loadInt(index);}
public final long getLong() {throw new UnsupportedOperationException();}
public final long getLong(int index) {throw new UnsupportedOperationException();}
public final short getShort() {int newPosition = position + 2;short result = loadShort(position);position = newPosition;return result;}
public final short getShort(int index) {return loadShort(index);}
public boolean isDirect() {return false;}
public ByteBuffer put(byte b) {throw new UnsupportedOperationException();}
public ByteBuffer put(int index, byte b) {throw new UnsupportedOperationException();}
public ByteBuffer putDouble(double value) {throw new UnsupportedOperationException();}
public ByteBuffer putDouble(int index, double value) {throw new UnsupportedOperationException();}
public ByteBuffer putFloat(float value) {throw new UnsupportedOperationException();}
public ByteBuffer putFloat(int index, float value) {throw new UnsupportedOperationException();}
public ByteBuffer putInt(int value) {throw new UnsupportedOperationException();}
public ByteBuffer putInt(int index, int value) {throw new UnsupportedOperationException();}
public ByteBuffer putLong(long value) {throw new UnsupportedOperationException();}
public ByteBuffer putLong(int index, long value) {throw new UnsupportedOperationException();}
public ByteBuffer putShort(short value) {throw new UnsupportedOperationException();}
public ByteBuffer putShort(int index, short value) {throw new UnsupportedOperationException();}
public ByteBuffer slice() {// TODO(jgw): I don't think this is right, but might work for our purposes.StringByteBuffer slice = new StringByteBuffer(s, position, limit);slice.order = order;return slice;}
public boolean isReadOnly() {return true;}
protected final int loadInt(int baseOffset) {int bytes = 0;for (int i = 3; i >= 0; i--) {bytes = bytes << 8;bytes = bytes | (get(baseOffset + i) & 0xFF);}return bytes;}
protected final short loadShort(int baseOffset) {short bytes = 0;bytes = (short) (get(baseOffset + 1) << 8);bytes |= (get(baseOffset) & 0xFF);return bytes;}public void create() {batch = new SpriteBatch();texture = new Texture(Gdx.files.internal("data/g2d/progressive-libgdx.jpg"));texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);drawable = new TextureRegionDrawable(new TextureRegion(texture));}
public void render() {Gdx.gl.glClearColor(1, 1, 1, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);batch.begin();drawable.draw(batch, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());batch.end();}
public void dispose() {texture.dispose();batch.dispose();}public void create() {if (thread == null) {final AudioDevice device = Gdx.app.getAudio().newAudioDevice(44100, false);thread = new Thread(new Runnable() {
@Overridepublic void run() {final float frequency = 440;// angular increment for each samplefloat increment = (float) (2 * Math.PI) * frequency / 44100;float angle = 0;float samples[] = new float[1024];while (!stop) {for (int i = 0; i < samples.length; i += 2) {samples[i] = 0.5f * (float) Math.sin(angle);samples[i + 1] = 2 * samples[i];angle += increment;}device.writeSamples(samples, 0, samples.length);}device.dispose();}});thread.start();}}
public void run() {final float frequency = 440;// angular increment for each samplefloat increment = (float) (2 * Math.PI) * frequency / 44100;float angle = 0;float samples[] = new float[1024];while (!stop) {for (int i = 0; i < samples.length; i += 2) {samples[i] = 0.5f * (float) Math.sin(angle);samples[i + 1] = 2 * samples[i];angle += increment;}device.writeSamples(samples, 0, samples.length);}device.dispose();}
public void dispose() {stop = true;try {thread.join();} catch (InterruptedException e) {e.printStackTrace();}}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btVector3Array obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_btVector3Array(swigCPtr);}swigCPtr = 0;}super.delete();}
public int size() {return LinearMathJNI.btVector3Array_size(swigCPtr, this);}
public Vector3 at(int n) {return LinearMathJNI.btVector3Array_at__SWIG_0(swigCPtr, this, n);}
public void clear() {LinearMathJNI.btVector3Array_clear(swigCPtr, this);}
public void pop_back() {LinearMathJNI.btVector3Array_pop_back(swigCPtr, this);}
public void resizeNoInitialize(int newsize) {LinearMathJNI.btVector3Array_resizeNoInitialize(swigCPtr, this, newsize);}
public void resize(int newsize, Vector3 fillData) {LinearMathJNI.btVector3Array_resize__SWIG_0(swigCPtr, this, newsize, fillData);}
public void resize(int newsize) {LinearMathJNI.btVector3Array_resize__SWIG_1(swigCPtr, this, newsize);}
public Vector3 expandNonInitializing() {return LinearMathJNI.btVector3Array_expandNonInitializing(swigCPtr, this);}
public Vector3 expand(Vector3 fillValue) {return LinearMathJNI.btVector3Array_expand__SWIG_0(swigCPtr, this, fillValue);}
public Vector3 expand() {return LinearMathJNI.btVector3Array_expand__SWIG_1(swigCPtr, this);}
public void push_back(Vector3 _Val) {LinearMathJNI.btVector3Array_push_back(swigCPtr, this, _Val);}
public int capacity() {return LinearMathJNI.btVector3Array_capacity(swigCPtr, this);}
public void reserve(int _Count) {LinearMathJNI.btVector3Array_reserve(swigCPtr, this, _Count);}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(less obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_btVector3Array_less(swigCPtr);}swigCPtr = 0;}super.delete();}
public void swap(int index0, int index1) {LinearMathJNI.btVector3Array_swap(swigCPtr, this, index0, index1);}
public int findBinarySearch(Vector3 key) {return LinearMathJNI.btVector3Array_findBinarySearch(swigCPtr, this, key);}
public int findLinearSearch(Vector3 key) {return LinearMathJNI.btVector3Array_findLinearSearch(swigCPtr, this, key);}
public void remove(Vector3 key) {LinearMathJNI.btVector3Array_remove(swigCPtr, this, key);}
public void initializeFromBuffer(long buffer, int size, int capacity) {LinearMathJNI.btVector3Array_initializeFromBuffer(swigCPtr, this, buffer, size, capacity);}
public void copyFromArray(btVector3Array otherArray) {LinearMathJNI.btVector3Array_copyFromArray(swigCPtr, this, btVector3Array.getCPtr(otherArray), otherArray);}public void create() {// to the servernew Thread(new Runnable() {
@Overridepublic void run() {ServerSocketHints hints = new ServerSocketHints();ServerSocket server = Gdx.net.newServerSocket(Protocol.TCP, "localhost", 9999, hints);// wait for the next client connectionSocket client = server.accept(null);// read message and send it backtry {String message = new BufferedReader(new InputStreamReader(client.getInputStream())).readLine();Gdx.app.log("PingPongSocketExample", "got client message: " + message);client.getOutputStream().write("PONG\n".getBytes());} catch (IOException e) {Gdx.app.log("PingPongSocketExample", "an error occured", e);}}}).start();// server to replySocketHints hints = new SocketHints();Socket client = Gdx.net.newClientSocket(Protocol.TCP, "localhost", 9999, hints);try {client.getOutputStream().write("PING\n".getBytes());String response = new BufferedReader(new InputStreamReader(client.getInputStream())).readLine();Gdx.app.log("PingPongSocketExample", "got server message: " + response);} catch (IOException e) {Gdx.app.log("PingPongSocketExample", "an error occured", e);}}
public void run() {ServerSocketHints hints = new ServerSocketHints();ServerSocket server = Gdx.net.newServerSocket(Protocol.TCP, "localhost", 9999, hints);// wait for the next client connectionSocket client = server.accept(null);// read message and send it backtry {String message = new BufferedReader(new InputStreamReader(client.getInputStream())).readLine();Gdx.app.log("PingPongSocketExample", "got client message: " + message);client.getOutputStream().write("PONG\n".getBytes());} catch (IOException e) {Gdx.app.log("PingPongSocketExample", "an error occured", e);}}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btCapsuleShapeX_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btCapsuleShapeX obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btCapsuleShapeX(swigCPtr);}swigCPtr = 0;}super.delete();}static ReadOnlyCharArrayBuffer copy(CharArrayBuffer other, int markOfOther) {ReadOnlyCharArrayBuffer buf = new ReadOnlyCharArrayBuffer(other.capacity(), other.backingArray, other.offset);buf.limit = other.limit();buf.position = other.position();buf.mark = markOfOther;return buf;}
public CharBuffer asReadOnlyBuffer() {return duplicate();}
public CharBuffer compact() {throw new ReadOnlyBufferException();}
public CharBuffer duplicate() {return copy(this, mark);}
public boolean isReadOnly() {return true;}
protected char[] protectedArray() {throw new ReadOnlyBufferException();}
protected int protectedArrayOffset() {throw new ReadOnlyBufferException();}
protected boolean protectedHasArray() {return false;}
public CharBuffer put(char c) {throw new ReadOnlyBufferException();}
public CharBuffer put(int index, char c) {throw new ReadOnlyBufferException();}
public final CharBuffer put(char[] src, int off, int len) {throw new ReadOnlyBufferException();}
public final CharBuffer put(CharBuffer src) {throw new ReadOnlyBufferException();}
public CharBuffer put(String src, int start, int end) {if ((start < 0) || (end < 0) || (long) start + (long) end > src.length()) {throw new IndexOutOfBoundsException();}throw new ReadOnlyBufferException();}
public CharBuffer slice() {return new ReadOnlyCharArrayBuffer(remaining(), backingArray, offset + position);}public static boolean left() {return Gdx.input.isButtonPressed(Buttons.LEFT);}
public static boolean left(int button) {return button == Buttons.LEFT;}
public static boolean right() {return Gdx.input.isButtonPressed(Buttons.RIGHT);}
public static boolean right(int button) {return button == Buttons.RIGHT;}
public static boolean middle() {return Gdx.input.isButtonPressed(Buttons.MIDDLE);}
public static boolean middle(int button) {return button == Buttons.MIDDLE;}
public static boolean shift() {return Gdx.input.isKeyPressed(Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Keys.SHIFT_RIGHT);}
public static boolean shift(int keycode) {return keycode == Keys.SHIFT_LEFT || keycode == Keys.SHIFT_RIGHT;}
public static boolean ctrl() {if (isMac)return Gdx.input.isKeyPressed(Keys.SYM);elsereturn Gdx.input.isKeyPressed(Keys.CONTROL_LEFT) || Gdx.input.isKeyPressed(Keys.CONTROL_RIGHT);}
public static boolean ctrl(int keycode) {if (isMac)return keycode == Keys.SYM;elsereturn keycode == Keys.CONTROL_LEFT || keycode == Keys.CONTROL_RIGHT;}
public static boolean alt() {return Gdx.input.isKeyPressed(Keys.ALT_LEFT) || Gdx.input.isKeyPressed(Keys.ALT_RIGHT);}
public static boolean alt(int keycode) {return keycode == Keys.ALT_LEFT || keycode == Keys.ALT_RIGHT;}public boolean onGenericMotion(MotionEvent event, AndroidInput input) {if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0)return false;final int action = event.getAction() & MotionEvent.ACTION_MASK;int x = 0, y = 0;int scrollAmount = 0;long timeStamp = System.nanoTime();synchronized (input) {switch(action) {case MotionEvent.ACTION_HOVER_MOVE:x = (int) event.getX();y = (int) event.getY();if ((x != deltaX) || (y != deltaY)) {// Avoid garbage eventspostTouchEvent(input, TouchEvent.TOUCH_MOVED, x, y, 0, timeStamp);deltaX = x;deltaY = y;}break;case MotionEvent.ACTION_SCROLL:scrollAmount = (int) -Math.signum(event.getAxisValue(MotionEvent.AXIS_VSCROLL));postTouchEvent(input, TouchEvent.TOUCH_SCROLLED, 0, 0, scrollAmount, timeStamp);}}Gdx.app.getGraphics().requestRendering();return true;}
private void logAction(int action) {String actionStr = "";if (action == MotionEvent.ACTION_HOVER_ENTER)actionStr = "HOVER_ENTER";else if (action == MotionEvent.ACTION_HOVER_MOVE)actionStr = "HOVER_MOVE";else if (action == MotionEvent.ACTION_HOVER_EXIT)actionStr = "HOVER_EXIT";else if (action == MotionEvent.ACTION_SCROLL)actionStr = "SCROLL";elseactionStr = "UNKNOWN (" + action + ")";Gdx.app.log("AndroidMouseHandler", "action " + actionStr);}
private void postTouchEvent(AndroidInput input, int type, int x, int y, int scrollAmount, long timeStamp) {TouchEvent event = input.usedTouchEvents.obtain();event.timeStamp = timeStamp;event.x = x;event.y = y;event.type = type;event.scrollAmount = scrollAmount;input.touchEvents.add(event);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btFace obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btFace(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setIndices(SWIGTYPE_p_btAlignedObjectArrayT_int_t value) {CollisionJNI.btFace_indices_set(swigCPtr, this, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(value));}
public SWIGTYPE_p_btAlignedObjectArrayT_int_t getIndices() {long cPtr = CollisionJNI.btFace_indices_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_btAlignedObjectArrayT_int_t(cPtr, false);}
public void setPlane(float[] value) {CollisionJNI.btFace_plane_set(swigCPtr, this, value);}
public float[] getPlane() {return CollisionJNI.btFace_plane_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btTriangleRaycastCallback_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btTriangleRaycastCallback obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btTriangleRaycastCallback(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void swigDirectorDisconnect() {swigCMemOwn = false;delete();}
public void swigReleaseOwnership() {swigCMemOwn = false;CollisionJNI.btTriangleRaycastCallback_change_ownership(this, swigCPtr, false);}
public void swigTakeOwnership() {swigCMemOwn = true;CollisionJNI.btTriangleRaycastCallback_change_ownership(this, swigCPtr, true);}
public void setFrom(btVector3 value) {CollisionJNI.btTriangleRaycastCallback_from_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getFrom() {long cPtr = CollisionJNI.btTriangleRaycastCallback_from_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setTo(btVector3 value) {CollisionJNI.btTriangleRaycastCallback_to_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getTo() {long cPtr = CollisionJNI.btTriangleRaycastCallback_to_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setFlags(long value) {CollisionJNI.btTriangleRaycastCallback_flags_set(swigCPtr, this, value);}
public long getFlags() {return CollisionJNI.btTriangleRaycastCallback_flags_get(swigCPtr, this);}
public void setHitFraction(float value) {CollisionJNI.btTriangleRaycastCallback_hitFraction_set(swigCPtr, this, value);}
public float getHitFraction() {return CollisionJNI.btTriangleRaycastCallback_hitFraction_get(swigCPtr, this);}
public void processTriangle(btVector3 triangle, int partId, int triangleIndex) {if (getClass() == btTriangleRaycastCallback.class)CollisionJNI.btTriangleRaycastCallback_processTriangle(swigCPtr, this, btVector3.getCPtr(triangle), triangle, partId, triangleIndex);elseCollisionJNI.btTriangleRaycastCallback_processTriangleSwigExplicitbtTriangleRaycastCallback(swigCPtr, this, btVector3.getCPtr(triangle), triangle, partId, triangleIndex);}
public float reportHit(Vector3 hitNormalLocal, float hitFraction, int partId, int triangleIndex) {return CollisionJNI.btTriangleRaycastCallback_reportHit(swigCPtr, this, hitNormalLocal, hitFraction, partId, triangleIndex);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btTypedConstraintFloatData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btTypedConstraintFloatData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setRbA(btRigidBodyFloatData value) {DynamicsJNI.btTypedConstraintFloatData_rbA_set(swigCPtr, this, btRigidBodyFloatData.getCPtr(value), value);}
public btRigidBodyFloatData getRbA() {long cPtr = DynamicsJNI.btTypedConstraintFloatData_rbA_get(swigCPtr, this);return (cPtr == 0) ? null : new btRigidBodyFloatData(cPtr, false);}
public void setRbB(btRigidBodyFloatData value) {DynamicsJNI.btTypedConstraintFloatData_rbB_set(swigCPtr, this, btRigidBodyFloatData.getCPtr(value), value);}
public btRigidBodyFloatData getRbB() {long cPtr = DynamicsJNI.btTypedConstraintFloatData_rbB_get(swigCPtr, this);return (cPtr == 0) ? null : new btRigidBodyFloatData(cPtr, false);}
public void setName(String value) {DynamicsJNI.btTypedConstraintFloatData_name_set(swigCPtr, this, value);}
public String getName() {return DynamicsJNI.btTypedConstraintFloatData_name_get(swigCPtr, this);}
public void setObjectType(int value) {DynamicsJNI.btTypedConstraintFloatData_objectType_set(swigCPtr, this, value);}
public int getObjectType() {return DynamicsJNI.btTypedConstraintFloatData_objectType_get(swigCPtr, this);}
public void setUserConstraintType(int value) {DynamicsJNI.btTypedConstraintFloatData_userConstraintType_set(swigCPtr, this, value);}
public int getUserConstraintType() {return DynamicsJNI.btTypedConstraintFloatData_userConstraintType_get(swigCPtr, this);}
public void setUserConstraintId(int value) {DynamicsJNI.btTypedConstraintFloatData_userConstraintId_set(swigCPtr, this, value);}
public int getUserConstraintId() {return DynamicsJNI.btTypedConstraintFloatData_userConstraintId_get(swigCPtr, this);}
public void setNeedsFeedback(int value) {DynamicsJNI.btTypedConstraintFloatData_needsFeedback_set(swigCPtr, this, value);}
public int getNeedsFeedback() {return DynamicsJNI.btTypedConstraintFloatData_needsFeedback_get(swigCPtr, this);}
public void setAppliedImpulse(float value) {DynamicsJNI.btTypedConstraintFloatData_appliedImpulse_set(swigCPtr, this, value);}
public float getAppliedImpulse() {return DynamicsJNI.btTypedConstraintFloatData_appliedImpulse_get(swigCPtr, this);}
public void setDbgDrawSize(float value) {DynamicsJNI.btTypedConstraintFloatData_dbgDrawSize_set(swigCPtr, this, value);}
public float getDbgDrawSize() {return DynamicsJNI.btTypedConstraintFloatData_dbgDrawSize_get(swigCPtr, this);}
public void setDisableCollisionsBetweenLinkedBodies(int value) {DynamicsJNI.btTypedConstraintFloatData_disableCollisionsBetweenLinkedBodies_set(swigCPtr, this, value);}
public int getDisableCollisionsBetweenLinkedBodies() {return DynamicsJNI.btTypedConstraintFloatData_disableCollisionsBetweenLinkedBodies_get(swigCPtr, this);}
public void setOverrideNumSolverIterations(int value) {DynamicsJNI.btTypedConstraintFloatData_overrideNumSolverIterations_set(swigCPtr, this, value);}
public int getOverrideNumSolverIterations() {return DynamicsJNI.btTypedConstraintFloatData_overrideNumSolverIterations_get(swigCPtr, this);}
public void setBreakingImpulseThreshold(float value) {DynamicsJNI.btTypedConstraintFloatData_breakingImpulseThreshold_set(swigCPtr, this, value);}
public float getBreakingImpulseThreshold() {return DynamicsJNI.btTypedConstraintFloatData_breakingImpulseThreshold_get(swigCPtr, this);}
public void setIsEnabled(int value) {DynamicsJNI.btTypedConstraintFloatData_isEnabled_set(swigCPtr, this, value);}
public int getIsEnabled() {return DynamicsJNI.btTypedConstraintFloatData_isEnabled_get(swigCPtr, this);}public void play() {if (isPlaying())return;if (sound.getPaused()) {resume();return;}soundOptions.volume = (int) (volume * 100);soundOptions.pan = (int) (pan * 100);soundOptions.loops = 1;soundOptions.from = 0;sound.play(soundOptions);isPlaying = true;}
public void resume() {sound.resume();}
public void pause() {sound.pause();isPlaying = false;}
public void stop() {sound.stop();isPlaying = false;}
public boolean isPlaying() {isPlaying &= sound.getPlayState() == 1;return isPlaying;}
public void setLooping(boolean isLooping) {this.isLooping = isLooping;}
public boolean isLooping() {return isLooping;}
public void setVolume(float volume) {sound.setVolume((int) (volume * 100));this.volume = volume;}
public float getVolume() {return volume;}
public void setPan(float pan, float volume) {sound.setPan((int) (pan * 100));sound.setVolume((int) (volume * 100));this.pan = pan;this.volume = volume;}
public void setPosition(float position) {sound.setPosition((int) (position * 1000f));}
public float getPosition() {return sound.getPosition() / 1000f;}
public void dispose() {sound.destruct();}
public void setOnCompletionListener(OnCompletionListener listener) {onCompletionListener = listener;}
public void onfinish() {if (isLooping)play();else if (onCompletionListener != null)onCompletionListener.onCompletion(this);}public void lerpAngleDeg() {assertEquals(10, MathUtils.lerpAngleDeg(10, 30, 0.0f), 0.01f);assertEquals(20, MathUtils.lerpAngleDeg(10, 30, 0.5f), 0.01f);assertEquals(30, MathUtils.lerpAngleDeg(10, 30, 1.0f), 0.01f);}
public void lerpAngleDegCrossingZero() {assertEquals(350, MathUtils.lerpAngleDeg(350, 10, 0.0f), 0.01f);assertEquals(0, MathUtils.lerpAngleDeg(350, 10, 0.5f), 0.01f);assertEquals(10, MathUtils.lerpAngleDeg(350, 10, 1.0f), 0.01f);}
public void lerpAngleDegCrossingZeroBackwards() {assertEquals(10, MathUtils.lerpAngleDeg(10, 350, 0.0f), 0.01f);assertEquals(0, MathUtils.lerpAngleDeg(10, 350, 0.5f), 0.01f);assertEquals(350, MathUtils.lerpAngleDeg(10, 350, 1.0f), 0.01f);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(RayResultCallback obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_RayResultCallback(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void swigDirectorDisconnect() {swigCMemOwn = false;delete();}
public void swigReleaseOwnership() {swigCMemOwn = false;CollisionJNI.RayResultCallback_change_ownership(this, swigCPtr, false);}
public void swigTakeOwnership() {swigCMemOwn = true;CollisionJNI.RayResultCallback_change_ownership(this, swigCPtr, true);}
public void setClosestHitFraction(float value) {CollisionJNI.RayResultCallback_closestHitFraction_set(swigCPtr, this, value);}
public float getClosestHitFraction() {return CollisionJNI.RayResultCallback_closestHitFraction_get(swigCPtr, this);}
public void setCollisionObject(btCollisionObject value) {CollisionJNI.RayResultCallback_collisionObject_set(swigCPtr, this, btCollisionObject.getCPtr(value), value);}
public btCollisionObject getCollisionObject() {return btCollisionObject.getInstance(CollisionJNI.RayResultCallback_collisionObject_get(swigCPtr, this), false);}
public void setCollisionFilterGroup(short value) {CollisionJNI.RayResultCallback_collisionFilterGroup_set(swigCPtr, this, value);}
public short getCollisionFilterGroup() {return CollisionJNI.RayResultCallback_collisionFilterGroup_get(swigCPtr, this);}
public void setCollisionFilterMask(short value) {CollisionJNI.RayResultCallback_collisionFilterMask_set(swigCPtr, this, value);}
public short getCollisionFilterMask() {return CollisionJNI.RayResultCallback_collisionFilterMask_get(swigCPtr, this);}
public void setFlags(long value) {CollisionJNI.RayResultCallback_flags_set(swigCPtr, this, value);}
public long getFlags() {return CollisionJNI.RayResultCallback_flags_get(swigCPtr, this);}
public boolean hasHit() {return CollisionJNI.RayResultCallback_hasHit(swigCPtr, this);}
public boolean needsCollision(btBroadphaseProxy proxy0) {return (getClass() == RayResultCallback.class) ? CollisionJNI.RayResultCallback_needsCollision(swigCPtr, this, btBroadphaseProxy.getCPtr(proxy0), proxy0) : CollisionJNI.RayResultCallback_needsCollisionSwigExplicitRayResultCallback(swigCPtr, this, btBroadphaseProxy.getCPtr(proxy0), proxy0);}
public float addSingleResult(LocalRayResult rayResult, boolean normalInWorldSpace) {return CollisionJNI.RayResultCallback_addSingleResult(swigCPtr, this, LocalRayResult.getCPtr(rayResult), rayResult, normalInWorldSpace);}public boolean shouldCollide(Fixture fixtureA, Fixture fixtureB) {Filter filterA = fixtureA.getFilterData();Filter filterB = fixtureB.getFilterData();if (filterA.groupIndex == filterB.groupIndex && filterA.groupIndex != 0) {return filterA.groupIndex > 0;}boolean collide = (filterA.maskBits & filterB.categoryBits) != 0 && (filterA.categoryBits & filterB.maskBits) != 0;return collide;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btBlock obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_btBlock(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setPrevious(btBlock value) {LinearMathJNI.btBlock_previous_set(swigCPtr, this, btBlock.getCPtr(value), value);}
public btBlock getPrevious() {long cPtr = LinearMathJNI.btBlock_previous_get(swigCPtr, this);return (cPtr == 0) ? null : new btBlock(cPtr, false);}
public void setAddress(java.nio.ByteBuffer value) {assert value.isDirect() : "Buffer must be allocated direct.";{LinearMathJNI.btBlock_address_set(swigCPtr, this, value);}}
public java.nio.ByteBuffer getAddress() {return LinearMathJNI.btBlock_address_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btPairCachingGhostObject_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btPairCachingGhostObject obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btPairCachingGhostObject(swigCPtr);}swigCPtr = 0;}super.delete();}
public void addOverlappingObjectInternal(btBroadphaseProxy otherProxy, btBroadphaseProxy thisProxy) {CollisionJNI.btPairCachingGhostObject_addOverlappingObjectInternal__SWIG_0(swigCPtr, this, btBroadphaseProxy.getCPtr(otherProxy), otherProxy, btBroadphaseProxy.getCPtr(thisProxy), thisProxy);}
public void addOverlappingObjectInternal(btBroadphaseProxy otherProxy) {CollisionJNI.btPairCachingGhostObject_addOverlappingObjectInternal__SWIG_1(swigCPtr, this, btBroadphaseProxy.getCPtr(otherProxy), otherProxy);}
public void removeOverlappingObjectInternal(btBroadphaseProxy otherProxy, btDispatcher dispatcher, btBroadphaseProxy thisProxy) {CollisionJNI.btPairCachingGhostObject_removeOverlappingObjectInternal__SWIG_0(swigCPtr, this, btBroadphaseProxy.getCPtr(otherProxy), otherProxy, btDispatcher.getCPtr(dispatcher), dispatcher, btBroadphaseProxy.getCPtr(thisProxy), thisProxy);}
public void removeOverlappingObjectInternal(btBroadphaseProxy otherProxy, btDispatcher dispatcher) {CollisionJNI.btPairCachingGhostObject_removeOverlappingObjectInternal__SWIG_1(swigCPtr, this, btBroadphaseProxy.getCPtr(otherProxy), otherProxy, btDispatcher.getCPtr(dispatcher), dispatcher);}
public btHashedOverlappingPairCache getOverlappingPairCache() {long cPtr = CollisionJNI.btPairCachingGhostObject_getOverlappingPairCache(swigCPtr, this);return (cPtr == 0) ? null : new btHashedOverlappingPairCache(cPtr, false);}public void spawnAux(Vector3 vector, float percent) {//Generate the point on the surface of the spherefloat width = spawnWidth + spawnWidthDiff * spawnWidthValue.getScale(percent);float height = spawnHeight + spawnHeightDiff * spawnHeightValue.getScale(percent);float depth = spawnDepth + spawnDepthDiff * spawnDepthValue.getScale(percent);float radiusX, radiusY, radiusZ;//Where generate the point, on edges or inside ?float minT = 0, maxT = MathUtils.PI2;if (side == SpawnSide.top) {maxT = MathUtils.PI;} else if (side == SpawnSide.bottom) {maxT = -MathUtils.PI;}float t = MathUtils.random(minT, maxT);//Where generate the point, on edges or inside ?if (edges) {if (width == 0) {vector.set(0, height / 2 * MathUtils.sin(t), depth / 2 * MathUtils.cos(t));return;}if (height == 0) {vector.set(width / 2 * MathUtils.cos(t), 0, depth / 2 * MathUtils.sin(t));return;}if (depth == 0) {vector.set(width / 2 * MathUtils.cos(t), height / 2 * MathUtils.sin(t), 0);return;}radiusX = width / 2;radiusY = height / 2;radiusZ = depth / 2;} else {radiusX = MathUtils.random(width / 2);radiusY = MathUtils.random(height / 2);radiusZ = MathUtils.random(depth / 2);}float z = MathUtils.random(-1, 1f);float r = (float) Math.sqrt(1f - z * z);vector.set(radiusX * r * MathUtils.cos(t), radiusY * r * MathUtils.sin(t), radiusZ * z);}
public SpawnSide getSide() {return side;}
public void setSide(SpawnSide side) {this.side = side;}
public void load(ParticleValue value) {super.load(value);EllipseSpawnShapeValue shape = (EllipseSpawnShapeValue) value;side = shape.side;}
public SpawnShapeValue copy() {return new EllipseSpawnShapeValue(this);}
public void write(Json json) {super.write(json);json.writeValue("side", side);}
public void read(Json json, JsonValue jsonData) {super.read(json, jsonData);side = json.readValue("side", SpawnSide.class, jsonData);}public FileHandle resolve(String fileName) {return Gdx.files.classpath(fileName);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btGImpactShapeInterface_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btGImpactShapeInterface obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btGImpactShapeInterface(swigCPtr);}swigCPtr = 0;}super.delete();}
public void updateBound() {CollisionJNI.btGImpactShapeInterface_updateBound(swigCPtr, this);}
public void postUpdate() {CollisionJNI.btGImpactShapeInterface_postUpdate(swigCPtr, this);}
public btAABB getLocalBox() {return new btAABB(CollisionJNI.btGImpactShapeInterface_getLocalBox(swigCPtr, this), false);}
public int getShapeType() {return CollisionJNI.btGImpactShapeInterface_getShapeType(swigCPtr, this);}
public int getGImpactShapeType() {return CollisionJNI.btGImpactShapeInterface_getGImpactShapeType(swigCPtr, this);}
public btGImpactQuantizedBvh getBoxSet() {long cPtr = CollisionJNI.btGImpactShapeInterface_getBoxSet(swigCPtr, this);return (cPtr == 0) ? null : new btGImpactQuantizedBvh(cPtr, false);}
public boolean hasBoxSet() {return CollisionJNI.btGImpactShapeInterface_hasBoxSet(swigCPtr, this);}
public btPrimitiveManagerBase getPrimitiveManager() {long cPtr = CollisionJNI.btGImpactShapeInterface_getPrimitiveManager(swigCPtr, this);return (cPtr == 0) ? null : new btPrimitiveManagerBase(cPtr, false);}
public int getNumChildShapes() {return CollisionJNI.btGImpactShapeInterface_getNumChildShapes(swigCPtr, this);}
public boolean childrenHasTransform() {return CollisionJNI.btGImpactShapeInterface_childrenHasTransform(swigCPtr, this);}
public boolean needsRetrieveTriangles() {return CollisionJNI.btGImpactShapeInterface_needsRetrieveTriangles(swigCPtr, this);}
public boolean needsRetrieveTetrahedrons() {return CollisionJNI.btGImpactShapeInterface_needsRetrieveTetrahedrons(swigCPtr, this);}
public void getBulletTriangle(int prim_index, btTriangleShapeEx triangle) {CollisionJNI.btGImpactShapeInterface_getBulletTriangle(swigCPtr, this, prim_index, btTriangleShapeEx.getCPtr(triangle), triangle);}
public void getBulletTetrahedron(int prim_index, btTetrahedronShapeEx tetrahedron) {CollisionJNI.btGImpactShapeInterface_getBulletTetrahedron(swigCPtr, this, prim_index, btTetrahedronShapeEx.getCPtr(tetrahedron), tetrahedron);}
public void lockChildShapes() {CollisionJNI.btGImpactShapeInterface_lockChildShapes(swigCPtr, this);}
public void unlockChildShapes() {CollisionJNI.btGImpactShapeInterface_unlockChildShapes(swigCPtr, this);}
public void getPrimitiveTriangle(int index, btPrimitiveTriangle triangle) {CollisionJNI.btGImpactShapeInterface_getPrimitiveTriangle(swigCPtr, this, index, btPrimitiveTriangle.getCPtr(triangle), triangle);}
public void getChildAabb(int child_index, Matrix4 t, Vector3 aabbMin, Vector3 aabbMax) {CollisionJNI.btGImpactShapeInterface_getChildAabb(swigCPtr, this, child_index, t, aabbMin, aabbMax);}
public btCollisionShape getChildShape(int index) {long cPtr = CollisionJNI.btGImpactShapeInterface_getChildShape__SWIG_0(swigCPtr, this, index);return (cPtr == 0) ? null : btCollisionShape.newDerivedObject(cPtr, false);}
public Matrix4 getChildTransform(int index) {return CollisionJNI.btGImpactShapeInterface_getChildTransform(swigCPtr, this, index);}
public void setChildTransform(int index, Matrix4 transform) {CollisionJNI.btGImpactShapeInterface_setChildTransform(swigCPtr, this, index, transform);}
public void rayTest(Vector3 rayFrom, Vector3 rayTo, RayResultCallback resultCallback) {CollisionJNI.btGImpactShapeInterface_rayTest(swigCPtr, this, rayFrom, rayTo, RayResultCallback.getCPtr(resultCallback), resultCallback);}
public void processAllTrianglesRay(btTriangleCallback arg0, Vector3 arg1, Vector3 arg2) {CollisionJNI.btGImpactShapeInterface_processAllTrianglesRay(swigCPtr, this, btTriangleCallback.getCPtr(arg0), arg0, arg1, arg2);}public static void main(String[] args) {SwingUtilities.invokeLater(new Runnable() {
@Overridepublic void run() {new LwjglCanvasTest();}});}
public void run() {new LwjglCanvasTest();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btScaledBvhTriangleMeshShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btScaledBvhTriangleMeshShape obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btScaledBvhTriangleMeshShape(swigCPtr);}swigCPtr = 0;}super.delete();}
public btBvhTriangleMeshShape getChildShape() {long cPtr = CollisionJNI.btScaledBvhTriangleMeshShape_getChildShape__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : new btBvhTriangleMeshShape(cPtr, false);}public void set(final ManifoldPoint cp) {localPoint.set(cp.localPoint);normalImpulse = cp.normalImpulse;tangentImpulse = cp.tangentImpulse;id.set(cp.id);}private int next(int idx) {return (idx + 1) % queue.length();}
public boolean put(T value) {int write = writeIndex.get();int read = readIndex.get();int next = next(write);if (next == read)return false;queue.set(write, value);writeIndex.set(next);return true;}
public T poll() {int read = readIndex.get();int write = writeIndex.get();if (read == write)return null;T value = queue.get(read);readIndex.set(next(read));return value;}public void draw(Batch batch, float parentAlpha) {// if this actor is not within the view of the camera we don't draw it.if (isCulled())return;// otherwise we draw via the super class methodsuper.draw(batch, parentAlpha);}
private boolean isCulled() {// Group.float stageX = getX();float stageY = getY();// parents are rotated or scaled!Actor parent = this.getParent();while (parent != null) {stageX += parent.getX();stageY += parent.getY();parent = parent.getParent();}// not rotated!actorRect.set(stageX, stageY, getWidth(), getHeight());camRect.set(camera.position.x - camera.viewportWidth / 2.0f, camera.position.y - camera.viewportHeight / 2.0f, camera.viewportWidth, camera.viewportHeight);visible = camRect.overlaps(actorRect);return !visible;}
public void create() {// create a stage and a camera controller so we can pan the view.stage = new Stage();;// we know it's an ortho cam at this point!camController = new OrthoCamController((OrthographicCamera) stage.getCamera());Gdx.input.setInputProcessor(camController);// load a dummy texturetexture = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));// populate the stage with some actors and groups.for (int i = 0; i < 5000; i++) {Actor img = new CullableActor("img" + i, texture, (OrthographicCamera) stage.getCamera());img.setX((float) Math.random() * 480 * 10);img.setY((float) Math.random() * 320 * 10);stage.addActor(img);}// we also want to output the number of visible actors, so we need a SpriteBatch and a BitmapFontbatch = new SpriteBatch();font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);}
public void render() {Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);stage.draw();// check how many actors are visible.Array<Actor> actors = stage.getActors();int numVisible = 0;for (int i = 0; i < actors.size; i++) {numVisible += ((CullableActor) actors.get(i)).visible ? 1 : 0;}batch.begin();font.draw(batch, "Visible: " + numVisible + ", fps: " + Gdx.graphics.getFramesPerSecond(), 20, 30);batch.end();}
public void dispose() {stage.dispose();texture.dispose();batch.dispose();font.dispose();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btPolyhedralConvexShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btPolyhedralConvexShape obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btPolyhedralConvexShape(swigCPtr);}swigCPtr = 0;}super.delete();}
public boolean initializePolyhedralFeatures(int shiftVerticesByMargin) {return CollisionJNI.btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_0(swigCPtr, this, shiftVerticesByMargin);}
public boolean initializePolyhedralFeatures() {return CollisionJNI.btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_1(swigCPtr, this);}
public btConvexPolyhedron getConvexPolyhedron() {long cPtr = CollisionJNI.btPolyhedralConvexShape_getConvexPolyhedron(swigCPtr, this);return (cPtr == 0) ? null : new btConvexPolyhedron(cPtr, false);}
public int getNumVertices() {return CollisionJNI.btPolyhedralConvexShape_getNumVertices(swigCPtr, this);}
public int getNumEdges() {return CollisionJNI.btPolyhedralConvexShape_getNumEdges(swigCPtr, this);}
public void getEdge(int i, Vector3 pa, Vector3 pb) {CollisionJNI.btPolyhedralConvexShape_getEdge(swigCPtr, this, i, pa, pb);}
public void getVertex(int i, Vector3 vtx) {CollisionJNI.btPolyhedralConvexShape_getVertex(swigCPtr, this, i, vtx);}
public int getNumPlanes() {return CollisionJNI.btPolyhedralConvexShape_getNumPlanes(swigCPtr, this);}
public void getPlane(Vector3 planeNormal, Vector3 planeSupport, int i) {CollisionJNI.btPolyhedralConvexShape_getPlane(swigCPtr, this, planeNormal, planeSupport, i);}
public boolean isInside(Vector3 pt, float tolerance) {return CollisionJNI.btPolyhedralConvexShape_isInside(swigCPtr, this, pt, tolerance);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btQuantizedBvhDoubleData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btQuantizedBvhDoubleData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setBvhAabbMin(btVector3DoubleData value) {CollisionJNI.btQuantizedBvhDoubleData_bvhAabbMin_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getBvhAabbMin() {long cPtr = CollisionJNI.btQuantizedBvhDoubleData_bvhAabbMin_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setBvhAabbMax(btVector3DoubleData value) {CollisionJNI.btQuantizedBvhDoubleData_bvhAabbMax_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getBvhAabbMax() {long cPtr = CollisionJNI.btQuantizedBvhDoubleData_bvhAabbMax_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setBvhQuantization(btVector3DoubleData value) {CollisionJNI.btQuantizedBvhDoubleData_bvhQuantization_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getBvhQuantization() {long cPtr = CollisionJNI.btQuantizedBvhDoubleData_bvhQuantization_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setCurNodeIndex(int value) {CollisionJNI.btQuantizedBvhDoubleData_curNodeIndex_set(swigCPtr, this, value);}
public int getCurNodeIndex() {return CollisionJNI.btQuantizedBvhDoubleData_curNodeIndex_get(swigCPtr, this);}
public void setUseQuantization(int value) {CollisionJNI.btQuantizedBvhDoubleData_useQuantization_set(swigCPtr, this, value);}
public int getUseQuantization() {return CollisionJNI.btQuantizedBvhDoubleData_useQuantization_get(swigCPtr, this);}
public void setNumContiguousLeafNodes(int value) {CollisionJNI.btQuantizedBvhDoubleData_numContiguousLeafNodes_set(swigCPtr, this, value);}
public int getNumContiguousLeafNodes() {return CollisionJNI.btQuantizedBvhDoubleData_numContiguousLeafNodes_get(swigCPtr, this);}
public void setNumQuantizedContiguousNodes(int value) {CollisionJNI.btQuantizedBvhDoubleData_numQuantizedContiguousNodes_set(swigCPtr, this, value);}
public int getNumQuantizedContiguousNodes() {return CollisionJNI.btQuantizedBvhDoubleData_numQuantizedContiguousNodes_get(swigCPtr, this);}
public void setContiguousNodesPtr(btOptimizedBvhNodeDoubleData value) {CollisionJNI.btQuantizedBvhDoubleData_contiguousNodesPtr_set(swigCPtr, this, btOptimizedBvhNodeDoubleData.getCPtr(value), value);}
public btOptimizedBvhNodeDoubleData getContiguousNodesPtr() {long cPtr = CollisionJNI.btQuantizedBvhDoubleData_contiguousNodesPtr_get(swigCPtr, this);return (cPtr == 0) ? null : new btOptimizedBvhNodeDoubleData(cPtr, false);}
public void setQuantizedContiguousNodesPtr(btQuantizedBvhNodeData value) {CollisionJNI.btQuantizedBvhDoubleData_quantizedContiguousNodesPtr_set(swigCPtr, this, btQuantizedBvhNodeData.getCPtr(value), value);}
public btQuantizedBvhNodeData getQuantizedContiguousNodesPtr() {long cPtr = CollisionJNI.btQuantizedBvhDoubleData_quantizedContiguousNodesPtr_get(swigCPtr, this);return (cPtr == 0) ? null : new btQuantizedBvhNodeData(cPtr, false);}
public void setTraversalMode(int value) {CollisionJNI.btQuantizedBvhDoubleData_traversalMode_set(swigCPtr, this, value);}
public int getTraversalMode() {return CollisionJNI.btQuantizedBvhDoubleData_traversalMode_get(swigCPtr, this);}
public void setNumSubtreeHeaders(int value) {CollisionJNI.btQuantizedBvhDoubleData_numSubtreeHeaders_set(swigCPtr, this, value);}
public int getNumSubtreeHeaders() {return CollisionJNI.btQuantizedBvhDoubleData_numSubtreeHeaders_get(swigCPtr, this);}
public void setSubTreeInfoPtr(btBvhSubtreeInfoData value) {CollisionJNI.btQuantizedBvhDoubleData_subTreeInfoPtr_set(swigCPtr, this, btBvhSubtreeInfoData.getCPtr(value), value);}
public btBvhSubtreeInfoData getSubTreeInfoPtr() {long cPtr = CollisionJNI.btQuantizedBvhDoubleData_subTreeInfoPtr_get(swigCPtr, this);return (cPtr == 0) ? null : new btBvhSubtreeInfoData(cPtr, false);}public void create() {ShaderProgram.pedantic = false;/* * shader = new ShaderProgram(Gdx.files.internal("data/shaders/default.vert").readString(), Gdx.files.internal( * "data/shaders/depthtocolor.frag").readString()); if (!shader.isCompiled()) { Gdx.app.log("EdgeDetectionTest", * "couldn't compile scene shader: " + shader.getLog()); } */batchShader = new ShaderProgram(Gdx.files.internal("data/shaders/batch.vert").readString(), Gdx.files.internal("data/shaders/convolution.frag").readString());if (!batchShader.isCompiled()) {Gdx.app.log("EdgeDetectionTest", "couldn't compile post-processing shader: " + batchShader.getLog());}ObjLoader objLoader = new ObjLoader();scene = objLoader.loadModel(Gdx.files.internal("data/scene.obj"));sceneInstance = new ModelInstance(scene);modelBatch = new ModelBatch();fbo = new FrameBuffer(Format.RGB565, Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);cam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());cam.position.set(0, 0, 10);cam.lookAt(0, 0, 0);cam.far = 30;batch = new SpriteBatch();batch.setShader(batchShader);fboRegion = new TextureRegion(fbo.getColorBufferTexture());fboRegion.flip(false, true);logger = new FPSLogger();calculateOffsets();}
public void dispose() {batchShader.dispose();scene.dispose();fbo.dispose();batch.dispose();}
private void calculateOffsets() {int idx = 0;for (int y = -1; y <= 1; y++) {for (int x = -1; x <= 1; x++) {offsets[idx++] = x / (float) Gdx.graphics.getWidth();offsets[idx++] = y / (float) Gdx.graphics.getHeight();}}System.out.println(Arrays.toString(offsets));}
public void render() {angle += 45 * Gdx.graphics.getDeltaTime();Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);cam.update();matrix.setToRotation(0, 1, 0, angle);cam.combined.mul(matrix);fbo.begin();Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);Gdx.gl.glEnable(GL20.GL_DEPTH_TEST);modelBatch.begin(cam);modelBatch.render(sceneInstance);modelBatch.end();fbo.end();batch.begin();batch.disableBlending();batchShader.setUniformi("u_filterSize", filter.length);batchShader.setUniform1fv("u_filter", filter, 0, filter.length);batchShader.setUniform2fv("u_offsets", offsets, 0, offsets.length);batch.draw(fboRegion, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());batch.end();logger.log();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btTransform obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_btTransform(swigCPtr);}swigCPtr = 0;}super.delete();}
public void mult(Matrix4 t1, Matrix4 t2) {LinearMathJNI.btTransform_mult(swigCPtr, this, t1, t2);}
public Matrix3 getBasis() {return LinearMathJNI.btTransform_getBasis__SWIG_0(swigCPtr, this);}
public Vector3 getOrigin() {return LinearMathJNI.btTransform_getOrigin__SWIG_0(swigCPtr, this);}
public Quaternion getRotation() {return LinearMathJNI.btTransform_getRotation(swigCPtr, this);}
public void setFromOpenGLMatrix(float[] m) {LinearMathJNI.btTransform_setFromOpenGLMatrix(swigCPtr, this, m);}
public void getOpenGLMatrix(float[] m) {LinearMathJNI.btTransform_getOpenGLMatrix(swigCPtr, this, m);}
public void setOrigin(Vector3 origin) {LinearMathJNI.btTransform_setOrigin(swigCPtr, this, origin);}
public Vector3 invXform(Vector3 inVec) {return LinearMathJNI.btTransform_invXform(swigCPtr, this, inVec);}
public void setBasis(Matrix3 basis) {LinearMathJNI.btTransform_setBasis(swigCPtr, this, basis);}
public void setRotation(Quaternion q) {LinearMathJNI.btTransform_setRotation(swigCPtr, this, q);}
public void setIdentity() {LinearMathJNI.btTransform_setIdentity(swigCPtr, this);}
public Matrix4 inverse() {return LinearMathJNI.btTransform_inverse(swigCPtr, this);}
public Matrix4 inverseTimes(Matrix4 t) {return LinearMathJNI.btTransform_inverseTimes(swigCPtr, this, t);}
public static Matrix4 getIdentity() {return LinearMathJNI.btTransform_getIdentity();}
public void serialize(btTransformFloatData dataOut) {LinearMathJNI.btTransform_serialize(swigCPtr, this, btTransformFloatData.getCPtr(dataOut), dataOut);}
public void serializeFloat(btTransformFloatData dataOut) {LinearMathJNI.btTransform_serializeFloat(swigCPtr, this, btTransformFloatData.getCPtr(dataOut), dataOut);}
public void deSerialize(btTransformFloatData dataIn) {LinearMathJNI.btTransform_deSerialize(swigCPtr, this, btTransformFloatData.getCPtr(dataIn), dataIn);}
public void deSerializeDouble(btTransformDoubleData dataIn) {LinearMathJNI.btTransform_deSerializeDouble(swigCPtr, this, btTransformDoubleData.getCPtr(dataIn), dataIn);}
public void deSerializeFloat(btTransformFloatData dataIn) {LinearMathJNI.btTransform_deSerializeFloat(swigCPtr, this, btTransformFloatData.getCPtr(dataIn), dataIn);}public static void copyStream(InputStream input, OutputStream output) {copyStream(input, output, new byte[DEFAULT_BUFFER_SIZE]);}
public static void copyStream(InputStream input, OutputStream output, int bufferSize) {copyStream(input, output, new byte[bufferSize]);}
public static void copyStream(InputStream input, OutputStream output, byte[] buffer) {int bytesRead;while ((bytesRead = input.read(buffer)) != -1) {output.write(buffer, 0, bytesRead);}}
public static void copyStream(InputStream input, ByteBuffer output) {copyStream(input, output, new byte[DEFAULT_BUFFER_SIZE]);}
public static void copyStream(InputStream input, ByteBuffer output, int bufferSize) {copyStream(input, output, new byte[bufferSize]);}
public static int copyStream(InputStream input, ByteBuffer output, byte[] buffer) {int startPosition = output.position(), total = 0, bytesRead;while ((bytesRead = input.read(buffer)) != -1) {BufferUtils.copy(buffer, 0, output, bytesRead);total += bytesRead;output.position(startPosition + total);}output.position(startPosition);return total;}
public static byte[] copyStreamToByteArray(InputStream input) {return copyStreamToByteArray(input, input.available());}
public static byte[] copyStreamToByteArray(InputStream input, int estimatedSize) {ByteArrayOutputStream baos = new OptimizedByteArrayOutputStream(Math.max(0, estimatedSize));copyStream(input, baos);return baos.toByteArray();}
public static String copyStreamToString(InputStream input) {return copyStreamToString(input, input.available(), null);}
public static String copyStreamToString(InputStream input, int estimatedSize) {return copyStreamToString(input, estimatedSize, null);}
public static String copyStreamToString(InputStream input, int estimatedSize, String charset) {InputStreamReader reader = charset == null ? new InputStreamReader(input) : new InputStreamReader(input, charset);StringWriter writer = new StringWriter(Math.max(0, estimatedSize));char[] buffer = new char[DEFAULT_BUFFER_SIZE];int charsRead;while ((charsRead = reader.read(buffer)) != -1) {writer.write(buffer, 0, charsRead);}return writer.toString();}
public static void closeQuietly(Closeable c) {if (c != null) {try {c.close();} catch (Exception ignored) {}}}
public synchronized byte[] toByteArray() {if (count == buf.length)return buf;return super.toByteArray();}
public byte[] getBuffer() {return buf;}public int read() {return dis.read();}
public int read(byte b[], int off, int len) {return dis.read(b, off, len);}
public int read(byte b[]) {return dis.read(b);}
public final void readFully(byte b[]) {dis.readFully(b);}
public final void readFully(byte b[], int off, int len) {dis.readFully(b, off, len);}
public int skipBytes(int n) {return dis.skipBytes(n);}
public void write(int b) {dos.write(b);}
public void write(byte b[]) {dos.write(b);}
public void write(byte b[], int off, int len) {dos.write(b, off, len);}
public long getFilePointer() {return pos;}
public void seek(long pos) {if (pos < 0) {throw new IllegalArgumentException();}this.pos = (int) pos;}
public long length() {return len;}
public void setLength(long newLength) {if (len != newLength) {consolidate();if (data.length() > newLength) {data = data.substring(0, (int) newLength);len = (int) newLength;} else {// System.out.println("padding " + (newLength - len) + " zeros in setLength to " + newLength);while (len < newLength) {write(0);}}}}
public void close() {if (data != null) {flush();data = null;}}
void consolidate() {if (newData == null) {return;}if (data.length() < newDataPos) {StringBuilder filler = new StringBuilder();while (data.length() + filler.length() < newDataPos) {filler.append('\0');}data += filler.toString();}int p2 = newDataPos + newData.length();data = data.substring(0, newDataPos) + newData.toString() + (p2 < data.length() ? data.substring(p2) : "");newData = null;}
void flush() {if (!dirty) {return;}consolidate();File.LocalStorage.setItem(name, btoa(data));dirty = false;}
public final boolean readBoolean() {return dis.readBoolean();}
public final byte readByte() {return dis.readByte();}
public final int readUnsignedByte() {return dis.readUnsignedByte();}
public final short readShort() {return dis.readShort();}
public final int readUnsignedShort() {return dis.readUnsignedShort();}
public final char readChar() {return dis.readChar();}
public final int readInt() {return dis.readInt();}
public final long readLong() {return dis.readLong();}
public final float readFloat() {return dis.readFloat();}
public final double readDouble() {return dis.readDouble();}
public final String readLine() {return dis.readLine();}
public final String readUTF() {return dis.readUTF();}
public final void writeBoolean(boolean v) {dos.writeBoolean(v);}
public final void writeByte(int v) {dos.writeByte(v);}
public final void writeShort(int v) {dos.writeShort(v);}
public final void writeChar(int v) {dos.writeChar(v);}
public final void writeInt(int v) {dos.writeInt(v);}
public final void writeLong(long v) {dos.writeLong(v);}
public final void writeFloat(float v) {dos.writeFloat(v);}
public final void writeDouble(double v) {dos.writeDouble(v);}
public final void writeBytes(String s) {dos.writeBytes(s);}
public final void writeChars(String s) {dos.writeChars(s);}
public final void writeUTF(String str) {dos.writeUTF(str);}
public int read() {if (pos >= len) {return -1;} else {consolidate();return data.charAt(pos++);}}
public void write(int b) {if (!writeable) {throw new IOException("not writeable");}if (newData == null) {newDataPos = pos;newData = new StringBuilder();} else if (newDataPos + newData.length() != pos) {consolidate();newDataPos = pos;newData = new StringBuilder();}newData.append((char) (b & 255));// Character.forDigit(b & 15, 16));pos++;len = Math.max(pos, len);dirty = true;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btRotationalLimitMotor2 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btRotationalLimitMotor2(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setLoLimit(float value) {DynamicsJNI.btRotationalLimitMotor2_loLimit_set(swigCPtr, this, value);}
public float getLoLimit() {return DynamicsJNI.btRotationalLimitMotor2_loLimit_get(swigCPtr, this);}
public void setHiLimit(float value) {DynamicsJNI.btRotationalLimitMotor2_hiLimit_set(swigCPtr, this, value);}
public float getHiLimit() {return DynamicsJNI.btRotationalLimitMotor2_hiLimit_get(swigCPtr, this);}
public void setBounce(float value) {DynamicsJNI.btRotationalLimitMotor2_bounce_set(swigCPtr, this, value);}
public float getBounce() {return DynamicsJNI.btRotationalLimitMotor2_bounce_get(swigCPtr, this);}
public void setStopERP(float value) {DynamicsJNI.btRotationalLimitMotor2_stopERP_set(swigCPtr, this, value);}
public float getStopERP() {return DynamicsJNI.btRotationalLimitMotor2_stopERP_get(swigCPtr, this);}
public void setStopCFM(float value) {DynamicsJNI.btRotationalLimitMotor2_stopCFM_set(swigCPtr, this, value);}
public float getStopCFM() {return DynamicsJNI.btRotationalLimitMotor2_stopCFM_get(swigCPtr, this);}
public void setMotorERP(float value) {DynamicsJNI.btRotationalLimitMotor2_motorERP_set(swigCPtr, this, value);}
public float getMotorERP() {return DynamicsJNI.btRotationalLimitMotor2_motorERP_get(swigCPtr, this);}
public void setMotorCFM(float value) {DynamicsJNI.btRotationalLimitMotor2_motorCFM_set(swigCPtr, this, value);}
public float getMotorCFM() {return DynamicsJNI.btRotationalLimitMotor2_motorCFM_get(swigCPtr, this);}
public void setEnableMotor(boolean value) {DynamicsJNI.btRotationalLimitMotor2_enableMotor_set(swigCPtr, this, value);}
public boolean getEnableMotor() {return DynamicsJNI.btRotationalLimitMotor2_enableMotor_get(swigCPtr, this);}
public void setTargetVelocity(float value) {DynamicsJNI.btRotationalLimitMotor2_targetVelocity_set(swigCPtr, this, value);}
public float getTargetVelocity() {return DynamicsJNI.btRotationalLimitMotor2_targetVelocity_get(swigCPtr, this);}
public void setMaxMotorForce(float value) {DynamicsJNI.btRotationalLimitMotor2_maxMotorForce_set(swigCPtr, this, value);}
public float getMaxMotorForce() {return DynamicsJNI.btRotationalLimitMotor2_maxMotorForce_get(swigCPtr, this);}
public void setServoMotor(boolean value) {DynamicsJNI.btRotationalLimitMotor2_servoMotor_set(swigCPtr, this, value);}
public boolean getServoMotor() {return DynamicsJNI.btRotationalLimitMotor2_servoMotor_get(swigCPtr, this);}
public void setServoTarget(float value) {DynamicsJNI.btRotationalLimitMotor2_servoTarget_set(swigCPtr, this, value);}
public float getServoTarget() {return DynamicsJNI.btRotationalLimitMotor2_servoTarget_get(swigCPtr, this);}
public void setEnableSpring(boolean value) {DynamicsJNI.btRotationalLimitMotor2_enableSpring_set(swigCPtr, this, value);}
public boolean getEnableSpring() {return DynamicsJNI.btRotationalLimitMotor2_enableSpring_get(swigCPtr, this);}
public void setSpringStiffness(float value) {DynamicsJNI.btRotationalLimitMotor2_springStiffness_set(swigCPtr, this, value);}
public float getSpringStiffness() {return DynamicsJNI.btRotationalLimitMotor2_springStiffness_get(swigCPtr, this);}
public void setSpringStiffnessLimited(boolean value) {DynamicsJNI.btRotationalLimitMotor2_springStiffnessLimited_set(swigCPtr, this, value);}
public boolean getSpringStiffnessLimited() {return DynamicsJNI.btRotationalLimitMotor2_springStiffnessLimited_get(swigCPtr, this);}
public void setSpringDamping(float value) {DynamicsJNI.btRotationalLimitMotor2_springDamping_set(swigCPtr, this, value);}
public float getSpringDamping() {return DynamicsJNI.btRotationalLimitMotor2_springDamping_get(swigCPtr, this);}
public void setSpringDampingLimited(boolean value) {DynamicsJNI.btRotationalLimitMotor2_springDampingLimited_set(swigCPtr, this, value);}
public boolean getSpringDampingLimited() {return DynamicsJNI.btRotationalLimitMotor2_springDampingLimited_get(swigCPtr, this);}
public void setEquilibriumPoint(float value) {DynamicsJNI.btRotationalLimitMotor2_equilibriumPoint_set(swigCPtr, this, value);}
public float getEquilibriumPoint() {return DynamicsJNI.btRotationalLimitMotor2_equilibriumPoint_get(swigCPtr, this);}
public void setCurrentLimitError(float value) {DynamicsJNI.btRotationalLimitMotor2_currentLimitError_set(swigCPtr, this, value);}
public float getCurrentLimitError() {return DynamicsJNI.btRotationalLimitMotor2_currentLimitError_get(swigCPtr, this);}
public void setCurrentLimitErrorHi(float value) {DynamicsJNI.btRotationalLimitMotor2_currentLimitErrorHi_set(swigCPtr, this, value);}
public float getCurrentLimitErrorHi() {return DynamicsJNI.btRotationalLimitMotor2_currentLimitErrorHi_get(swigCPtr, this);}
public void setCurrentPosition(float value) {DynamicsJNI.btRotationalLimitMotor2_currentPosition_set(swigCPtr, this, value);}
public float getCurrentPosition() {return DynamicsJNI.btRotationalLimitMotor2_currentPosition_get(swigCPtr, this);}
public void setCurrentLimit(int value) {DynamicsJNI.btRotationalLimitMotor2_currentLimit_set(swigCPtr, this, value);}
public int getCurrentLimit() {return DynamicsJNI.btRotationalLimitMotor2_currentLimit_get(swigCPtr, this);}
public boolean isLimited() {return DynamicsJNI.btRotationalLimitMotor2_isLimited(swigCPtr, this);}
public void testLimitValue(float test_value) {DynamicsJNI.btRotationalLimitMotor2_testLimitValue(swigCPtr, this, test_value);}public static String getMachineString() {BytePtr name = BytePtr.toBytePtrAsciiZ("hw.machine");MachineSizedUIntPtr size = new MachineSizedUIntPtr();sysctlbyname(name, null, size, null, 0);BytePtr machine = Struct.allocate(BytePtr.class, (int) size.get());sysctlbyname(name, machine.as(VoidPtr.class), size, null, 0);return machine.toStringAsciiZ();}public PerformanceCounter add(final String name, final int windowSize) {PerformanceCounter result = new PerformanceCounter(name, windowSize);counters.add(result);return result;}
public PerformanceCounter add(final String name) {PerformanceCounter result = new PerformanceCounter(name);counters.add(result);return result;}
public void tick() {final long t = TimeUtils.nanoTime();if (lastTick > 0L)tick((t - lastTick) * nano2seconds);lastTick = t;}
public void tick(final float deltaTime) {for (int i = 0; i < counters.size; i++) counters.get(i).tick(deltaTime);}
public StringBuilder toString(final StringBuilder sb) {sb.setLength(0);for (int i = 0; i < counters.size; i++) {if (i != 0)sb.append("; ");counters.get(i).toString(sb);}return sb;}public void create() {// create a SpriteBatch with which to render the spritebatch = new SpriteBatch();// one sprite in a texture, see {@see TextureAtlas} and {@see TextureRegion}.texture = new Texture(Gdx.files.internal("data/bobargb8888-32x32.png"));// touch coordinates to world coordinates.camera = new OrthographicCamera();// of the screen.camera.setToOrtho(false);}
public void render() {// set the clear color and clear the screen.Gdx.gl.glClearColor(1, 1, 1, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);// draw the spritebatch.begin();batch.draw(texture, spritePosition.x, spritePosition.y);batch.end();// if a finger is down, set the sprite's x/y coordinate.if (Gdx.input.isTouched()) {// coordinates.camera.unproject(spritePosition.set(Gdx.input.getX(), Gdx.input.getY(), 0));}}public void allocateChannels() {colorChannel = controller.particles.addChannel(ParticleChannels.Color);}
public void activateParticles(int startIndex, int count) {for (int i = startIndex * colorChannel.strideSize, c = i + count * colorChannel.strideSize; i < c; i += colorChannel.strideSize) {colorChannel.data[i + ParticleChannels.RedOffset] = MathUtils.random();colorChannel.data[i + ParticleChannels.GreenOffset] = MathUtils.random();colorChannel.data[i + ParticleChannels.BlueOffset] = MathUtils.random();colorChannel.data[i + ParticleChannels.AlphaOffset] = MathUtils.random();}}
public Random copy() {return new Random();}
public void set(Single colorInfluencer) {this.colorValue.load(colorInfluencer.colorValue);this.alphaValue.load(colorInfluencer.alphaValue);}
public void allocateChannels() {super.allocateChannels();//Hack this allows to share the channel descriptor structure but using a different id temporaryParticleChannels.Interpolation.id = controller.particleChannels.newId();alphaInterpolationChannel = controller.particles.addChannel(ParticleChannels.Interpolation);lifeChannel = controller.particles.addChannel(ParticleChannels.Life);}
public void activateParticles(int startIndex, int count) {for (int i = startIndex * colorChannel.strideSize, a = startIndex * alphaInterpolationChannel.strideSize, l = startIndex * lifeChannel.strideSize + ParticleChannels.LifePercentOffset, c = i + count * colorChannel.strideSize; i < c; i += colorChannel.strideSize, a += alphaInterpolationChannel.strideSize, l += lifeChannel.strideSize) {float alphaStart = alphaValue.newLowValue();float alphaDiff = alphaValue.newHighValue() - alphaStart;colorValue.getColor(0, colorChannel.data, i);colorChannel.data[i + ParticleChannels.AlphaOffset] = alphaStart + alphaDiff * alphaValue.getScale(lifeChannel.data[l]);alphaInterpolationChannel.data[a + ParticleChannels.InterpolationStartOffset] = alphaStart;alphaInterpolationChannel.data[a + ParticleChannels.InterpolationDiffOffset] = alphaDiff;}}
public void update() {for (int i = 0, a = 0, l = ParticleChannels.LifePercentOffset, c = i + controller.particles.size * colorChannel.strideSize; i < c; i += colorChannel.strideSize, a += alphaInterpolationChannel.strideSize, l += lifeChannel.strideSize) {float lifePercent = lifeChannel.data[l];colorValue.getColor(lifePercent, colorChannel.data, i);colorChannel.data[i + ParticleChannels.AlphaOffset] = alphaInterpolationChannel.data[a + ParticleChannels.InterpolationStartOffset] + alphaInterpolationChannel.data[a + ParticleChannels.InterpolationDiffOffset] * alphaValue.getScale(lifePercent);}}
public Single copy() {return new Single(this);}
public void write(Json json) {json.writeValue("alpha", alphaValue);json.writeValue("color", colorValue);}
public void read(Json json, JsonValue jsonData) {alphaValue = json.readValue("alpha", ScaledNumericValue.class, jsonData);colorValue = json.readValue("color", GradientColorValue.class, jsonData);}
public void allocateChannels() {colorChannel = controller.particles.addChannel(ParticleChannels.Color);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(LocalConvexResult obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_LocalConvexResult(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setHitCollisionObject(btCollisionObject value) {CollisionJNI.LocalConvexResult_hitCollisionObject_set(swigCPtr, this, btCollisionObject.getCPtr(value), value);}
public btCollisionObject getHitCollisionObject() {return btCollisionObject.getInstance(CollisionJNI.LocalConvexResult_hitCollisionObject_get(swigCPtr, this), false);}
public void setLocalShapeInfo(LocalShapeInfo value) {CollisionJNI.LocalConvexResult_localShapeInfo_set(swigCPtr, this, LocalShapeInfo.getCPtr(value), value);}
public LocalShapeInfo getLocalShapeInfo() {long cPtr = CollisionJNI.LocalConvexResult_localShapeInfo_get(swigCPtr, this);return (cPtr == 0) ? null : new LocalShapeInfo(cPtr, false);}
public void setHitFraction(float value) {CollisionJNI.LocalConvexResult_hitFraction_set(swigCPtr, this, value);}
public float getHitFraction() {return CollisionJNI.LocalConvexResult_hitFraction_get(swigCPtr, this);}
public void getHitNormalLocal(Vector3 out) {CollisionJNI.LocalConvexResult_getHitNormalLocal(swigCPtr, this, out);}
public void setHitNormalLocal(Vector3 value) {CollisionJNI.LocalConvexResult_setHitNormalLocal(swigCPtr, this, value);}
public void getHitPointLocal(Vector3 out) {CollisionJNI.LocalConvexResult_getHitPointLocal(swigCPtr, this, out);}
public void setHitPointLocal(Vector3 value) {CollisionJNI.LocalConvexResult_setHitPointLocal(swigCPtr, this, value);}protected void processFile(Entry entry) {System.out.println("Processing " + entry.inputFile);Pixmap pixmap = new Pixmap(new FileHandle(entry.inputFile));if (pixmap.getFormat() != Format.RGB888 && pixmap.getFormat() != Format.RGB565) {System.out.println("Converting from " + pixmap.getFormat() + " to RGB888!");Pixmap tmp = new Pixmap(pixmap.getWidth(), pixmap.getHeight(), Format.RGB888);tmp.drawPixmap(pixmap, 0, 0, 0, 0, pixmap.getWidth(), pixmap.getHeight());pixmap.dispose();pixmap = tmp;}ETC1.encodeImagePKM(pixmap).write(new FileHandle(entry.outputFile));pixmap.dispose();}
protected void processDir(Entry entryDir, ArrayList<Entry> value) {if (!entryDir.outputDir.exists()) {if (!entryDir.outputDir.mkdirs())throw new Exception("Couldn't create output directory '" + entryDir.outputDir + "'");}}
public static void process(String inputDirectory, String outputDirectory, boolean recursive, boolean flatten) {GdxNativesLoader.load();ETC1FileProcessor processor = new ETC1FileProcessor();processor.setRecursive(recursive);processor.setFlattenOutput(flatten);processor.process(new File(inputDirectory), new File(outputDirectory));}
public static void main(String[] args) {if (args.length != 2) {System.out.println("ETC1Compressor <input-dir> <output-dir>");System.exit(-1);}ETC1Compressor.process(args[0], args[1], true, false);}protected static long getCPtr(SWIGTYPE_p_f_p_void__void obj) {return (obj == null) ? 0 : obj.swigCPtr;}public void invalidate() {super.invalidate();sizeInvalid = true;}
private void computeSize() {sizeInvalid = false;prefWidth = 0;prefHeight = 0;minWidth = 0;minHeight = 0;maxWidth = 0;maxHeight = 0;SnapshotArray<Actor> children = getChildren();for (int i = 0, n = children.size; i < n; i++) {Actor child = children.get(i);float childMaxWidth, childMaxHeight;if (child instanceof Layout) {Layout layout = (Layout) child;prefWidth = Math.max(prefWidth, layout.getPrefWidth());prefHeight = Math.max(prefHeight, layout.getPrefHeight());minWidth = Math.max(minWidth, layout.getMinWidth());minHeight = Math.max(minHeight, layout.getMinHeight());childMaxWidth = layout.getMaxWidth();childMaxHeight = layout.getMaxHeight();} else {prefWidth = Math.max(prefWidth, child.getWidth());prefHeight = Math.max(prefHeight, child.getHeight());minWidth = Math.max(minWidth, child.getWidth());minHeight = Math.max(minHeight, child.getHeight());childMaxWidth = 0;childMaxHeight = 0;}if (childMaxWidth > 0)maxWidth = maxWidth == 0 ? childMaxWidth : Math.min(maxWidth, childMaxWidth);if (childMaxHeight > 0)maxHeight = maxHeight == 0 ? childMaxHeight : Math.min(maxHeight, childMaxHeight);}}
public void add(Actor actor) {addActor(actor);}
public void layout() {if (sizeInvalid)computeSize();float width = getWidth(), height = getHeight();Array<Actor> children = getChildren();for (int i = 0, n = children.size; i < n; i++) {Actor child = children.get(i);child.setBounds(0, 0, width, height);if (child instanceof Layout)((Layout) child).validate();}}
public float getPrefWidth() {if (sizeInvalid)computeSize();return prefWidth;}
public float getPrefHeight() {if (sizeInvalid)computeSize();return prefHeight;}
public float getMinWidth() {if (sizeInvalid)computeSize();return minWidth;}
public float getMinHeight() {if (sizeInvalid)computeSize();return minHeight;}
public float getMaxWidth() {if (sizeInvalid)computeSize();return maxWidth;}
public float getMaxHeight() {if (sizeInvalid)computeSize();return maxHeight;}public Writer getWriter() {return writer;}
public void setOutputType(OutputType outputType) {this.outputType = outputType;}
public void setQuoteLongValues(boolean quoteLongValues) {this.quoteLongValues = quoteLongValues;}
public JsonWriter name(String name) {if (current == null || current.array)throw new IllegalStateException("Current item must be an object.");if (!current.needsComma)current.needsComma = true;elsewriter.write(',');writer.write(outputType.quoteName(name));writer.write(':');named = true;return this;}
public JsonWriter object() {requireCommaOrName();stack.add(current = new JsonObject(false));return this;}
public JsonWriter array() {requireCommaOrName();stack.add(current = new JsonObject(true));return this;}
public JsonWriter value(Object value) {if (quoteLongValues && (value instanceof Long || value instanceof Double || value instanceof BigDecimal || value instanceof BigInteger)) {value = value.toString();} else if (value instanceof Number) {Number number = (Number) value;long longValue = number.longValue();if (number.doubleValue() == longValue)value = longValue;}requireCommaOrName();writer.write(outputType.quoteValue(value));return this;}
public JsonWriter json(String json) {requireCommaOrName();writer.write(json);return this;}
private void requireCommaOrName() {if (current == null)return;if (current.array) {if (!current.needsComma)current.needsComma = true;elsewriter.write(',');} else {if (!named)throw new IllegalStateException("Name must be set.");named = false;}}
public JsonWriter object(String name) {return name(name).object();}
public JsonWriter array(String name) {return name(name).array();}
public JsonWriter set(String name, Object value) {return name(name).value(value);}
public JsonWriter json(String name, String json) {return name(name).json(json);}
public JsonWriter pop() {if (named)throw new IllegalStateException("Expected an object, array, or value since a name was set.");stack.pop().close();current = stack.size == 0 ? null : stack.peek();return this;}
public void write(char[] cbuf, int off, int len) {writer.write(cbuf, off, len);}
public void flush() {writer.flush();}
public void close() {while (stack.size > 0) pop();writer.close();}
void close() {writer.write(array ? ']' : '}');}
public String quoteValue(Object value) {if (value == null)return "null";String string = value.toString();if (value instanceof Number || value instanceof Boolean)return string;StringBuilder buffer = new StringBuilder(string);buffer.replace('\\', "\\\\").replace('\r', "\\r").replace('\n', "\\n").replace('\t', "\\t");if (this == OutputType.minimal && !string.equals("true") && !string.equals("false") && !string.equals("null") && !string.contains("//") && !string.contains("/*")) {int length = buffer.length();if (length > 0 && buffer.charAt(length - 1) != ' ' && minimalValuePattern.matcher(buffer).matches())return buffer.toString();}return '"' + buffer.replace('"', "\\\"").toString() + '"';}
public String quoteName(String value) {StringBuilder buffer = new StringBuilder(value);buffer.replace('\\', "\\\\").replace('\r', "\\r").replace('\n', "\\n").replace('\t', "\\t");switch(this) {case minimal:if (!value.contains("//") && !value.contains("/*") && minimalNamePattern.matcher(buffer).matches())return buffer.toString();case javascript:if (javascriptPattern.matcher(buffer).matches())return buffer.toString();}return '"' + buffer.replace('"', "\\\"").toString() + '"';}public void create() {super.create();final Model chassisModel = objLoader.loadModel(Gdx.files.internal("data/car.obj"));disposables.add(chassisModel);chassisModel.materials.get(0).clear();chassisModel.materials.get(0).set(ColorAttribute.createDiffuse(Color.RED), ColorAttribute.createSpecular(Color.WHITE));chassisVertexArray = new btTriangleIndexVertexArray(chassisModel.meshParts);btGImpactMeshShape chassisShape = new btGImpactMeshShape(chassisVertexArray);chassisShape.setLocalScaling(new Vector3(1f, 1f, 1f));chassisShape.setMargin(0f);chassisShape.updateBound();world.addConstructor("chassis", new BulletConstructor(chassisModel, 1f, chassisShape));(ground = world.add("ground", 0f, 0f, 0f)).setColor(0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 1f);for (float y = 10f; y < 50f; y += 5f) world.add("chassis", -2f + (float) Math.random() * 4f, y, -2f + (float) Math.random() * 4f).setColor(0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 1f);btGImpactCollisionAlgorithm.registerAlgorithm(world.dispatcher);}
public boolean tap(float x, float y, int count, int button) {shoot(x, y);return true;}
public void dispose() {super.dispose();chassisVertexArray.dispose();chassisVertexArray = null;ground = null;}public static int floatToIntBits(float f) {return impl.floatToIntBits(f);}
public static float intBitsToFloat(int i) {return impl.intBitsToFloat(i);}
public static String newString(byte[] b) {return impl.createString(b, 0, b.length);}
public static String newString(byte[] b, int s, int l) {return impl.createString(b, s, l);}
public static String newString(byte[] b, String encoding) {return impl.createString(b, encoding);}
public static String getOriginatingServerAddress() {return impl.getOriginatingServerAddress();}
public static void printStackTrace(Throwable e) {impl.printStackTrace(e);}
public static void sleep(int i) {impl.sleep(i);}
public static String bytesToString(byte[] data, int len) {char[] chars = new char[len];for (int i = 0; i < len; i++) {chars[i] = (char) data[i];}return new String(chars);}
public static int stringToBytes(String s, byte[] data) {int len = s.length();for (int i = 0; i < len; i++) {data[i] = (byte) s.charAt(i);}return len;}
public static String bytesToHex(byte[] data, int len) {char[] hex = new char[len * 2];for (int i = 0; i < len; i++) {int di = data[i];hex[i << 1] = Character.forDigit((di >> 4) & 15, 16);hex[(i << 1) + 1] = Character.forDigit(di & 15, 16);}return new String(hex);}
public static int hexToBytes(String hex, byte[] data) {int len = hex.length();for (int i = 0; i < len; i += 2) {data[i >> 1] = (byte) ((Character.digit(hex.charAt(i), 16) << 4) | Character.digit(hex.charAt(i + 1), 16));}return len / 2;}public static TextureData loadFromFile(FileHandle file, boolean useMipMaps) {return loadFromFile(file, null, useMipMaps);}
public static TextureData loadFromFile(FileHandle file, Format format, boolean useMipMaps) {if (file == null)return null;if (file.name().endsWith(".cim"))return new FileTextureData(file, PixmapIO.readCIM(file), format, useMipMaps);if (file.name().endsWith(".etc1"))return new ETC1TextureData(file, useMipMaps);if (file.name().endsWith(".ktx") || file.name().endsWith(".zktx"))return new KTXTextureData(file, useMipMaps);return new FileTextureData(file, new Pixmap(file), format, useMipMaps);}public void Create(int windowSize) {if (_buffer == null || _windowSize != windowSize)_buffer = new byte[windowSize];_windowSize = windowSize;_pos = 0;_streamPos = 0;}
public void SetStream(java.io.OutputStream stream) {ReleaseStream();_stream = stream;}
public void ReleaseStream() {Flush();_stream = null;}
public void Init(boolean solid) {if (!solid) {_streamPos = 0;_pos = 0;}}
public void Flush() {int size = _pos - _streamPos;if (size == 0)return;_stream.write(_buffer, _streamPos, size);if (_pos >= _windowSize)_pos = 0;_streamPos = _pos;}
public void CopyBlock(int distance, int len) {int pos = _pos - distance - 1;if (pos < 0)pos += _windowSize;for (; len != 0; len--) {if (pos >= _windowSize)pos = 0;_buffer[_pos++] = _buffer[pos++];if (_pos >= _windowSize)Flush();}}
public void PutByte(byte b) {_buffer[_pos++] = b;if (_pos >= _windowSize)Flush();}
public byte GetByte(int distance) {int pos = _pos - distance - 1;if (pos < 0)pos += _windowSize;return _buffer[pos];}protected static long getCPtr(SWIGTYPE_p_btMatrix3x3DoubleData obj) {return (obj == null) ? 0 : obj.swigCPtr;}public Vec2[] get(int argLength) {assert (argLength > 0);if (!map.containsKey(argLength)) {map.put(argLength, getInitializedArray(argLength));}assert (map.get(argLength).length == argLength) : "Array not built of correct length";return map.get(argLength);}
protected Vec2[] getInitializedArray(int argLength) {final Vec2[] ray = new Vec2[argLength];for (int i = 0; i < ray.length; i++) {ray[i] = new Vec2();}return ray;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btCylinderShapeData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btCylinderShapeData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setConvexInternalShapeData(btConvexInternalShapeData value) {CollisionJNI.btCylinderShapeData_convexInternalShapeData_set(swigCPtr, this, btConvexInternalShapeData.getCPtr(value), value);}
public btConvexInternalShapeData getConvexInternalShapeData() {long cPtr = CollisionJNI.btCylinderShapeData_convexInternalShapeData_get(swigCPtr, this);return (cPtr == 0) ? null : new btConvexInternalShapeData(cPtr, false);}
public void setUpAxis(int value) {CollisionJNI.btCylinderShapeData_upAxis_set(swigCPtr, this, value);}
public int getUpAxis() {return CollisionJNI.btCylinderShapeData_upAxis_get(swigCPtr, this);}
public void setPadding(String value) {CollisionJNI.btCylinderShapeData_padding_set(swigCPtr, this, value);}
public String getPadding() {return CollisionJNI.btCylinderShapeData_padding_get(swigCPtr, this);}protected void createWorld(World world) {Body ground;{BodyDef bd = new BodyDef();ground = world.createBody(bd);EdgeShape shape = new EdgeShape();shape.set(new Vector2(-40, 0), new Vector2(40, 0));ground.createFixture(shape, 0);shape.dispose();}{PolygonShape shape = new PolygonShape();shape.setAsBox(2, 5);BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(-10, 10);bd.angle = 0.5f * (float) Math.PI;bd.allowSleep = false;Body body = world.createBody(bd);body.createFixture(shape, 5.0f);PrismaticJointDef pjd = new PrismaticJointDef();Vector2 axis = new Vector2(2, 1);axis.nor();pjd.initialize(ground, body, new Vector2(0, 0), axis);pjd.motorSpeed = 10.0f;pjd.maxMotorForce = 10000.0f;pjd.enableMotor = true;pjd.lowerTranslation = 0;pjd.upperTranslation = 20.0f;pjd.enableLimit = true;m_joint = (PrismaticJoint) world.createJoint(pjd);}}
public boolean keyDown(int keyCode) {if (keyCode == Keys.L)m_joint.enableLimit(!m_joint.isLimitEnabled());if (keyCode == Keys.M)m_joint.enableMotor(!m_joint.isMotorEnabled());if (keyCode == Keys.S)m_joint.setMotorSpeed(-m_joint.getMotorSpeed());return false;}
public void render() {super.render();}public void Init() {Decoder.InitBitModels(Models);}
public void Encode(Encoder rangeEncoder, int symbol) {int m = 1;for (int bitIndex = NumBitLevels; bitIndex != 0; ) {bitIndex--;int bit = (symbol >>> bitIndex) & 1;rangeEncoder.Encode(Models, m, bit);m = (m << 1) | bit;}}
public void ReverseEncode(Encoder rangeEncoder, int symbol) {int m = 1;for (int i = 0; i < NumBitLevels; i++) {int bit = symbol & 1;rangeEncoder.Encode(Models, m, bit);m = (m << 1) | bit;symbol >>= 1;}}
public int GetPrice(int symbol) {int price = 0;int m = 1;for (int bitIndex = NumBitLevels; bitIndex != 0; ) {bitIndex--;int bit = (symbol >>> bitIndex) & 1;price += Encoder.GetPrice(Models[m], bit);m = (m << 1) + bit;}return price;}
public int ReverseGetPrice(int symbol) {int price = 0;int m = 1;for (int i = NumBitLevels; i != 0; i--) {int bit = symbol & 1;symbol >>>= 1;price += Encoder.GetPrice(Models[m], bit);m = (m << 1) | bit;}return price;}
public static int ReverseGetPrice(short[] Models, int startIndex, int NumBitLevels, int symbol) {int price = 0;int m = 1;for (int i = NumBitLevels; i != 0; i--) {int bit = symbol & 1;symbol >>>= 1;price += Encoder.GetPrice(Models[startIndex + m], bit);m = (m << 1) | bit;}return price;}
public static void ReverseEncode(short[] Models, int startIndex, Encoder rangeEncoder, int NumBitLevels, int symbol) {int m = 1;for (int i = 0; i < NumBitLevels; i++) {int bit = symbol & 1;rangeEncoder.Encode(Models, startIndex + m, bit);m = (m << 1) | bit;symbol >>= 1;}}public int getPaddingTop() {return paddingTop;}
public void setPaddingTop(int paddingTop) {this.paddingTop = paddingTop;}
public int getPaddingLeft() {return paddingLeft;}
public void setPaddingLeft(int paddingLeft) {this.paddingLeft = paddingLeft;}
public int getPaddingBottom() {return paddingBottom;}
public void setPaddingBottom(int paddingBottom) {this.paddingBottom = paddingBottom;}
public int getPaddingRight() {return paddingRight;}
public void setPaddingRight(int paddingRight) {this.paddingRight = paddingRight;}
public int getPaddingAdvanceX() {return paddingAdvanceX;}
public void setPaddingAdvanceX(int paddingAdvanceX) {this.paddingAdvanceX = paddingAdvanceX;}
public int getPaddingAdvanceY() {return paddingAdvanceY;}
public void setPaddingAdvanceY(int paddingAdvanceY) {this.paddingAdvanceY = paddingAdvanceY;}
public int getGlyphPageWidth() {return glyphPageWidth;}
public void setGlyphPageWidth(int glyphPageWidth) {this.glyphPageWidth = glyphPageWidth;}
public int getGlyphPageHeight() {return glyphPageHeight;}
public void setGlyphPageHeight(int glyphPageHeight) {this.glyphPageHeight = glyphPageHeight;}
public String getFontName() {return fontName;}
public void setFontName(String fontName) {this.fontName = fontName;}
public int getFontSize() {return fontSize;}
public void setFontSize(int fontSize) {this.fontSize = fontSize;}
public boolean isBold() {return bold;}
public void setBold(boolean bold) {this.bold = bold;}
public boolean isItalic() {return italic;}
public void setItalic(boolean italic) {this.italic = italic;}
public List getEffects() {return effects;}
public boolean getNativeRendering() {return nativeRendering;}
public void setNativeRendering(boolean nativeRendering) {this.nativeRendering = nativeRendering;}
public String getGlyphText() {return this.glyphText.replace("\\n", "\n");}
public void setGlyphText(String text) {this.glyphText = text.replace("\n", "\\n");}
public String getFont2File() {return font2File;}
public void setFont2File(String filename) {this.font2File = filename;}
public boolean isFont2Active() {return font2Active;}
public void setFont2Active(boolean active) {this.font2Active = active;}
public boolean isMono() {return mono;}
public void setMono(boolean mono) {this.mono = mono;}
public float getGamma() {return gamma;}
public void setGamma(float gamma) {this.gamma = gamma;}
public void save(File file) {PrintStream out = new PrintStream(file, "UTF-8");out.println("font.name=" + fontName);out.println("font.size=" + fontSize);out.println("font.bold=" + bold);out.println("font.italic=" + italic);out.println("font.gamma=" + gamma);out.println("font.mono=" + mono);out.println();out.println("font2.file=" + font2File);out.println("font2.use=" + font2Active);out.println();out.println("pad.top=" + paddingTop);out.println("pad.right=" + paddingRight);out.println("pad.bottom=" + paddingBottom);out.println("pad.left=" + paddingLeft);out.println("pad.advance.x=" + paddingAdvanceX);out.println("pad.advance.y=" + paddingAdvanceY);out.println();out.println("glyph.native.rendering=" + nativeRendering);out.println("glyph.page.width=" + glyphPageWidth);out.println("glyph.page.height=" + glyphPageHeight);out.println("glyph.text=" + glyphText);out.println();for (Iterator iter = effects.iterator(); iter.hasNext(); ) {ConfigurableEffect effect = (ConfigurableEffect) iter.next();out.println("effect.class=" + effect.getClass().getName());for (Iterator iter2 = effect.getValues().iterator(); iter2.hasNext(); ) {Value value = (Value) iter2.next();out.println("effect." + value.getName() + "=" + value.getString());}out.println();}out.close();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btConeTwistConstraintData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btConeTwistConstraintData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setTypeConstraintData(btTypedConstraintData value) {DynamicsJNI.btConeTwistConstraintData_typeConstraintData_set(swigCPtr, this, btTypedConstraintData.getCPtr(value), value);}
public btTypedConstraintData getTypeConstraintData() {long cPtr = DynamicsJNI.btConeTwistConstraintData_typeConstraintData_get(swigCPtr, this);return (cPtr == 0) ? null : new btTypedConstraintData(cPtr, false);}
public void setRbAFrame(btTransformFloatData value) {DynamicsJNI.btConeTwistConstraintData_rbAFrame_set(swigCPtr, this, btTransformFloatData.getCPtr(value), value);}
public btTransformFloatData getRbAFrame() {long cPtr = DynamicsJNI.btConeTwistConstraintData_rbAFrame_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformFloatData(cPtr, false);}
public void setRbBFrame(btTransformFloatData value) {DynamicsJNI.btConeTwistConstraintData_rbBFrame_set(swigCPtr, this, btTransformFloatData.getCPtr(value), value);}
public btTransformFloatData getRbBFrame() {long cPtr = DynamicsJNI.btConeTwistConstraintData_rbBFrame_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformFloatData(cPtr, false);}
public void setSwingSpan1(float value) {DynamicsJNI.btConeTwistConstraintData_swingSpan1_set(swigCPtr, this, value);}
public float getSwingSpan1() {return DynamicsJNI.btConeTwistConstraintData_swingSpan1_get(swigCPtr, this);}
public void setSwingSpan2(float value) {DynamicsJNI.btConeTwistConstraintData_swingSpan2_set(swigCPtr, this, value);}
public float getSwingSpan2() {return DynamicsJNI.btConeTwistConstraintData_swingSpan2_get(swigCPtr, this);}
public void setTwistSpan(float value) {DynamicsJNI.btConeTwistConstraintData_twistSpan_set(swigCPtr, this, value);}
public float getTwistSpan() {return DynamicsJNI.btConeTwistConstraintData_twistSpan_get(swigCPtr, this);}
public void setLimitSoftness(float value) {DynamicsJNI.btConeTwistConstraintData_limitSoftness_set(swigCPtr, this, value);}
public float getLimitSoftness() {return DynamicsJNI.btConeTwistConstraintData_limitSoftness_get(swigCPtr, this);}
public void setBiasFactor(float value) {DynamicsJNI.btConeTwistConstraintData_biasFactor_set(swigCPtr, this, value);}
public float getBiasFactor() {return DynamicsJNI.btConeTwistConstraintData_biasFactor_get(swigCPtr, this);}
public void setRelaxationFactor(float value) {DynamicsJNI.btConeTwistConstraintData_relaxationFactor_set(swigCPtr, this, value);}
public float getRelaxationFactor() {return DynamicsJNI.btConeTwistConstraintData_relaxationFactor_get(swigCPtr, this);}
public void setDamping(float value) {DynamicsJNI.btConeTwistConstraintData_damping_set(swigCPtr, this, value);}
public float getDamping() {return DynamicsJNI.btConeTwistConstraintData_damping_get(swigCPtr, this);}
public void setPad(String value) {DynamicsJNI.btConeTwistConstraintData_pad_set(swigCPtr, this, value);}
public String getPad() {return DynamicsJNI.btConeTwistConstraintData_pad_get(swigCPtr, this);}public void begin() {Gdx.gl.glDisable(GL20.GL_DEPTH_TEST);depthFunc = 0;Gdx.gl.glDepthMask(true);depthMask = true;Gdx.gl.glDisable(GL20.GL_BLEND);blending = false;Gdx.gl.glDisable(GL20.GL_CULL_FACE);cullFace = blendSFactor = blendDFactor = 0;textureBinder.begin();}
public void end() {if (depthFunc != 0)Gdx.gl.glDisable(GL20.GL_DEPTH_TEST);if (!depthMask)Gdx.gl.glDepthMask(true);if (blending)Gdx.gl.glDisable(GL20.GL_BLEND);if (cullFace > 0)Gdx.gl.glDisable(GL20.GL_CULL_FACE);textureBinder.end();}
public void setDepthMask(final boolean depthMask) {if (this.depthMask != depthMask)Gdx.gl.glDepthMask(this.depthMask = depthMask);}
public void setDepthTest(final int depthFunction) {setDepthTest(depthFunction, 0f, 1f);}
public void setDepthTest(final int depthFunction, final float depthRangeNear, final float depthRangeFar) {final boolean wasEnabled = depthFunc != 0;final boolean enabled = depthFunction != 0;if (depthFunc != depthFunction) {depthFunc = depthFunction;if (enabled) {Gdx.gl.glEnable(GL20.GL_DEPTH_TEST);Gdx.gl.glDepthFunc(depthFunction);} elseGdx.gl.glDisable(GL20.GL_DEPTH_TEST);}if (enabled) {if (!wasEnabled || depthFunc != depthFunction)Gdx.gl.glDepthFunc(depthFunc = depthFunction);if (!wasEnabled || this.depthRangeNear != depthRangeNear || this.depthRangeFar != depthRangeFar)Gdx.gl.glDepthRangef(this.depthRangeNear = depthRangeNear, this.depthRangeFar = depthRangeFar);}}
public void setBlending(final boolean enabled, final int sFactor, final int dFactor) {if (enabled != blending) {blending = enabled;if (enabled)Gdx.gl.glEnable(GL20.GL_BLEND);elseGdx.gl.glDisable(GL20.GL_BLEND);}if (enabled && (blendSFactor != sFactor || blendDFactor != dFactor)) {Gdx.gl.glBlendFunc(sFactor, dFactor);blendSFactor = sFactor;blendDFactor = dFactor;}}
public void setCullFace(final int face) {if (face != cullFace) {cullFace = face;if ((face == GL20.GL_FRONT) || (face == GL20.GL_BACK) || (face == GL20.GL_FRONT_AND_BACK)) {Gdx.gl.glEnable(GL20.GL_CULL_FACE);Gdx.gl.glCullFace(face);} elseGdx.gl.glDisable(GL20.GL_CULL_FACE);}}public String toString() {return "Outline (Wobble)";}
public List getValues() {List values = super.getValues();// Remove "Join".values.remove(2);values.add(EffectUtil.floatValue("Detail", detail, 1, 50, "This setting controls how detailed the outline will be. " + "Smaller numbers cause the outline to have more detail."));values.add(EffectUtil.floatValue("Amplitude", amplitude, 0.5f, 50, "This setting controls the amplitude of the outline."));return values;}
public void setValues(List values) {super.setValues(values);for (Iterator iter = values.iterator(); iter.hasNext(); ) {Value value = (Value) iter.next();if (value.getName().equals("Detail")) {detail = ((Float) value.getObject()).floatValue();} else if (value.getName().equals("Amplitude")) {amplitude = ((Float) value.getObject()).floatValue();}}}
public Shape createStrokedShape(Shape shape) {GeneralPath result = new GeneralPath();shape = new BasicStroke(getWidth(), BasicStroke.CAP_SQUARE, getJoin()).createStrokedShape(shape);PathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), FLATNESS);float points[] = new float[6];float moveX = 0, moveY = 0;float lastX = 0, lastY = 0;float thisX = 0, thisY = 0;int type = 0;float next = 0;while (!it.isDone()) {type = it.currentSegment(points);switch(type) {case PathIterator.SEG_MOVETO:moveX = lastX = randomize(points[0]);moveY = lastY = randomize(points[1]);result.moveTo(moveX, moveY);next = 0;break;case PathIterator.SEG_CLOSE:points[0] = moveX;points[1] = moveY;case PathIterator.SEG_LINETO:thisX = randomize(points[0]);thisY = randomize(points[1]);float dx = thisX - lastX;float dy = thisY - lastY;float distance = (float) Math.sqrt(dx * dx + dy * dy);if (distance >= next) {float r = 1.0f / distance;while (distance >= next) {float x = lastX + next * dx * r;float y = lastY + next * dy * r;result.lineTo(randomize(x), randomize(y));next += detail;}}next -= distance;lastX = thisX;lastY = thisY;break;}it.next();}return result;}
private float randomize(float x) {return x + (float) Math.random() * amplitude * 2 - 1;}public float[] getVertices() {return localVertices;}
public float[] getTransformedVertices() {if (!dirty)return worldVertices;dirty = false;final float[] localVertices = this.localVertices;if (worldVertices == null || worldVertices.length < localVertices.length)worldVertices = new float[localVertices.length];final float[] worldVertices = this.worldVertices;final float positionX = x;final float positionY = y;final float originX = this.originX;final float originY = this.originY;final float scaleX = this.scaleX;final float scaleY = this.scaleY;final boolean scale = scaleX != 1 || scaleY != 1;final float rotation = this.rotation;final float cos = MathUtils.cosDeg(rotation);final float sin = MathUtils.sinDeg(rotation);for (int i = 0, n = localVertices.length; i < n; i += 2) {float x = localVertices[i] - originX;float y = localVertices[i + 1] - originY;// scale if neededif (scale) {x *= scaleX;y *= scaleY;}// rotate if neededif (rotation != 0) {float oldX = x;x = cos * x - sin * y;y = sin * oldX + cos * y;}worldVertices[i] = positionX + x + originX;worldVertices[i + 1] = positionY + y + originY;}return worldVertices;}
public float getLength() {if (!calculateLength)return length;calculateLength = false;length = 0;for (int i = 0, n = localVertices.length - 2; i < n; i += 2) {float x = localVertices[i + 2] - localVertices[i];float y = localVertices[i + 1] - localVertices[i + 3];length += (float) Math.sqrt(x * x + y * y);}return length;}
public float getScaledLength() {if (!calculateScaledLength)return scaledLength;calculateScaledLength = false;scaledLength = 0;for (int i = 0, n = localVertices.length - 2; i < n; i += 2) {float x = localVertices[i + 2] * scaleX - localVertices[i] * scaleX;float y = localVertices[i + 1] * scaleY - localVertices[i + 3] * scaleY;scaledLength += (float) Math.sqrt(x * x + y * y);}return scaledLength;}
public float getX() {return x;}
public float getY() {return y;}
public float getOriginX() {return originX;}
public float getOriginY() {return originY;}
public float getRotation() {return rotation;}
public float getScaleX() {return scaleX;}
public float getScaleY() {return scaleY;}
public void setOrigin(float originX, float originY) {this.originX = originX;this.originY = originY;dirty = true;}
public void setPosition(float x, float y) {this.x = x;this.y = y;dirty = true;}
public void setVertices(float[] vertices) {if (vertices.length < 4)throw new IllegalArgumentException("polylines must contain at least 2 points.");this.localVertices = vertices;dirty = true;}
public void setRotation(float degrees) {this.rotation = degrees;dirty = true;}
public void rotate(float degrees) {rotation += degrees;dirty = true;}
public void setScale(float scaleX, float scaleY) {this.scaleX = scaleX;this.scaleY = scaleY;dirty = true;calculateScaledLength = true;}
public void scale(float amount) {this.scaleX += amount;this.scaleY += amount;dirty = true;calculateScaledLength = true;}
public void calculateLength() {calculateLength = true;}
public void calculateScaledLength() {calculateScaledLength = true;}
public void dirty() {dirty = true;}
public void translate(float x, float y) {this.x += x;this.y += y;dirty = true;}
public boolean contains(Vector2 point) {return false;}
public boolean contains(float x, float y) {return false;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btDiscreteCollisionDetectorInterface obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btDiscreteCollisionDetectorInterface(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(Result obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btDiscreteCollisionDetectorInterface_Result(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setShapeIdentifiersA(int partId0, int index0) {CollisionJNI.btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersA(swigCPtr, this, partId0, index0);}
public void setShapeIdentifiersB(int partId1, int index1) {CollisionJNI.btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersB(swigCPtr, this, partId1, index1);}
public void addContactPoint(Vector3 normalOnBInWorld, Vector3 pointInWorld, float depth) {CollisionJNI.btDiscreteCollisionDetectorInterface_Result_addContactPoint(swigCPtr, this, normalOnBInWorld, pointInWorld, depth);}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(ClosestPointInput obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btDiscreteCollisionDetectorInterface_ClosestPointInput(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setTransformA(btTransform value) {CollisionJNI.btDiscreteCollisionDetectorInterface_ClosestPointInput_transformA_set(swigCPtr, this, btTransform.getCPtr(value), value);}
public btTransform getTransformA() {long cPtr = CollisionJNI.btDiscreteCollisionDetectorInterface_ClosestPointInput_transformA_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransform(cPtr, false);}
public void setTransformB(btTransform value) {CollisionJNI.btDiscreteCollisionDetectorInterface_ClosestPointInput_transformB_set(swigCPtr, this, btTransform.getCPtr(value), value);}
public btTransform getTransformB() {long cPtr = CollisionJNI.btDiscreteCollisionDetectorInterface_ClosestPointInput_transformB_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransform(cPtr, false);}
public void setMaximumDistanceSquared(float value) {CollisionJNI.btDiscreteCollisionDetectorInterface_ClosestPointInput_maximumDistanceSquared_set(swigCPtr, this, value);}
public float getMaximumDistanceSquared() {return CollisionJNI.btDiscreteCollisionDetectorInterface_ClosestPointInput_maximumDistanceSquared_get(swigCPtr, this);}
public void getClosestPoints(btDiscreteCollisionDetectorInterface.ClosestPointInput input, btDiscreteCollisionDetectorInterface.Result output, btIDebugDraw debugDraw, boolean swapResults) {CollisionJNI.btDiscreteCollisionDetectorInterface_getClosestPoints__SWIG_0(swigCPtr, this, btDiscreteCollisionDetectorInterface.ClosestPointInput.getCPtr(input), input, btDiscreteCollisionDetectorInterface.Result.getCPtr(output), output, btIDebugDraw.getCPtr(debugDraw), debugDraw, swapResults);}
public void getClosestPoints(btDiscreteCollisionDetectorInterface.ClosestPointInput input, btDiscreteCollisionDetectorInterface.Result output, btIDebugDraw debugDraw) {CollisionJNI.btDiscreteCollisionDetectorInterface_getClosestPoints__SWIG_1(swigCPtr, this, btDiscreteCollisionDetectorInterface.ClosestPointInput.getCPtr(input), input, btDiscreteCollisionDetectorInterface.Result.getCPtr(output), output, btIDebugDraw.getCPtr(debugDraw), debugDraw);}public int floatToIntBits(float f) {return Numbers.floatToIntBits(f);}
public float intBitsToFloat(int i) {return Numbers.intBitsToFloat(i);}
public String createString(byte[] b, int ofs, int length) {// TODO Auto-generated method stubreturn null;}
public String getOriginatingServerAddress() {// TODO Auto-generated method stubreturn null;}
public void printStackTrace(Throwable e) {}
public String createString(byte[] b, String encoding) {// TODO Auto-generated method stubreturn null;}
public void sleep(int i) {}public void render() {GL20 gl = Gdx.gl20;gl.glClearColor(0.7f, 0.7f, 0.7f, 1);gl.glClear(GL20.GL_COLOR_BUFFER_BIT);float begin = 0;float end = 0;float draw1 = 0;float draw2 = 0;float drawText = 0;long start = TimeUtils.nanoTime();spriteBatch.begin();begin = (TimeUtils.nanoTime() - start) / 1000000000.0f;int len = coords.length;start = TimeUtils.nanoTime();for (int i = 0; i < len; i += 2) spriteBatch.draw(texture, coords[i], coords[i + 1], 0, 0, 32, 32);draw1 = (TimeUtils.nanoTime() - start) / 1000000000.0f;start = TimeUtils.nanoTime();spriteBatch.setColor(col);for (int i = 0; i < coords2.length; i += 2) spriteBatch.draw(texture2, coords2[i], coords2[i + 1], 0, 0, 32, 32);draw2 = (TimeUtils.nanoTime() - start) / 1000000000.0f;start = TimeUtils.nanoTime();// spriteBatch.drawText(font, "all hail and another this is a test", 200, 200, Color.WHITE);drawText = (TimeUtils.nanoTime() - start) / 1000000000.0f;start = TimeUtils.nanoTime();spriteBatch.end();end = (TimeUtils.nanoTime() - start) / 1000000000.0f;if (TimeUtils.nanoTime() - startTime > 1000000000) {Gdx.app.log("SpriteBatch", "fps: " + frames + ", render calls: " + spriteBatch.renderCalls + ", " + begin + ", " + draw1 + ", " + draw2 + ", " + drawText + ", " + end);frames = 0;startTime = TimeUtils.nanoTime();}frames++;}
public void create() {spriteBatch = new SpriteBatch();texture = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));Pixmap pixmap = new Pixmap(32, 32, Format.RGB565);pixmap.setColor(1, 1, 0, 0.7f);pixmap.fill();texture2 = new Texture(pixmap);pixmap.dispose();for (int i = 0; i < coords.length; i += 2) {coords[i] = (int) (Math.random() * Gdx.graphics.getWidth());coords[i + 1] = (int) (Math.random() * Gdx.graphics.getHeight());coords2[i] = (int) (Math.random() * Gdx.graphics.getWidth());coords2[i + 1] = (int) (Math.random() * Gdx.graphics.getHeight());}}
public void dispose() {spriteBatch.dispose();texture.dispose();texture2.dispose();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(HullDesc obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_HullDesc(swigCPtr);}swigCPtr = 0;}super.delete();}
public boolean HasHullFlag(int flag) {return LinearMathJNI.HullDesc_HasHullFlag(swigCPtr, this, flag);}
public void SetHullFlag(int flag) {LinearMathJNI.HullDesc_SetHullFlag(swigCPtr, this, flag);}
public void ClearHullFlag(int flag) {LinearMathJNI.HullDesc_ClearHullFlag(swigCPtr, this, flag);}
public void setMFlags(long value) {LinearMathJNI.HullDesc_mFlags_set(swigCPtr, this, value);}
public long getMFlags() {return LinearMathJNI.HullDesc_mFlags_get(swigCPtr, this);}
public void setMVcount(long value) {LinearMathJNI.HullDesc_mVcount_set(swigCPtr, this, value);}
public long getMVcount() {return LinearMathJNI.HullDesc_mVcount_get(swigCPtr, this);}
public void setMVertices(btVector3 value) {LinearMathJNI.HullDesc_mVertices_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getMVertices() {long cPtr = LinearMathJNI.HullDesc_mVertices_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setMVertexStride(long value) {LinearMathJNI.HullDesc_mVertexStride_set(swigCPtr, this, value);}
public long getMVertexStride() {return LinearMathJNI.HullDesc_mVertexStride_get(swigCPtr, this);}
public void setMNormalEpsilon(float value) {LinearMathJNI.HullDesc_mNormalEpsilon_set(swigCPtr, this, value);}
public float getMNormalEpsilon() {return LinearMathJNI.HullDesc_mNormalEpsilon_get(swigCPtr, this);}
public void setMMaxVertices(long value) {LinearMathJNI.HullDesc_mMaxVertices_set(swigCPtr, this, value);}
public long getMMaxVertices() {return LinearMathJNI.HullDesc_mMaxVertices_get(swigCPtr, this);}
public void setMMaxFaces(long value) {LinearMathJNI.HullDesc_mMaxFaces_set(swigCPtr, this, value);}
public long getMMaxFaces() {return LinearMathJNI.HullDesc_mMaxFaces_get(swigCPtr, this);}public boolean tap(float stageX, float stageY, int count, int button) {actor.stageToLocalCoordinates(tmpCoords.set(stageX, stageY));ActorGestureListener.this.tap(event, tmpCoords.x, tmpCoords.y, count, button);return true;}
public boolean longPress(float stageX, float stageY) {actor.stageToLocalCoordinates(tmpCoords.set(stageX, stageY));return ActorGestureListener.this.longPress(actor, tmpCoords.x, tmpCoords.y);}
public boolean fling(float velocityX, float velocityY, int button) {stageToLocalAmount(tmpCoords.set(velocityX, velocityY));ActorGestureListener.this.fling(event, tmpCoords.x, tmpCoords.y, button);return true;}
public boolean pan(float stageX, float stageY, float deltaX, float deltaY) {stageToLocalAmount(tmpCoords.set(deltaX, deltaY));deltaX = tmpCoords.x;deltaY = tmpCoords.y;actor.stageToLocalCoordinates(tmpCoords.set(stageX, stageY));ActorGestureListener.this.pan(event, tmpCoords.x, tmpCoords.y, deltaX, deltaY);return true;}
public boolean zoom(float initialDistance, float distance) {ActorGestureListener.this.zoom(event, initialDistance, distance);return true;}
public boolean pinch(Vector2 stageInitialPointer1, Vector2 stageInitialPointer2, Vector2 stagePointer1, Vector2 stagePointer2) {actor.stageToLocalCoordinates(initialPointer1.set(stageInitialPointer1));actor.stageToLocalCoordinates(initialPointer2.set(stageInitialPointer2));actor.stageToLocalCoordinates(pointer1.set(stagePointer1));actor.stageToLocalCoordinates(pointer2.set(stagePointer2));ActorGestureListener.this.pinch(event, initialPointer1, initialPointer2, pointer1, pointer2);return true;}
private void stageToLocalAmount(Vector2 amount) {actor.stageToLocalCoordinates(amount);amount.sub(actor.stageToLocalCoordinates(tmpCoords2.set(0, 0)));}
public boolean handle(Event e) {if (!(e instanceof InputEvent))return false;InputEvent event = (InputEvent) e;switch(event.getType()) {case touchDown:actor = event.getListenerActor();touchDownTarget = event.getTarget();detector.touchDown(event.getStageX(), event.getStageY(), event.getPointer(), event.getButton());actor.stageToLocalCoordinates(tmpCoords.set(event.getStageX(), event.getStageY()));touchDown(event, tmpCoords.x, tmpCoords.y, event.getPointer(), event.getButton());return true;case touchUp:if (event.isTouchFocusCancel())return false;this.event = event;actor = event.getListenerActor();detector.touchUp(event.getStageX(), event.getStageY(), event.getPointer(), event.getButton());actor.stageToLocalCoordinates(tmpCoords.set(event.getStageX(), event.getStageY()));touchUp(event, tmpCoords.x, tmpCoords.y, event.getPointer(), event.getButton());return true;case touchDragged:this.event = event;actor = event.getListenerActor();detector.touchDragged(event.getStageX(), event.getStageY(), event.getPointer());return true;}return false;}
public void touchDown(InputEvent event, float x, float y, int pointer, int button) {}
public void touchUp(InputEvent event, float x, float y, int pointer, int button) {}
public void tap(InputEvent event, float x, float y, int count, int button) {}
public boolean longPress(Actor actor, float x, float y) {return false;}
public void fling(InputEvent event, float velocityX, float velocityY, int button) {}
public void pan(InputEvent event, float x, float y, float deltaX, float deltaY) {}
public void zoom(InputEvent event, float initialDistance, float distance) {}
public void pinch(InputEvent event, Vector2 initialPointer1, Vector2 initialPointer2, Vector2 pointer1, Vector2 pointer2) {}
public GestureDetector getGestureDetector() {return detector;}
public Actor getTouchDownTarget() {return touchDownTarget;}public boolean handle(Event event) {if (!(event instanceof ChangeEvent))return false;changed((ChangeEvent) event, event.getTarget());return false;}public void init() {AspectTextureRegion region = regions.items[0];for (int i = 0, c = controller.emitter.maxParticleCount * regionChannel.strideSize; i < c; i += regionChannel.strideSize) {regionChannel.data[i + ParticleChannels.UOffset] = region.u;regionChannel.data[i + ParticleChannels.VOffset] = region.v;regionChannel.data[i + ParticleChannels.U2Offset] = region.u2;regionChannel.data[i + ParticleChannels.V2Offset] = region.v2;regionChannel.data[i + ParticleChannels.HalfWidthOffset] = 0.5f;regionChannel.data[i + ParticleChannels.HalfHeightOffset] = region.halfInvAspectRatio;}}
public Single copy() {return new Single(this);}
public void activateParticles(int startIndex, int count) {for (int i = startIndex * regionChannel.strideSize, c = i + count * regionChannel.strideSize; i < c; i += regionChannel.strideSize) {AspectTextureRegion region = regions.random();regionChannel.data[i + ParticleChannels.UOffset] = region.u;regionChannel.data[i + ParticleChannels.VOffset] = region.v;regionChannel.data[i + ParticleChannels.U2Offset] = region.u2;regionChannel.data[i + ParticleChannels.V2Offset] = region.v2;regionChannel.data[i + ParticleChannels.HalfWidthOffset] = 0.5f;regionChannel.data[i + ParticleChannels.HalfHeightOffset] = region.halfInvAspectRatio;}}
public Random copy() {return new Random(this);}
public void allocateChannels() {super.allocateChannels();lifeChannel = controller.particles.addChannel(ParticleChannels.Life);}
public void update() {for (int i = 0, l = ParticleChannels.LifePercentOffset, c = controller.particles.size * regionChannel.strideSize; i < c; i += regionChannel.strideSize, l += lifeChannel.strideSize) {AspectTextureRegion region = regions.get((int) (lifeChannel.data[l] * (regions.size - 1)));regionChannel.data[i + ParticleChannels.UOffset] = region.u;regionChannel.data[i + ParticleChannels.VOffset] = region.v;regionChannel.data[i + ParticleChannels.U2Offset] = region.u2;regionChannel.data[i + ParticleChannels.V2Offset] = region.v2;regionChannel.data[i + ParticleChannels.HalfWidthOffset] = 0.5f;regionChannel.data[i + ParticleChannels.HalfHeightOffset] = region.halfInvAspectRatio;}}
public Animated copy() {return new Animated(this);}
public void set(TextureRegion region) {this.u = region.getU();this.v = region.getV();this.u2 = region.getU2();this.v2 = region.getV2();this.halfInvAspectRatio = 0.5f * ((float) region.getRegionHeight() / region.getRegionWidth());}
public void set(AspectTextureRegion aspectTextureRegion) {u = aspectTextureRegion.u;v = aspectTextureRegion.v;u2 = aspectTextureRegion.u2;v2 = aspectTextureRegion.v2;halfInvAspectRatio = aspectTextureRegion.halfInvAspectRatio;}
public void add(TextureRegion... regions) {this.regions.ensureCapacity(regions.length);for (TextureRegion region : regions) {this.regions.add(new AspectTextureRegion(region));}}
public void clear() {regions.clear();}
public void allocateChannels() {regionChannel = controller.particles.addChannel(ParticleChannels.TextureRegion);}
public void write(Json json) {json.writeValue("regions", regions, Array.class, AspectTextureRegion.class);}
public void read(Json json, JsonValue jsonData) {regions.clear();regions.addAll(json.readValue("regions", Array.class, AspectTextureRegion.class, jsonData));}public void setValue(ScaleInfluencer value) {super.setValue(value);if (value == null)return;scalePanel.setValue(value.value);}
protected void initializeComponents() {super.initializeComponents();addContent(0, 0, scalePanel = new ScaledNumericPanel(editor, null, "Life", "", ""));scalePanel.setIsAlwayShown(true);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btVehicleRaycaster obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btVehicleRaycaster(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btVehicleRaycasterResult obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btVehicleRaycaster_btVehicleRaycasterResult(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setHitPointInWorld(btVector3 value) {DynamicsJNI.btVehicleRaycaster_btVehicleRaycasterResult_hitPointInWorld_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getHitPointInWorld() {long cPtr = DynamicsJNI.btVehicleRaycaster_btVehicleRaycasterResult_hitPointInWorld_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setHitNormalInWorld(btVector3 value) {DynamicsJNI.btVehicleRaycaster_btVehicleRaycasterResult_hitNormalInWorld_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getHitNormalInWorld() {long cPtr = DynamicsJNI.btVehicleRaycaster_btVehicleRaycasterResult_hitNormalInWorld_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setDistFraction(float value) {DynamicsJNI.btVehicleRaycaster_btVehicleRaycasterResult_distFraction_set(swigCPtr, this, value);}
public float getDistFraction() {return DynamicsJNI.btVehicleRaycaster_btVehicleRaycasterResult_distFraction_get(swigCPtr, this);}
public long castRay(Vector3 from, Vector3 to, btVehicleRaycaster.btVehicleRaycasterResult result) {return DynamicsJNI.btVehicleRaycaster_castRay(swigCPtr, this, from, to, btVehicleRaycaster.btVehicleRaycasterResult.getCPtr(result), result);}protected void createWorld(World world) {Body ground;{BodyDef bd = new BodyDef();ground = world.createBody(bd);EdgeShape shape = new EdgeShape();shape.set(new Vector2(-40, 0), new Vector2(40.0f, 0));ground.createFixture(shape, 0);shape.dispose();}{PolygonShape shape = new PolygonShape();shape.setAsBox(0.5f, 0.125f);FixtureDef fd = new FixtureDef();fd.shape = shape;fd.density = 20.0f;fd.friction = 0.2f;RevoluteJointDef jd = new RevoluteJointDef();Body prevBody = ground;for (int i = 0; i < e_count; i++) {BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(-14.5f + 1.0f * i, 5.0f);Body body = world.createBody(bd);body.createFixture(fd);Vector2 anchor = new Vector2(-15.0f + 1.0f * i, 5.0f);jd.initialize(prevBody, body, anchor);world.createJoint(jd);prevBody = body;}Vector2 anchor = new Vector2(-15.0f + 1.0f * e_count, 5.0f);jd.initialize(prevBody, ground, anchor);world.createJoint(jd);shape.dispose();}for (int i = 0; i < 2; i++) {Vector2[] vertices = new Vector2[3];vertices[0] = new Vector2(-0.5f, 0);vertices[1] = new Vector2(0.5f, 0);vertices[2] = new Vector2(0, 1.5f);PolygonShape shape = new PolygonShape();shape.set(vertices);FixtureDef fd = new FixtureDef();fd.shape = shape;fd.density = 1.0f;BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(-8.0f + 8.0f * i, 12.0f);Body body = world.createBody(bd);body.createFixture(fd);shape.dispose();}for (int i = 0; i < 3; i++) {CircleShape shape = new CircleShape();shape.setRadius(0.5f);FixtureDef fd = new FixtureDef();fd.shape = shape;fd.density = 1.0f;BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(-6.0f + 6.0f * i, 10.0f);Body body = world.createBody(bd);body.createFixture(fd);shape.dispose();}}public int getKey() {return ((int) indexA) << 24 | ((int) indexB) << 16 | ((int) typeA) << 8 | ((int) typeB);}
public boolean isEqual(final ContactID cid) {return getKey() == cid.getKey();}
public void set(final ContactID c) {indexA = c.indexA;indexB = c.indexB;typeA = c.typeA;typeB = c.typeB;}
public void flip() {byte tempA = indexA;indexA = indexB;indexB = tempA;tempA = typeA;typeA = typeB;typeB = tempA;}
public void zero() {indexA = 0;indexB = 0;typeA = 0;typeB = 0;}
public int compareTo(ContactID o) {return getKey() - o.getKey();}public void sendHttpRequest(HttpRequest httpRequest, HttpResponseListener httpResponseListener) {netJavaImpl.sendHttpRequest(httpRequest, httpResponseListener);}
public void cancelHttpRequest(HttpRequest httpRequest) {netJavaImpl.cancelHttpRequest(httpRequest);}
public ServerSocket newServerSocket(Protocol protocol, String hostname, int port, ServerSocketHints hints) {return new NetJavaServerSocketImpl(protocol, hostname, port, hints);}
public ServerSocket newServerSocket(Protocol protocol, int port, ServerSocketHints hints) {return new NetJavaServerSocketImpl(protocol, port, hints);}
public Socket newClientSocket(Protocol protocol, String host, int port, SocketHints hints) {return new NetJavaSocketImpl(protocol, host, port, hints);}
public boolean openURI(String URI) {boolean result = false;try {if (!GraphicsEnvironment.isHeadless() && Desktop.isDesktopSupported()) {if (Desktop.getDesktop().isSupported(Action.BROWSE)) {Desktop.getDesktop().browse(java.net.URI.create(URI));result = true;}} else {Gdx.app.error("HeadlessNet", "Opening URIs on this environment is not supported. Ignoring.");}} catch (Throwable t) {Gdx.app.error("HeadlessNet", "Failed to open URI. ", t);}return result;}public T add(T node) {// Expand if necessary.if (size == nodes.length) {Node[] newNodes = new Node[size << 1];System.arraycopy(nodes, 0, newNodes, 0, size);nodes = newNodes;}// Insert at end and bubble up.node.index = size;nodes[size] = node;up(size++);return node;}
public T add(T node, float value) {node.value = value;return add(node);}
public T peek() {if (size == 0)throw new IllegalStateException("The heap is empty.");return (T) nodes[0];}
public T pop() {return remove(0);}
public T remove(T node) {return remove(node.index);}
private T remove(int index) {Node[] nodes = this.nodes;Node removed = nodes[index];nodes[index] = nodes[--size];nodes[size] = null;if (size > 0 && index < size)down(index);return (T) removed;}
public void clear() {Node[] nodes = this.nodes;for (int i = 0, n = size; i < n; i++) nodes[i] = null;size = 0;}
public void setValue(T node, float value) {float oldValue = node.value;node.value = value;if (value < oldValue ^ isMaxHeap)up(node.index);elsedown(node.index);}
private void up(int index) {Node[] nodes = this.nodes;Node node = nodes[index];float value = node.value;while (index > 0) {int parentIndex = (index - 1) >> 1;Node parent = nodes[parentIndex];if (value < parent.value ^ isMaxHeap) {nodes[index] = parent;parent.index = index;index = parentIndex;} elsebreak;}nodes[index] = node;node.index = index;}
private void down(int index) {Node[] nodes = this.nodes;int size = this.size;Node node = nodes[index];float value = node.value;while (true) {int leftIndex = 1 + (index << 1);if (leftIndex >= size)break;int rightIndex = leftIndex + 1;// Always have a left child.Node leftNode = nodes[leftIndex];float leftValue = leftNode.value;// May have a right child.Node rightNode;float rightValue;if (rightIndex >= size) {rightNode = null;rightValue = isMaxHeap ? Float.MIN_VALUE : Float.MAX_VALUE;} else {rightNode = nodes[rightIndex];rightValue = rightNode.value;}// The smallest of the three values is the parent.if (leftValue < rightValue ^ isMaxHeap) {if (leftValue == value || (leftValue > value ^ isMaxHeap))break;nodes[index] = leftNode;leftNode.index = index;index = leftIndex;} else {if (rightValue == value || (rightValue > value ^ isMaxHeap))break;nodes[index] = rightNode;rightNode.index = index;index = rightIndex;}}nodes[index] = node;node.index = index;}
public boolean equals(Object obj) {if (!(obj instanceof BinaryHeap))return false;BinaryHeap other = (BinaryHeap) obj;if (other.size != size)return false;for (int i = 0, n = size; i < n; i++) if (other.nodes[i].value != nodes[i].value)return false;return true;}
public int hashCode() {int h = 1;for (int i = 0, n = size; i < n; i++) h = h * 31 + Float.floatToIntBits(nodes[i].value);return h;}
public String toString() {if (size == 0)return "[]";Node[] nodes = this.nodes;StringBuilder buffer = new StringBuilder(32);buffer.append('[');buffer.append(nodes[0].value);for (int i = 1; i < size; i++) {buffer.append(", ");buffer.append(nodes[i].value);}buffer.append(']');return buffer.toString();}
public float getValue() {return value;}
public String toString() {return Float.toString(value);}public static void main(String[] args) {String[] headers = { "freetype-2.6.2/include" };String[] sources = { // BASE"freetype-2.6.2/src/base/ftsystem.c", "freetype-2.6.2/src/base/ftinit.c", "freetype-2.6.2/src/base/ftdebug.c", "freetype-2.6.2/src/base/ftbase.c", "freetype-2.6.2/src/base/ftbbox.c", "freetype-2.6.2/src/base/ftglyph.c", "freetype-2.6.2/src/base/ftbdf.c", "freetype-2.6.2/src/base/ftbitmap.c", "freetype-2.6.2/src/base/ftcid.c", "freetype-2.6.2/src/base/ftfstype.c", "freetype-2.6.2/src/base/ftgasp.c", "freetype-2.6.2/src/base/ftgxval.c", "freetype-2.6.2/src/base/ftlcdfil.c", "freetype-2.6.2/src/base/ftmm.c", "freetype-2.6.2/src/base/ftotval.c", "freetype-2.6.2/src/base/ftpatent.c", "freetype-2.6.2/src/base/ftpfr.c", "freetype-2.6.2/src/base/ftstroke.c", "freetype-2.6.2/src/base/ftsynth.c", "freetype-2.6.2/src/base/fttype1.c", "freetype-2.6.2/src/base/ftwinfnt.c", "freetype-2.6.2/src/base/ftxf86.c", // DRIVERS"freetype-2.6.2/src/bdf/bdf.c", "freetype-2.6.2/src/cff/cff.c", "freetype-2.6.2/src/cid/type1cid.c", "freetype-2.6.2/src/pcf/pcf.c", "freetype-2.6.2/src/pfr/pfr.c", "freetype-2.6.2/src/sfnt/sfnt.c", "freetype-2.6.2/src/truetype/truetype.c", "freetype-2.6.2/src/type1/type1.c", "freetype-2.6.2/src/type42/type42.c", "freetype-2.6.2/src/winfonts/winfnt.c", // RASTERIZERS"freetype-2.6.2/src/raster/raster.c", "freetype-2.6.2/src/smooth/smooth.c", // AUX"freetype-2.6.2/src/autofit/autofit.c", "freetype-2.6.2/src/cache/ftcache.c", "freetype-2.6.2/src/gzip/ftgzip.c", "freetype-2.6.2/src/lzw/ftlzw.c", "freetype-2.6.2/src/bzip2/ftbzip2.c", "freetype-2.6.2/src/gxvalid/gxvalid.c", "freetype-2.6.2/src/otvalid/otvalid.c", "freetype-2.6.2/src/psaux/psaux.c", "freetype-2.6.2/src/pshinter/pshinter.c", "freetype-2.6.2/src/psnames/psnames.c" };BuildTarget win32home = BuildTarget.newDefaultTarget(TargetOs.Windows, false);win32home.compilerPrefix = "";win32home.buildFileName = "build-windows32home.xml";win32home.excludeFromMasterBuildFile = true;win32home.headerDirs = headers;win32home.cIncludes = sources;win32home.cFlags += " -std=c99 -DFT2_BUILD_LIBRARY";win32home.cppFlags += " -std=c99 -DFT2_BUILD_LIBRARY";BuildTarget win32 = BuildTarget.newDefaultTarget(TargetOs.Windows, false);win32.headerDirs = headers;win32.cIncludes = sources;win32.cFlags += " -std=c99 -DFT2_BUILD_LIBRARY";win32.cppFlags += " -std=c99 -DFT2_BUILD_LIBRARY";BuildTarget win64 = BuildTarget.newDefaultTarget(TargetOs.Windows, true);win64.headerDirs = headers;win64.cIncludes = sources;win64.cFlags += " -std=c99 -DFT2_BUILD_LIBRARY";win64.cppFlags += " -std=c99 -DFT2_BUILD_LIBRARY";BuildTarget lin32 = BuildTarget.newDefaultTarget(TargetOs.Linux, false);lin32.headerDirs = headers;lin32.cIncludes = sources;lin32.cFlags += " -std=c99 -DFT2_BUILD_LIBRARY";lin32.cppFlags += " -std=c99 -DFT2_BUILD_LIBRARY";BuildTarget lin64 = BuildTarget.newDefaultTarget(TargetOs.Linux, true);lin64.headerDirs = headers;lin64.cIncludes = sources;lin64.cFlags += " -std=c99 -DFT2_BUILD_LIBRARY";lin64.cppFlags += " -std=c99 -DFT2_BUILD_LIBRARY";BuildTarget mac = BuildTarget.newDefaultTarget(TargetOs.MacOsX, false);mac.headerDirs = headers;mac.cIncludes = sources;mac.cFlags += " -DFT2_BUILD_LIBRARY";mac.cppFlags += " -DFT2_BUILD_LIBRARY";mac.linkerFlags += " -framework CoreServices -framework Carbon";BuildTarget mac64 = BuildTarget.newDefaultTarget(TargetOs.MacOsX, true);mac64.headerDirs = headers;mac64.cIncludes = sources;mac64.cFlags += " -DFT2_BUILD_LIBRARY";mac64.cppFlags += " -DFT2_BUILD_LIBRARY";mac64.linkerFlags += " -framework CoreServices -framework Carbon";BuildTarget android = BuildTarget.newDefaultTarget(TargetOs.Android, false);android.headerDirs = headers;android.cIncludes = sources;android.cFlags += " -std=c99 -DFT2_BUILD_LIBRARY";android.cppFlags += " -std=c99 -DFT2_BUILD_LIBRARY";BuildTarget ios = BuildTarget.newDefaultTarget(TargetOs.IOS, false);ios.headerDirs = headers;ios.cIncludes = sources;ios.cFlags += " -DFT2_BUILD_LIBRARY";ios.cppFlags += " -DFT2_BUILD_LIBRARY";new NativeCodeGenerator().generate();new AntScriptGenerator().generate(new BuildConfig("gdx-freetype"), win32home, win32, win64, lin32, lin64, mac, mac64, android, ios);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btTriangleConvexcastCallback_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btTriangleConvexcastCallback obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btTriangleConvexcastCallback(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void swigDirectorDisconnect() {swigCMemOwn = false;delete();}
public void swigReleaseOwnership() {swigCMemOwn = false;CollisionJNI.btTriangleConvexcastCallback_change_ownership(this, swigCPtr, false);}
public void swigTakeOwnership() {swigCMemOwn = true;CollisionJNI.btTriangleConvexcastCallback_change_ownership(this, swigCPtr, true);}
public void setConvexShape(btConvexShape value) {CollisionJNI.btTriangleConvexcastCallback_convexShape_set(swigCPtr, this, btConvexShape.getCPtr(value), value);}
public btConvexShape getConvexShape() {long cPtr = CollisionJNI.btTriangleConvexcastCallback_convexShape_get(swigCPtr, this);return (cPtr == 0) ? null : new btConvexShape(cPtr, false);}
public void setConvexShapeFrom(btTransform value) {CollisionJNI.btTriangleConvexcastCallback_convexShapeFrom_set(swigCPtr, this, btTransform.getCPtr(value), value);}
public btTransform getConvexShapeFrom() {long cPtr = CollisionJNI.btTriangleConvexcastCallback_convexShapeFrom_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransform(cPtr, false);}
public void setConvexShapeTo(btTransform value) {CollisionJNI.btTriangleConvexcastCallback_convexShapeTo_set(swigCPtr, this, btTransform.getCPtr(value), value);}
public btTransform getConvexShapeTo() {long cPtr = CollisionJNI.btTriangleConvexcastCallback_convexShapeTo_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransform(cPtr, false);}
public void setTriangleToWorld(btTransform value) {CollisionJNI.btTriangleConvexcastCallback_triangleToWorld_set(swigCPtr, this, btTransform.getCPtr(value), value);}
public btTransform getTriangleToWorld() {long cPtr = CollisionJNI.btTriangleConvexcastCallback_triangleToWorld_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransform(cPtr, false);}
public void setHitFraction(float value) {CollisionJNI.btTriangleConvexcastCallback_hitFraction_set(swigCPtr, this, value);}
public float getHitFraction() {return CollisionJNI.btTriangleConvexcastCallback_hitFraction_get(swigCPtr, this);}
public void setTriangleCollisionMargin(float value) {CollisionJNI.btTriangleConvexcastCallback_triangleCollisionMargin_set(swigCPtr, this, value);}
public float getTriangleCollisionMargin() {return CollisionJNI.btTriangleConvexcastCallback_triangleCollisionMargin_get(swigCPtr, this);}
public void setAllowedPenetration(float value) {CollisionJNI.btTriangleConvexcastCallback_allowedPenetration_set(swigCPtr, this, value);}
public float getAllowedPenetration() {return CollisionJNI.btTriangleConvexcastCallback_allowedPenetration_get(swigCPtr, this);}
public void processTriangle(btVector3 triangle, int partId, int triangleIndex) {if (getClass() == btTriangleConvexcastCallback.class)CollisionJNI.btTriangleConvexcastCallback_processTriangle(swigCPtr, this, btVector3.getCPtr(triangle), triangle, partId, triangleIndex);elseCollisionJNI.btTriangleConvexcastCallback_processTriangleSwigExplicitbtTriangleConvexcastCallback(swigCPtr, this, btVector3.getCPtr(triangle), triangle, partId, triangleIndex);}
public float reportHit(Vector3 hitNormalLocal, Vector3 hitPointLocal, float hitFraction, int partId, int triangleIndex) {return CollisionJNI.btTriangleConvexcastCallback_reportHit(swigCPtr, this, hitNormalLocal, hitPointLocal, hitFraction, partId, triangleIndex);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(SoftBodyClusterData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_SoftBodyClusterData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setFramexform(btTransformFloatData value) {SoftbodyJNI.SoftBodyClusterData_framexform_set(swigCPtr, this, btTransformFloatData.getCPtr(value), value);}
public btTransformFloatData getFramexform() {long cPtr = SoftbodyJNI.SoftBodyClusterData_framexform_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformFloatData(cPtr, false);}
public void setLocii(SWIGTYPE_p_btMatrix3x3FloatData value) {SoftbodyJNI.SoftBodyClusterData_locii_set(swigCPtr, this, SWIGTYPE_p_btMatrix3x3FloatData.getCPtr(value));}
public SWIGTYPE_p_btMatrix3x3FloatData getLocii() {return new SWIGTYPE_p_btMatrix3x3FloatData(SoftbodyJNI.SoftBodyClusterData_locii_get(swigCPtr, this), true);}
public void setInvwi(SWIGTYPE_p_btMatrix3x3FloatData value) {SoftbodyJNI.SoftBodyClusterData_invwi_set(swigCPtr, this, SWIGTYPE_p_btMatrix3x3FloatData.getCPtr(value));}
public SWIGTYPE_p_btMatrix3x3FloatData getInvwi() {return new SWIGTYPE_p_btMatrix3x3FloatData(SoftbodyJNI.SoftBodyClusterData_invwi_get(swigCPtr, this), true);}
public void setCom(btVector3FloatData value) {SoftbodyJNI.SoftBodyClusterData_com_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getCom() {long cPtr = SoftbodyJNI.SoftBodyClusterData_com_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setVimpulses(btVector3FloatData value) {SoftbodyJNI.SoftBodyClusterData_vimpulses_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getVimpulses() {long cPtr = SoftbodyJNI.SoftBodyClusterData_vimpulses_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setDimpulses(btVector3FloatData value) {SoftbodyJNI.SoftBodyClusterData_dimpulses_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getDimpulses() {long cPtr = SoftbodyJNI.SoftBodyClusterData_dimpulses_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setLv(btVector3FloatData value) {SoftbodyJNI.SoftBodyClusterData_lv_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getLv() {long cPtr = SoftbodyJNI.SoftBodyClusterData_lv_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setAv(btVector3FloatData value) {SoftbodyJNI.SoftBodyClusterData_av_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getAv() {long cPtr = SoftbodyJNI.SoftBodyClusterData_av_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setFramerefs(btVector3FloatData value) {SoftbodyJNI.SoftBodyClusterData_framerefs_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getFramerefs() {long cPtr = SoftbodyJNI.SoftBodyClusterData_framerefs_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setNodeIndices(java.nio.IntBuffer value) {assert value.isDirect() : "Buffer must be allocated direct.";{SoftbodyJNI.SoftBodyClusterData_nodeIndices_set(swigCPtr, this, value);}}
public java.nio.IntBuffer getNodeIndices() {return SoftbodyJNI.SoftBodyClusterData_nodeIndices_get(swigCPtr, this);}
public void setMasses(java.nio.FloatBuffer value) {assert value.isDirect() : "Buffer must be allocated direct.";{SoftbodyJNI.SoftBodyClusterData_masses_set(swigCPtr, this, value);}}
public java.nio.FloatBuffer getMasses() {return SoftbodyJNI.SoftBodyClusterData_masses_get(swigCPtr, this);}
public void setNumFrameRefs(int value) {SoftbodyJNI.SoftBodyClusterData_numFrameRefs_set(swigCPtr, this, value);}
public int getNumFrameRefs() {return SoftbodyJNI.SoftBodyClusterData_numFrameRefs_get(swigCPtr, this);}
public void setNumNodes(int value) {SoftbodyJNI.SoftBodyClusterData_numNodes_set(swigCPtr, this, value);}
public int getNumNodes() {return SoftbodyJNI.SoftBodyClusterData_numNodes_get(swigCPtr, this);}
public void setNumMasses(int value) {SoftbodyJNI.SoftBodyClusterData_numMasses_set(swigCPtr, this, value);}
public int getNumMasses() {return SoftbodyJNI.SoftBodyClusterData_numMasses_get(swigCPtr, this);}
public void setIdmass(float value) {SoftbodyJNI.SoftBodyClusterData_idmass_set(swigCPtr, this, value);}
public float getIdmass() {return SoftbodyJNI.SoftBodyClusterData_idmass_get(swigCPtr, this);}
public void setImass(float value) {SoftbodyJNI.SoftBodyClusterData_imass_set(swigCPtr, this, value);}
public float getImass() {return SoftbodyJNI.SoftBodyClusterData_imass_get(swigCPtr, this);}
public void setNvimpulses(int value) {SoftbodyJNI.SoftBodyClusterData_nvimpulses_set(swigCPtr, this, value);}
public int getNvimpulses() {return SoftbodyJNI.SoftBodyClusterData_nvimpulses_get(swigCPtr, this);}
public void setNdimpulses(int value) {SoftbodyJNI.SoftBodyClusterData_ndimpulses_set(swigCPtr, this, value);}
public int getNdimpulses() {return SoftbodyJNI.SoftBodyClusterData_ndimpulses_get(swigCPtr, this);}
public void setNdamping(float value) {SoftbodyJNI.SoftBodyClusterData_ndamping_set(swigCPtr, this, value);}
public float getNdamping() {return SoftbodyJNI.SoftBodyClusterData_ndamping_get(swigCPtr, this);}
public void setLdamping(float value) {SoftbodyJNI.SoftBodyClusterData_ldamping_set(swigCPtr, this, value);}
public float getLdamping() {return SoftbodyJNI.SoftBodyClusterData_ldamping_get(swigCPtr, this);}
public void setAdamping(float value) {SoftbodyJNI.SoftBodyClusterData_adamping_set(swigCPtr, this, value);}
public float getAdamping() {return SoftbodyJNI.SoftBodyClusterData_adamping_get(swigCPtr, this);}
public void setMatching(float value) {SoftbodyJNI.SoftBodyClusterData_matching_set(swigCPtr, this, value);}
public float getMatching() {return SoftbodyJNI.SoftBodyClusterData_matching_get(swigCPtr, this);}
public void setMaxSelfCollisionImpulse(float value) {SoftbodyJNI.SoftBodyClusterData_maxSelfCollisionImpulse_set(swigCPtr, this, value);}
public float getMaxSelfCollisionImpulse() {return SoftbodyJNI.SoftBodyClusterData_maxSelfCollisionImpulse_get(swigCPtr, this);}
public void setSelfCollisionImpulseFactor(float value) {SoftbodyJNI.SoftBodyClusterData_selfCollisionImpulseFactor_set(swigCPtr, this, value);}
public float getSelfCollisionImpulseFactor() {return SoftbodyJNI.SoftBodyClusterData_selfCollisionImpulseFactor_get(swigCPtr, this);}
public void setContainsAnchor(int value) {SoftbodyJNI.SoftBodyClusterData_containsAnchor_set(swigCPtr, this, value);}
public int getContainsAnchor() {return SoftbodyJNI.SoftBodyClusterData_containsAnchor_get(swigCPtr, this);}
public void setCollide(int value) {SoftbodyJNI.SoftBodyClusterData_collide_set(swigCPtr, this, value);}
public int getCollide() {return SoftbodyJNI.SoftBodyClusterData_collide_get(swigCPtr, this);}
public void setClusterIndex(int value) {SoftbodyJNI.SoftBodyClusterData_clusterIndex_set(swigCPtr, this, value);}
public int getClusterIndex() {return SoftbodyJNI.SoftBodyClusterData_clusterIndex_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btGeneric6DofConstraintDoubleData2 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btGeneric6DofConstraintDoubleData2(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setTypeConstraintData(btTypedConstraintDoubleData value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_typeConstraintData_set(swigCPtr, this, btTypedConstraintDoubleData.getCPtr(value), value);}
public btTypedConstraintDoubleData getTypeConstraintData() {long cPtr = DynamicsJNI.btGeneric6DofConstraintDoubleData2_typeConstraintData_get(swigCPtr, this);return (cPtr == 0) ? null : new btTypedConstraintDoubleData(cPtr, false);}
public void setRbAFrame(btTransformDoubleData value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_rbAFrame_set(swigCPtr, this, btTransformDoubleData.getCPtr(value), value);}
public btTransformDoubleData getRbAFrame() {long cPtr = DynamicsJNI.btGeneric6DofConstraintDoubleData2_rbAFrame_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformDoubleData(cPtr, false);}
public void setRbBFrame(btTransformDoubleData value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_rbBFrame_set(swigCPtr, this, btTransformDoubleData.getCPtr(value), value);}
public btTransformDoubleData getRbBFrame() {long cPtr = DynamicsJNI.btGeneric6DofConstraintDoubleData2_rbBFrame_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformDoubleData(cPtr, false);}
public void setLinearUpperLimit(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_linearUpperLimit_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearUpperLimit() {long cPtr = DynamicsJNI.btGeneric6DofConstraintDoubleData2_linearUpperLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearLowerLimit(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_linearLowerLimit_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearLowerLimit() {long cPtr = DynamicsJNI.btGeneric6DofConstraintDoubleData2_linearLowerLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularUpperLimit(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_angularUpperLimit_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularUpperLimit() {long cPtr = DynamicsJNI.btGeneric6DofConstraintDoubleData2_angularUpperLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularLowerLimit(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_angularLowerLimit_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularLowerLimit() {long cPtr = DynamicsJNI.btGeneric6DofConstraintDoubleData2_angularLowerLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setUseLinearReferenceFrameA(int value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_useLinearReferenceFrameA_set(swigCPtr, this, value);}
public int getUseLinearReferenceFrameA() {return DynamicsJNI.btGeneric6DofConstraintDoubleData2_useLinearReferenceFrameA_get(swigCPtr, this);}
public void setUseOffsetForConstraintFrame(int value) {DynamicsJNI.btGeneric6DofConstraintDoubleData2_useOffsetForConstraintFrame_set(swigCPtr, this, value);}
public int getUseOffsetForConstraintFrame() {return DynamicsJNI.btGeneric6DofConstraintDoubleData2_useOffsetForConstraintFrame_get(swigCPtr, this);}public final void setZero() {x = 0.0f;y = 0.0f;}
public final Vec2 set(float x, float y) {this.x = x;this.y = y;return this;}
public final Vec2 set(Vec2 v) {this.x = v.x;this.y = v.y;return this;}
public final Vec2 add(Vec2 v) {return new Vec2(x + v.x, y + v.y);}
public final Vec2 sub(Vec2 v) {return new Vec2(x - v.x, y - v.y);}
public final Vec2 mul(float a) {return new Vec2(x * a, y * a);}
public final Vec2 negate() {return new Vec2(-x, -y);}
public final Vec2 negateLocal() {x = -x;y = -y;return this;}
public final Vec2 addLocal(Vec2 v) {x += v.x;y += v.y;return this;}
public final Vec2 addLocal(float x, float y) {this.x += x;this.y += y;return this;}
public final Vec2 subLocal(Vec2 v) {x -= v.x;y -= v.y;return this;}
public final Vec2 mulLocal(float a) {x *= a;y *= a;return this;}
public final Vec2 skew() {return new Vec2(-y, x);}
public final void skew(Vec2 out) {out.x = -y;out.y = x;}
public final float length() {return MathUtils.sqrt(x * x + y * y);}
public final float lengthSquared() {return (x * x + y * y);}
public final float normalize() {float length = length();if (length < Settings.EPSILON) {return 0f;}float invLength = 1.0f / length;x *= invLength;y *= invLength;return length;}
public final boolean isValid() {return !Float.isNaN(x) && !Float.isInfinite(x) && !Float.isNaN(y) && !Float.isInfinite(y);}
public final Vec2 abs() {return new Vec2(MathUtils.abs(x), MathUtils.abs(y));}
public final void absLocal() {x = MathUtils.abs(x);y = MathUtils.abs(y);}
public final Vec2 clone() {return new Vec2(x, y);}
public final String toString() {return "(" + x + "," + y + ")";}
public static final Vec2 abs(Vec2 a) {return new Vec2(MathUtils.abs(a.x), MathUtils.abs(a.y));}
public static final void absToOut(Vec2 a, Vec2 out) {out.x = MathUtils.abs(a.x);out.y = MathUtils.abs(a.y);}
public static final float dot(final Vec2 a, final Vec2 b) {return a.x * b.x + a.y * b.y;}
public static final float cross(final Vec2 a, final Vec2 b) {return a.x * b.y - a.y * b.x;}
public static final Vec2 cross(Vec2 a, float s) {return new Vec2(s * a.y, -s * a.x);}
public static final void crossToOut(Vec2 a, float s, Vec2 out) {final float tempy = -s * a.x;out.x = s * a.y;out.y = tempy;}
public static final void crossToOutUnsafe(Vec2 a, float s, Vec2 out) {assert (out != a);out.x = s * a.y;out.y = -s * a.x;}
public static final Vec2 cross(float s, Vec2 a) {return new Vec2(-s * a.y, s * a.x);}
public static final void crossToOut(float s, Vec2 a, Vec2 out) {final float tempY = s * a.x;out.x = -s * a.y;out.y = tempY;}
public static final void crossToOutUnsafe(float s, Vec2 a, Vec2 out) {assert (out != a);out.x = -s * a.y;out.y = s * a.x;}
public static final void negateToOut(Vec2 a, Vec2 out) {out.x = -a.x;out.y = -a.y;}
public static final Vec2 min(Vec2 a, Vec2 b) {return new Vec2(a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y);}
public static final Vec2 max(Vec2 a, Vec2 b) {return new Vec2(a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y);}
public static final void minToOut(Vec2 a, Vec2 b, Vec2 out) {out.x = a.x < b.x ? a.x : b.x;out.y = a.y < b.y ? a.y : b.y;}
public static final void maxToOut(Vec2 a, Vec2 b, Vec2 out) {out.x = a.x > b.x ? a.x : b.x;out.y = a.y > b.y ? a.y : b.y;}
public int hashCode() {// automatically generated by Eclipsefinal int prime = 31;int result = 1;result = prime * result + Float.floatToIntBits(x);result = prime * result + Float.floatToIntBits(y);return result;}
public boolean equals(Object obj) {// automatically generated by Eclipseif (this == obj)return true;if (obj == null)return false;if (getClass() != obj.getClass())return false;Vec2 other = (Vec2) obj;if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x))return false;if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y))return false;return true;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btBvhSubtreeInfo obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btBvhSubtreeInfo(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setQuantizedAabbMin(int[] value) {CollisionJNI.btBvhSubtreeInfo_quantizedAabbMin_set(swigCPtr, this, value);}
public int[] getQuantizedAabbMin() {return CollisionJNI.btBvhSubtreeInfo_quantizedAabbMin_get(swigCPtr, this);}
public void setQuantizedAabbMax(int[] value) {CollisionJNI.btBvhSubtreeInfo_quantizedAabbMax_set(swigCPtr, this, value);}
public int[] getQuantizedAabbMax() {return CollisionJNI.btBvhSubtreeInfo_quantizedAabbMax_get(swigCPtr, this);}
public void setRootNodeIndex(int value) {CollisionJNI.btBvhSubtreeInfo_rootNodeIndex_set(swigCPtr, this, value);}
public int getRootNodeIndex() {return CollisionJNI.btBvhSubtreeInfo_rootNodeIndex_get(swigCPtr, this);}
public void setSubtreeSize(int value) {CollisionJNI.btBvhSubtreeInfo_subtreeSize_set(swigCPtr, this, value);}
public int getSubtreeSize() {return CollisionJNI.btBvhSubtreeInfo_subtreeSize_get(swigCPtr, this);}
public void setPadding(int[] value) {CollisionJNI.btBvhSubtreeInfo_padding_set(swigCPtr, this, value);}
public int[] getPadding() {return CollisionJNI.btBvhSubtreeInfo_padding_get(swigCPtr, this);}
public void setAabbFromQuantizeNode(btQuantizedBvhNode quantizedNode) {CollisionJNI.btBvhSubtreeInfo_setAabbFromQuantizeNode(swigCPtr, this, btQuantizedBvhNode.getCPtr(quantizedNode), quantizedNode);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btCollisionWorld obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btCollisionWorld(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setBroadphase(btBroadphaseInterface pairCache) {CollisionJNI.btCollisionWorld_setBroadphase(swigCPtr, this, btBroadphaseInterface.getCPtr(pairCache), pairCache);}
public btBroadphaseInterface getBroadphase() {long cPtr = CollisionJNI.btCollisionWorld_getBroadphase__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : new btBroadphaseInterface(cPtr, false);}
public btOverlappingPairCache getPairCache() {long cPtr = CollisionJNI.btCollisionWorld_getPairCache(swigCPtr, this);return (cPtr == 0) ? null : new btOverlappingPairCache(cPtr, false);}
public btDispatcher getDispatcher() {long cPtr = CollisionJNI.btCollisionWorld_getDispatcher__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : new btDispatcher(cPtr, false);}
public void updateSingleAabb(btCollisionObject colObj) {CollisionJNI.btCollisionWorld_updateSingleAabb(swigCPtr, this, btCollisionObject.getCPtr(colObj), colObj);}
public void updateAabbs() {CollisionJNI.btCollisionWorld_updateAabbs(swigCPtr, this);}
public void computeOverlappingPairs() {CollisionJNI.btCollisionWorld_computeOverlappingPairs(swigCPtr, this);}
public void setDebugDrawer(btIDebugDraw debugDrawer) {CollisionJNI.btCollisionWorld_setDebugDrawer(swigCPtr, this, btIDebugDraw.getCPtr(debugDrawer), debugDrawer);}
public btIDebugDraw getDebugDrawer() {long cPtr = CollisionJNI.btCollisionWorld_getDebugDrawer(swigCPtr, this);return (cPtr == 0) ? null : new btIDebugDraw(cPtr, false);}
public void debugDrawWorld() {CollisionJNI.btCollisionWorld_debugDrawWorld(swigCPtr, this);}
public void debugDrawObject(Matrix4 worldTransform, btCollisionShape shape, Vector3 color) {CollisionJNI.btCollisionWorld_debugDrawObject(swigCPtr, this, worldTransform, btCollisionShape.getCPtr(shape), shape, color);}
public int getNumCollisionObjects() {return CollisionJNI.btCollisionWorld_getNumCollisionObjects(swigCPtr, this);}
public void rayTest(Vector3 rayFromWorld, Vector3 rayToWorld, RayResultCallback resultCallback) {CollisionJNI.btCollisionWorld_rayTest(swigCPtr, this, rayFromWorld, rayToWorld, RayResultCallback.getCPtr(resultCallback), resultCallback);}
public void convexSweepTest(btConvexShape castShape, Matrix4 from, Matrix4 to, ConvexResultCallback resultCallback, float allowedCcdPenetration) {CollisionJNI.btCollisionWorld_convexSweepTest__SWIG_0(swigCPtr, this, btConvexShape.getCPtr(castShape), castShape, from, to, ConvexResultCallback.getCPtr(resultCallback), resultCallback, allowedCcdPenetration);}
public void convexSweepTest(btConvexShape castShape, Matrix4 from, Matrix4 to, ConvexResultCallback resultCallback) {CollisionJNI.btCollisionWorld_convexSweepTest__SWIG_1(swigCPtr, this, btConvexShape.getCPtr(castShape), castShape, from, to, ConvexResultCallback.getCPtr(resultCallback), resultCallback);}
public void contactTest(btCollisionObject colObj, ContactResultCallback resultCallback) {CollisionJNI.btCollisionWorld_contactTest(swigCPtr, this, btCollisionObject.getCPtr(colObj), colObj, ContactResultCallback.getCPtr(resultCallback), resultCallback);}
public void contactPairTest(btCollisionObject colObjA, btCollisionObject colObjB, ContactResultCallback resultCallback) {CollisionJNI.btCollisionWorld_contactPairTest(swigCPtr, this, btCollisionObject.getCPtr(colObjA), colObjA, btCollisionObject.getCPtr(colObjB), colObjB, ContactResultCallback.getCPtr(resultCallback), resultCallback);}
public static void rayTestSingle(Matrix4 rayFromTrans, Matrix4 rayToTrans, btCollisionObject collisionObject, btCollisionShape collisionShape, Matrix4 colObjWorldTransform, RayResultCallback resultCallback) {CollisionJNI.btCollisionWorld_rayTestSingle(rayFromTrans, rayToTrans, btCollisionObject.getCPtr(collisionObject), collisionObject, btCollisionShape.getCPtr(collisionShape), collisionShape, colObjWorldTransform, RayResultCallback.getCPtr(resultCallback), resultCallback);}
public static void rayTestSingleInternal(Matrix4 rayFromTrans, Matrix4 rayToTrans, btCollisionObjectWrapper collisionObjectWrap, RayResultCallback resultCallback) {CollisionJNI.btCollisionWorld_rayTestSingleInternal(rayFromTrans, rayToTrans, btCollisionObjectWrapper.getCPtr(collisionObjectWrap), collisionObjectWrap, RayResultCallback.getCPtr(resultCallback), resultCallback);}
public static void objectQuerySingle(btConvexShape castShape, Matrix4 rayFromTrans, Matrix4 rayToTrans, btCollisionObject collisionObject, btCollisionShape collisionShape, Matrix4 colObjWorldTransform, ConvexResultCallback resultCallback, float allowedPenetration) {CollisionJNI.btCollisionWorld_objectQuerySingle(btConvexShape.getCPtr(castShape), castShape, rayFromTrans, rayToTrans, btCollisionObject.getCPtr(collisionObject), collisionObject, btCollisionShape.getCPtr(collisionShape), collisionShape, colObjWorldTransform, ConvexResultCallback.getCPtr(resultCallback), resultCallback, allowedPenetration);}
public static void objectQuerySingleInternal(btConvexShape castShape, Matrix4 convexFromTrans, Matrix4 convexToTrans, btCollisionObjectWrapper colObjWrap, ConvexResultCallback resultCallback, float allowedPenetration) {CollisionJNI.btCollisionWorld_objectQuerySingleInternal(btConvexShape.getCPtr(castShape), castShape, convexFromTrans, convexToTrans, btCollisionObjectWrapper.getCPtr(colObjWrap), colObjWrap, ConvexResultCallback.getCPtr(resultCallback), resultCallback, allowedPenetration);}
public void addCollisionObject(btCollisionObject collisionObject, short collisionFilterGroup, short collisionFilterMask) {CollisionJNI.btCollisionWorld_addCollisionObject__SWIG_0(swigCPtr, this, btCollisionObject.getCPtr(collisionObject), collisionObject, collisionFilterGroup, collisionFilterMask);}
public void addCollisionObject(btCollisionObject collisionObject, short collisionFilterGroup) {CollisionJNI.btCollisionWorld_addCollisionObject__SWIG_1(swigCPtr, this, btCollisionObject.getCPtr(collisionObject), collisionObject, collisionFilterGroup);}
public void addCollisionObject(btCollisionObject collisionObject) {CollisionJNI.btCollisionWorld_addCollisionObject__SWIG_2(swigCPtr, this, btCollisionObject.getCPtr(collisionObject), collisionObject);}
public btCollisionObjectArray getCollisionObjectArray() {return new btCollisionObjectArray(CollisionJNI.btCollisionWorld_getCollisionObjectArray__SWIG_0(swigCPtr, this), false);}
public void removeCollisionObject(btCollisionObject collisionObject) {CollisionJNI.btCollisionWorld_removeCollisionObject(swigCPtr, this, btCollisionObject.getCPtr(collisionObject), collisionObject);}
public void performDiscreteCollisionDetection() {CollisionJNI.btCollisionWorld_performDiscreteCollisionDetection(swigCPtr, this);}
public btDispatcherInfo getDispatchInfo() {return new btDispatcherInfo(CollisionJNI.btCollisionWorld_getDispatchInfo__SWIG_0(swigCPtr, this), false);}
public boolean getForceUpdateAllAabbs() {return CollisionJNI.btCollisionWorld_getForceUpdateAllAabbs(swigCPtr, this);}
public void setForceUpdateAllAabbs(boolean forceUpdateAllAabbs) {CollisionJNI.btCollisionWorld_setForceUpdateAllAabbs(swigCPtr, this, forceUpdateAllAabbs);}
public void serialize(SWIGTYPE_p_btSerializer serializer) {CollisionJNI.btCollisionWorld_serialize(swigCPtr, this, SWIGTYPE_p_btSerializer.getCPtr(serializer));}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btMultiSapBroadphase_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btMultiSapBroadphase obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btMultiSapBroadphase(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btMultiSapBroadphase_btMultiSapProxy_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btMultiSapProxy obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btMultiSapBroadphase_btMultiSapProxy(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setAabbMin(btVector3 value) {CollisionJNI.btMultiSapBroadphase_btMultiSapProxy_aabbMin_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getAabbMin() {long cPtr = CollisionJNI.btMultiSapBroadphase_btMultiSapProxy_aabbMin_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setAabbMax(btVector3 value) {CollisionJNI.btMultiSapBroadphase_btMultiSapProxy_aabbMax_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getAabbMax() {long cPtr = CollisionJNI.btMultiSapBroadphase_btMultiSapProxy_aabbMax_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setShapeType(int value) {CollisionJNI.btMultiSapBroadphase_btMultiSapProxy_shapeType_set(swigCPtr, this, value);}
public int getShapeType() {return CollisionJNI.btMultiSapBroadphase_btMultiSapProxy_shapeType_get(swigCPtr, this);}
public SWIGTYPE_p_btAlignedObjectArrayT_btBroadphaseInterface_p_t getBroadphaseArray() {return new SWIGTYPE_p_btAlignedObjectArrayT_btBroadphaseInterface_p_t(CollisionJNI.btMultiSapBroadphase_getBroadphaseArray__SWIG_0(swigCPtr, this), false);}
public void rayTest(Vector3 rayFrom, Vector3 rayTo, btBroadphaseRayCallback rayCallback, Vector3 aabbMin, Vector3 aabbMax) {CollisionJNI.btMultiSapBroadphase_rayTest__SWIG_0(swigCPtr, this, rayFrom, rayTo, btBroadphaseRayCallback.getCPtr(rayCallback), rayCallback, aabbMin, aabbMax);}
public void rayTest(Vector3 rayFrom, Vector3 rayTo, btBroadphaseRayCallback rayCallback, Vector3 aabbMin) {CollisionJNI.btMultiSapBroadphase_rayTest__SWIG_1(swigCPtr, this, rayFrom, rayTo, btBroadphaseRayCallback.getCPtr(rayCallback), rayCallback, aabbMin);}
public void rayTest(Vector3 rayFrom, Vector3 rayTo, btBroadphaseRayCallback rayCallback) {CollisionJNI.btMultiSapBroadphase_rayTest__SWIG_2(swigCPtr, this, rayFrom, rayTo, btBroadphaseRayCallback.getCPtr(rayCallback), rayCallback);}
public void addToChildBroadphase(btMultiSapBroadphase.btMultiSapProxy parentMultiSapProxy, btBroadphaseProxy childProxy, btBroadphaseInterface childBroadphase) {CollisionJNI.btMultiSapBroadphase_addToChildBroadphase(swigCPtr, this, btMultiSapBroadphase.btMultiSapProxy.getCPtr(parentMultiSapProxy), parentMultiSapProxy, btBroadphaseProxy.getCPtr(childProxy), childProxy, btBroadphaseInterface.getCPtr(childBroadphase), childBroadphase);}
public boolean testAabbOverlap(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1) {return CollisionJNI.btMultiSapBroadphase_testAabbOverlap(swigCPtr, this, btBroadphaseProxy.getCPtr(proxy0), proxy0, btBroadphaseProxy.getCPtr(proxy1), proxy1);}
public btOverlappingPairCache getOverlappingPairCache() {long cPtr = CollisionJNI.btMultiSapBroadphase_getOverlappingPairCache__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : new btOverlappingPairCache(cPtr, false);}
public void buildTree(Vector3 bvhAabbMin, Vector3 bvhAabbMax) {CollisionJNI.btMultiSapBroadphase_buildTree(swigCPtr, this, bvhAabbMin, bvhAabbMax);}
public void quicksort(btBroadphasePairArray a, int lo, int hi) {CollisionJNI.btMultiSapBroadphase_quicksort(swigCPtr, this, btBroadphasePairArray.getCPtr(a), a, lo, hi);}public static LongBuffer allocate(int capacity) {if (capacity < 0) {throw new IllegalArgumentException();}return BufferFactory.newLongBuffer(capacity);}
public static LongBuffer wrap(long[] array) {return wrap(array, 0, array.length);}
public static LongBuffer wrap(long[] array, int start, int len) {if (array == null) {throw new NullPointerException();}if (start < 0 || len < 0 || (long) len + (long) start > array.length) {throw new IndexOutOfBoundsException();}LongBuffer buf = BufferFactory.newLongBuffer(array);buf.position = start;buf.limit = start + len;return buf;}
public final long[] array() {return protectedArray();}
public final int arrayOffset() {return protectedArrayOffset();}
public int compareTo(LongBuffer otherBuffer) {int compareRemaining = (remaining() < otherBuffer.remaining()) ? remaining() : otherBuffer.remaining();int thisPos = position;int otherPos = otherBuffer.position;// BEGIN android-changedlong thisLong, otherLong;while (compareRemaining > 0) {thisLong = get(thisPos);otherLong = otherBuffer.get(otherPos);if (thisLong != otherLong) {return thisLong < otherLong ? -1 : 1;}thisPos++;otherPos++;compareRemaining--;}// END android-changedreturn remaining() - otherBuffer.remaining();}
public boolean equals(Object other) {if (!(other instanceof LongBuffer)) {return false;}LongBuffer otherBuffer = (LongBuffer) other;if (remaining() != otherBuffer.remaining()) {return false;}int myPosition = position;int otherPosition = otherBuffer.position;boolean equalSoFar = true;while (equalSoFar && (myPosition < limit)) {equalSoFar = get(myPosition++) == otherBuffer.get(otherPosition++);}return equalSoFar;}
public LongBuffer get(long[] dest) {return get(dest, 0, dest.length);}
public LongBuffer get(long[] dest, int off, int len) {int length = dest.length;if (off < 0 || len < 0 || (long) len + (long) off > length) {throw new IndexOutOfBoundsException();}if (len > remaining()) {throw new BufferUnderflowException();}for (int i = off; i < off + len; i++) {dest[i] = get();}return this;}
public final boolean hasArray() {return protectedHasArray();}
public int hashCode() {int myPosition = position;int hash = 0;long l;while (myPosition < limit) {l = get(myPosition++);hash = hash + ((int) l) ^ ((int) (l >> 32));}return hash;}
public final LongBuffer put(long[] src) {return put(src, 0, src.length);}
public LongBuffer put(long[] src, int off, int len) {int length = src.length;if (off < 0 || len < 0 || (long) len + (long) off > length) {throw new IndexOutOfBoundsException();}if (len > remaining()) {throw new BufferOverflowException();}for (int i = off; i < off + len; i++) {put(src[i]);}return this;}
public LongBuffer put(LongBuffer src) {if (src == this) {throw new IllegalArgumentException();}if (src.remaining() > remaining()) {throw new BufferOverflowException();}long[] contents = new long[src.remaining()];src.get(contents);put(contents);return this;}
public String toString() {StringBuffer buf = new StringBuffer();buf.append(getClass().getName());//$NON-NLS-1$buf.append(", status: capacity=");buf.append(capacity());//$NON-NLS-1$buf.append(" position=");buf.append(position());//$NON-NLS-1$buf.append(" limit=");buf.append(limit());return buf.toString();}public void setSmoothing(float smoothing) {float delta = 0.5f * MathUtils.clamp(smoothing, 0, 1);setUniformf("u_lower", 0.5f - delta);setUniformf("u_upper", 0.5f + delta);}
public void create() {camera = new OrthographicCamera();spriteBatch = new SpriteBatch();descriptionFont = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), true);descriptionFont.setColor(Color.RED);regularTexture = new Texture(Gdx.files.internal("data/verdana39.png"), true);regularFont = new BitmapFont(Gdx.files.internal("data/verdana39.fnt"), new TextureRegion(regularTexture), true);regularFont.setColor(COLOR);distanceFieldTexture = new Texture(Gdx.files.internal("data/verdana39distancefield.png"), true);distanceFieldFont = new BitmapFont(Gdx.files.internal("data/verdana39distancefield.fnt"), new TextureRegion(distanceFieldTexture), true);distanceFieldFont.setColor(COLOR);distanceFieldShader = new DistanceFieldShader();// Useful when debugging this testShaderProgram.pedantic = false;}
public void render() {Gdx.gl.glClearColor(1, 1, 1, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);spriteBatch.begin();int x = 10;x += drawFont(regularFont, "Regular font\nNearest filter", false, false, 0, x);x += drawFont(regularFont, "Regular font\nLinear filter", true, false, 0, x);x += drawFont(regularFont, "Regular font\nCustom shader", true, true, 1.0f, x);x += drawFont(distanceFieldFont, "Distance field\nCustom shader", true, true, 1 / 8f, x);x += drawFont(distanceFieldFont, "Distance field\nShowing distance field", false, false, 0, x);spriteBatch.end();}
private int drawFont(BitmapFont font, String description, boolean linearFiltering, boolean useShader, float smoothing, int x) {int y = 10;float maxWidth = 0;spriteBatch.setShader(null);descriptionFont.draw(spriteBatch, description, x, y);spriteBatch.flush();y += 10 + 2 * descriptionFont.getLineHeight();// set filters for each pageTextureFilter minFilter = linearFiltering ? TextureFilter.MipMapLinearNearest : TextureFilter.Nearest;TextureFilter magFilter = linearFiltering ? TextureFilter.Linear : TextureFilter.Nearest;for (int i = 0; i < font.getRegions().size; i++) {font.getRegion(i).getTexture().setFilter(minFilter, magFilter);}if (useShader) {spriteBatch.setShader(distanceFieldShader);} else {spriteBatch.setShader(null);}for (float scale : SCALES) {font.getData().setScale(scale);layout.setText(font, TEXT);maxWidth = Math.max(maxWidth, layout.width);if (useShader) {distanceFieldShader.setSmoothing(smoothing / scale);}font.draw(spriteBatch, layout, x, y);y += font.getLineHeight();spriteBatch.flush();}return (int) Math.ceil(maxWidth);}
private float getBaselineShift(float shift) {return shift;}
public void resize(int width, int height) {super.resize(width, height);camera.setToOrtho(true, width, height);spriteBatch.setTransformMatrix(camera.view);spriteBatch.setProjectionMatrix(camera.projection);}
public void dispose() {spriteBatch.dispose();regularTexture.dispose();distanceFieldTexture.dispose();descriptionFont.dispose();regularFont.dispose();distanceFieldFont.dispose();distanceFieldShader.dispose();}private int createBufferObject() {int result = Gdx.gl20.glGenBuffer();Gdx.gl20.glBindBuffer(GL20.GL_ARRAY_BUFFER, result);Gdx.gl20.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.capacity(), null, usage);Gdx.gl20.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);return result;}
public VertexAttributes getAttributes() {return attributes;}
public int getNumVertices() {return buffer.limit() * 4 / attributes.vertexSize;}
public int getNumMaxVertices() {return byteBuffer.capacity() / attributes.vertexSize;}
public FloatBuffer getBuffer() {isDirty = true;return buffer;}
private void bufferChanged() {if (isBound) {Gdx.gl20.glBufferSubData(GL20.GL_ARRAY_BUFFER, 0, byteBuffer.limit(), byteBuffer);isDirty = false;}}
public void setVertices(float[] vertices, int offset, int count) {isDirty = true;if (isDirect) {BufferUtils.copy(vertices, byteBuffer, count, offset);buffer.position(0);buffer.limit(count);} else {buffer.clear();buffer.put(vertices, offset, count);buffer.flip();byteBuffer.position(0);byteBuffer.limit(buffer.limit() << 2);}bufferChanged();}
public void updateVertices(int targetOffset, float[] vertices, int sourceOffset, int count) {isDirty = true;if (isDirect) {final int pos = byteBuffer.position();byteBuffer.position(targetOffset * 4);BufferUtils.copy(vertices, sourceOffset, count, byteBuffer);byteBuffer.position(pos);} else// Should never happenthrow new GdxRuntimeException("Buffer must be allocated direct.");bufferChanged();}
public void bind(final ShaderProgram shader) {bind(shader, null);}
public void bind(final ShaderProgram shader, final int[] locations) {final GL20 gl = Gdx.gl20;gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);if (isDirty) {byteBuffer.limit(buffer.limit() * 4);gl.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);isDirty = false;}final int numAttributes = attributes.size();if (locations == null) {for (int i = 0; i < numAttributes; i++) {final VertexAttribute attribute = attributes.get(i);final int location = shader.getAttributeLocation(attribute.alias);if (location < 0)continue;shader.enableVertexAttribute(location);shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize, attribute.offset);}} else {for (int i = 0; i < numAttributes; i++) {final VertexAttribute attribute = attributes.get(i);final int location = locations[i];if (location < 0)continue;shader.enableVertexAttribute(location);shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize, attribute.offset);}}isBound = true;}
public void unbind(final ShaderProgram shader) {unbind(shader, null);}
public void unbind(final ShaderProgram shader, final int[] locations) {final GL20 gl = Gdx.gl20;final int numAttributes = attributes.size();if (locations == null) {for (int i = 0; i < numAttributes; i++) {shader.disableVertexAttribute(attributes.get(i).alias);}} else {for (int i = 0; i < numAttributes; i++) {final int location = locations[i];if (location >= 0)shader.disableVertexAttribute(location);}}gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);isBound = false;}
public void invalidate() {bufferHandle = createBufferObject();isDirty = true;}
public void dispose() {GL20 gl = Gdx.gl20;gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);gl.glDeleteBuffer(bufferHandle);bufferHandle = 0;}
public int getBufferHandle() {return bufferHandle;}public void create() {super.create();final Texture texture = new Texture(Gdx.files.internal("data/badlogic.jpg"));disposables.add(texture);final Material material = new Material(TextureAttribute.createDiffuse(texture), ColorAttribute.createSpecular(1, 1, 1, 1), FloatAttribute.createShininess(8f));final long attributes = Usage.Position | Usage.Normal | Usage.TextureCoordinates;final Model sphere = modelBuilder.createSphere(4f, 4f, 4f, 24, 24, material, attributes);disposables.add(sphere);world.addConstructor("sphere", new BulletConstructor(sphere, 10f, new btSphereShape(2f)));final Model cylinder = modelBuilder.createCylinder(4f, 6f, 4f, 16, material, attributes);disposables.add(cylinder);world.addConstructor("cylinder", new BulletConstructor(cylinder, 10f, new btCylinderShape(tmpV1.set(2f, 3f, 2f))));final Model capsule = modelBuilder.createCapsule(2f, 6f, 16, material, attributes);disposables.add(capsule);world.addConstructor("capsule", new BulletConstructor(capsule, 10f, new btCapsuleShape(2f, 2f)));final Model box = modelBuilder.createBox(4f, 4f, 2f, material, attributes);disposables.add(box);world.addConstructor("box2", new BulletConstructor(box, 10f, new btBoxShape(tmpV1.set(2f, 2f, 1f))));final Model cone = modelBuilder.createCone(4f, 6f, 4f, 16, material, attributes);disposables.add(cone);world.addConstructor("cone", new BulletConstructor(cone, 10f, new btConeShape(2f, 6f)));// Create the entitiesworld.add("ground", 0f, 0f, 0f).setColor(0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 1f);world.add("sphere", 0, 5, 5);world.add("cylinder", 5, 5, 0);world.add("box2", 0, 5, 0);world.add("capsule", 5, 5, 5);world.add("cone", 10, 5, 0);}
public boolean tap(float x, float y, int count, int button) {shoot(x, y);return true;}public void layout() {if (drawable == null)return;float regionWidth = drawable.getMinWidth();float regionHeight = drawable.getMinHeight();float width = getWidth();float height = getHeight();Vector2 size = scaling.apply(regionWidth, regionHeight, width, height);imageWidth = size.x;imageHeight = size.y;if ((align & Align.left) != 0)imageX = 0;else if ((align & Align.right) != 0)imageX = (int) (width - imageWidth);elseimageX = (int) (width / 2 - imageWidth / 2);if ((align & Align.top) != 0)imageY = (int) (height - imageHeight);else if ((align & Align.bottom) != 0)imageY = 0;elseimageY = (int) (height / 2 - imageHeight / 2);}
public void draw(Batch batch, float parentAlpha) {validate();Color color = getColor();batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);float x = getX();float y = getY();float scaleX = getScaleX();float scaleY = getScaleY();if (drawable instanceof TransformDrawable) {float rotation = getRotation();if (scaleX != 1 || scaleY != 1 || rotation != 0) {((TransformDrawable) drawable).draw(batch, x + imageX, y + imageY, getOriginX() - imageX, getOriginY() - imageY, imageWidth, imageHeight, scaleX, scaleY, rotation);return;}}if (drawable != null)drawable.draw(batch, x + imageX, y + imageY, imageWidth * scaleX, imageHeight * scaleY);}
public void setDrawable(Skin skin, String drawableName) {setDrawable(skin.getDrawable(drawableName));}
public void setDrawable(Drawable drawable) {if (this.drawable == drawable)return;if (drawable != null) {if (getPrefWidth() != drawable.getMinWidth() || getPrefHeight() != drawable.getMinHeight())invalidateHierarchy();} elseinvalidateHierarchy();this.drawable = drawable;}
public Drawable getDrawable() {return drawable;}
public void setScaling(Scaling scaling) {if (scaling == null)throw new IllegalArgumentException("scaling cannot be null.");this.scaling = scaling;}
public void setAlign(int align) {this.align = align;}
public float getMinWidth() {return 0;}
public float getMinHeight() {return 0;}
public float getPrefWidth() {if (drawable != null)return drawable.getMinWidth();return 0;}
public float getPrefHeight() {if (drawable != null)return drawable.getMinHeight();return 0;}
public float getImageX() {return imageX;}
public float getImageY() {return imageY;}
public float getImageWidth() {return imageWidth;}
public float getImageHeight() {return imageHeight;}private static final float clamp(final float v) {return v < 0f ? 0f : (v > 1f ? 1f : v);}
public AmbientCubemap set(final float values[]) {for (int i = 0; i < data.length; i++) data[i] = values[i];return this;}
public AmbientCubemap set(final AmbientCubemap other) {return set(other.data);}
public AmbientCubemap set(final Color color) {return set(color.r, color.g, color.b);}
public AmbientCubemap set(float r, float g, float b) {for (int idx = 0; idx < data.length; ) {data[idx++] = r;data[idx++] = g;data[idx++] = b;}return this;}
public Color getColor(final Color out, int side) {side *= 3;return out.set(data[side], data[side + 1], data[side + 2], 1f);}
public AmbientCubemap clear() {for (int i = 0; i < data.length; i++) data[i] = 0f;return this;}
public AmbientCubemap clamp() {for (int i = 0; i < data.length; i++) data[i] = clamp(data[i]);return this;}
public AmbientCubemap add(float r, float g, float b) {for (int idx = 0; idx < data.length; ) {data[idx++] += r;data[idx++] += g;data[idx++] += b;}return this;}
public AmbientCubemap add(final Color color) {return add(color.r, color.g, color.b);}
public AmbientCubemap add(final float r, final float g, final float b, final float x, final float y, final float z) {final float x2 = x * x, y2 = y * y, z2 = z * z;float d = x2 + y2 + z2;if (d == 0f)return this;d = 1f / d * (d + 1f);final float rd = r * d, gd = g * d, bd = b * d;int idx = x > 0 ? 0 : 3;data[idx] += x2 * rd;data[idx + 1] += x2 * gd;data[idx + 2] += x2 * bd;idx = y > 0 ? 6 : 9;data[idx] += y2 * rd;data[idx + 1] += y2 * gd;data[idx + 2] += y2 * bd;idx = z > 0 ? 12 : 15;data[idx] += z2 * rd;data[idx + 1] += z2 * gd;data[idx + 2] += z2 * bd;return this;}
public AmbientCubemap add(final Color color, final Vector3 direction) {return add(color.r, color.g, color.b, direction.x, direction.y, direction.z);}
public AmbientCubemap add(final float r, final float g, final float b, final Vector3 direction) {return add(r, g, b, direction.x, direction.y, direction.z);}
public AmbientCubemap add(final Color color, final float x, final float y, final float z) {return add(color.r, color.g, color.b, x, y, z);}
public AmbientCubemap add(final Color color, final Vector3 point, final Vector3 target) {return add(color.r, color.g, color.b, target.x - point.x, target.y - point.y, target.z - point.z);}
public AmbientCubemap add(final Color color, final Vector3 point, final Vector3 target, final float intensity) {final float t = intensity / (1f + target.dst(point));return add(color.r * t, color.g * t, color.b * t, target.x - point.x, target.y - point.y, target.z - point.z);}
public String toString() {String result = "";for (int i = 0; i < data.length; i += 3) {result += Float.toString(data[i]) + ", " + Float.toString(data[i + 1]) + ", " + Float.toString(data[i + 2]) + "\n";}return result;}public static boolean test(Object data) {if (!(data instanceof byte[]))return false;byte[] b = (byte[]) data;for (int i = 0; i < b.length; ++i) {if (((int) b[i] & 0x080) != 0)return true;}return false;}
public static byte[] encode(char[] s16, int offset, int length) {ByteArrayOutputStream buf = new ByteArrayOutputStream();for (int i = offset; i < offset + length; ++i) {char c = s16[i];if (c == ' ') {// null charbuf.write(0);buf.write(0);} else if (c < 0x080) {// 1 byte charbuf.write(c);} else if (c < 0x0800) {// 2 byte charbuf.write(0x0c0 | (c >>> 6));buf.write(0x080 | (c & 0x03f));} else {// 3 byte charbuf.write(0x0e0 | ((c >>> 12) & 0x0f));buf.write(0x080 | ((c >>> 6) & 0x03f));buf.write(0x080 | (c & 0x03f));}}return buf.toByteArray();}
public static Object decode(byte[] s8, int offset, int length) {Object buf = new byte[length];boolean isMultiByte = false;int i = offset, j = 0;while (i < offset + length) {int x = s8[i++];if ((x & 0x080) == 0x0) {// 2 byte null charif (x == 0)++i;cram(buf, j++, x);} else if ((x & 0x0e0) == 0x0c0) {// 2 byte charif (!isMultiByte) {buf = widen(buf, j, length - 1);isMultiByte = true;}int y = s8[i++];cram(buf, j++, ((x & 0x1f) << 6) | (y & 0x3f));} else if ((x & 0x0f0) == 0x0e0) {// 3 byte charif (!isMultiByte) {buf = widen(buf, j, length - 2);isMultiByte = true;}int y = s8[i++];int z = s8[i++];cram(buf, j++, ((x & 0xf) << 12) | ((y & 0x3f) << 6) | (z & 0x3f));}}return trim(buf, j);}
public static char[] decode16(byte[] s8, int offset, int length) {Object decoded = decode(s8, offset, length);if (decoded instanceof char[])return (char[]) decoded;return (char[]) widen(decoded, length, length);}
private static void cram(Object data, int index, int val) {if (data instanceof byte[])((byte[]) data)[index] = (byte) val;else((char[]) data)[index] = (char) val;}
private static Object widen(Object data, int length, int capacity) {byte[] src = (byte[]) data;char[] result = new char[capacity];for (int i = 0; i < length; ++i) result[i] = (char) ((int) src[i] & 0x0ff);return result;}
private static Object trim(Object data, int length) {if (data instanceof byte[])return data;if (((char[]) data).length == length)return data;char[] result = new char[length];System.arraycopy(data, 0, result, 0, length);return result;}public Vector2 apply(float sourceWidth, float sourceHeight, float targetWidth, float targetHeight) {switch(this) {case fit:{float targetRatio = targetHeight / targetWidth;float sourceRatio = sourceHeight / sourceWidth;float scale = targetRatio > sourceRatio ? targetWidth / sourceWidth : targetHeight / sourceHeight;temp.x = sourceWidth * scale;temp.y = sourceHeight * scale;break;}case fill:{float targetRatio = targetHeight / targetWidth;float sourceRatio = sourceHeight / sourceWidth;float scale = targetRatio < sourceRatio ? targetWidth / sourceWidth : targetHeight / sourceHeight;temp.x = sourceWidth * scale;temp.y = sourceHeight * scale;break;}case fillX:{float scale = targetWidth / sourceWidth;temp.x = sourceWidth * scale;temp.y = sourceHeight * scale;break;}case fillY:{float scale = targetHeight / sourceHeight;temp.x = sourceWidth * scale;temp.y = sourceHeight * scale;break;}case stretch:temp.x = targetWidth;temp.y = targetHeight;break;case stretchX:temp.x = targetWidth;temp.y = sourceHeight;break;case stretchY:temp.x = sourceWidth;temp.y = targetHeight;break;case none:temp.x = sourceWidth;temp.y = sourceHeight;break;}return temp;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btConvexPolyhedron obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btConvexPolyhedron(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setVertices(btVector3Array value) {CollisionJNI.btConvexPolyhedron_vertices_set(swigCPtr, this, btVector3Array.getCPtr(value), value);}
public btVector3Array getVertices() {long cPtr = CollisionJNI.btConvexPolyhedron_vertices_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3Array(cPtr, false);}
public void setFaces(SWIGTYPE_p_btAlignedObjectArrayT_btFace_t value) {CollisionJNI.btConvexPolyhedron_faces_set(swigCPtr, this, SWIGTYPE_p_btAlignedObjectArrayT_btFace_t.getCPtr(value));}
public SWIGTYPE_p_btAlignedObjectArrayT_btFace_t getFaces() {long cPtr = CollisionJNI.btConvexPolyhedron_faces_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_btAlignedObjectArrayT_btFace_t(cPtr, false);}
public void setUniqueEdges(btVector3Array value) {CollisionJNI.btConvexPolyhedron_uniqueEdges_set(swigCPtr, this, btVector3Array.getCPtr(value), value);}
public btVector3Array getUniqueEdges() {long cPtr = CollisionJNI.btConvexPolyhedron_uniqueEdges_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3Array(cPtr, false);}
public void setLocalCenter(btVector3 value) {CollisionJNI.btConvexPolyhedron_localCenter_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getLocalCenter() {long cPtr = CollisionJNI.btConvexPolyhedron_localCenter_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setExtents(btVector3 value) {CollisionJNI.btConvexPolyhedron_extents_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getExtents() {long cPtr = CollisionJNI.btConvexPolyhedron_extents_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setRadius(float value) {CollisionJNI.btConvexPolyhedron_radius_set(swigCPtr, this, value);}
public float getRadius() {return CollisionJNI.btConvexPolyhedron_radius_get(swigCPtr, this);}
public void setMC(btVector3 value) {CollisionJNI.btConvexPolyhedron_mC_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getMC() {long cPtr = CollisionJNI.btConvexPolyhedron_mC_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setME(btVector3 value) {CollisionJNI.btConvexPolyhedron_mE_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getME() {long cPtr = CollisionJNI.btConvexPolyhedron_mE_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void initialize() {CollisionJNI.btConvexPolyhedron_initialize(swigCPtr, this);}
public boolean testContainment() {return CollisionJNI.btConvexPolyhedron_testContainment(swigCPtr, this);}
public void project(Matrix4 trans, Vector3 dir, SWIGTYPE_p_float minProj, SWIGTYPE_p_float maxProj, Vector3 witnesPtMin, Vector3 witnesPtMax) {CollisionJNI.btConvexPolyhedron_project(swigCPtr, this, trans, dir, SWIGTYPE_p_float.getCPtr(minProj), SWIGTYPE_p_float.getCPtr(maxProj), witnesPtMin, witnesPtMax);}public void create() {super.create();instructions = "Tap a box to ray cast\nLong press to toggle debug mode\nSwipe for next test\nCtrl+drag to rotate\nScroll to zoom";// Create the entitiesworld.add("ground", -7f, 0f, -7f).setColor(0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 1f);for (int x = 0; x < BOXCOUNT_X; x++) {for (int y = 0; y < BOXCOUNT_Y; y++) {for (int z = 0; z < BOXCOUNT_Z; z++) {world.add("box", BOXOFFSET_X + x, BOXOFFSET_Y + y, BOXOFFSET_Z + z).setColor(0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 1f);}}}rayTestCB = new ClosestRayResultCallback(Vector3.Zero, Vector3.Z);}
public void dispose() {if (rayTestCB != null)rayTestCB.dispose();rayTestCB = null;super.dispose();}
public boolean tap(float x, float y, int count, int button) {Ray ray = camera.getPickRay(x, y);rayFrom.set(ray.origin);// 50 meters max from the originrayTo.set(ray.direction).scl(50f).add(rayFrom);// Because we reuse the ClosestRayResultCallback, we need reset it's valuesrayTestCB.setCollisionObject(null);rayTestCB.setClosestHitFraction(1f);rayTestCB.setRayFromWorld(rayFrom);rayTestCB.setRayToWorld(rayTo);world.collisionWorld.rayTest(rayFrom, rayTo, rayTestCB);if (rayTestCB.hasHit()) {final btCollisionObject obj = rayTestCB.getCollisionObject();if (!obj.isStaticOrKinematicObject()) {final btRigidBody body = (btRigidBody) (obj);body.activate();body.applyCentralImpulse(tmpV2.set(ray.direction).scl(20f));}}return true;}public void render() {if ((loading > 0) && (++loading > 2))loadnext();tests[testIndex].render();fpsLabel.setText(tests[testIndex].performance);hud.draw();}
public void create() {if (app == null) {app = Gdx.app;tests[testIndex].create();}cameraController = new CameraInputController(tests[testIndex].camera);cameraController.activateKey = Keys.CONTROL_LEFT;cameraController.autoUpdate = false;cameraController.forwardTarget = false;cameraController.translateTarget = false;Gdx.input.setInputProcessor(new InputMultiplexer(cameraController, this, new GestureDetector(this)));font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);hud = new Stage();hud.addActor(fpsLabel = new Label(" ", new Label.LabelStyle(font, Color.WHITE)));fpsLabel.setPosition(0, 0);hud.addActor(titleLabel = new Label(tests[testIndex].getClass().getSimpleName(), new Label.LabelStyle(font, Color.WHITE)));titleLabel.setY(hud.getHeight() - titleLabel.getHeight());hud.addActor(instructLabel = new Label("A\nB\nC\nD\nE\nF", new Label.LabelStyle(font, Color.WHITE)));instructLabel.setY(titleLabel.getY() - instructLabel.getHeight());instructLabel.setAlignment(Align.top | Align.left);instructLabel.setText(tests[testIndex].instructions);}
public void resize(int width, int height) {hud.getViewport().update(width, height, true);}
public void dispose() {tests[testIndex].dispose();app = null;}
public void next() {titleLabel.setText("Loading...");loading = 1;}
public void loadnext() {app.log("TestCollection", "disposing test '" + tests[testIndex].getClass().getName() + "'");tests[testIndex].dispose();// This would be a good time for GC to kick in.System.gc();testIndex++;if (testIndex >= tests.length)testIndex = 0;tests[testIndex].create();cameraController.camera = tests[testIndex].camera;app.log("TestCollection", "created test '" + tests[testIndex].getClass().getName() + "'");titleLabel.setText(tests[testIndex].getClass().getSimpleName());instructLabel.setText(tests[testIndex].instructions);loading = 0;}
public boolean keyDown(int keycode) {return tests[testIndex].keyDown(keycode);}
public boolean keyTyped(char character) {return tests[testIndex].keyTyped(character);}
public boolean keyUp(int keycode) {boolean result = tests[testIndex].keyUp(keycode);if ((result == false) && (keycode == Keys.SPACE || keycode == Keys.MENU)) {next();result = true;}return result;}
public boolean touchDown(int x, int y, int pointer, int button) {return tests[testIndex].touchDown(x, y, pointer, button);}
public boolean touchDragged(int x, int y, int pointer) {return tests[testIndex].touchDragged(x, y, pointer);}
public boolean touchUp(int x, int y, int pointer, int button) {return tests[testIndex].touchUp(x, y, pointer, button);}
public boolean mouseMoved(int x, int y) {return tests[testIndex].mouseMoved(x, y);}
public boolean scrolled(int amount) {return tests[testIndex].scrolled(amount);}
public boolean touchDown(float x, float y, int pointer, int button) {return tests[testIndex].touchDown(x, y, pointer, button);}
public boolean tap(float x, float y, int count, int button) {return tests[testIndex].tap(x, y, count, button);}
public boolean longPress(float x, float y) {return tests[testIndex].longPress(x, y);}
public boolean fling(float velocityX, float velocityY, int button) {if (tests[testIndex].fling(velocityX, velocityY, button) == false)next();return true;}
public boolean pan(float x, float y, float deltaX, float deltaY) {return tests[testIndex].pan(x, y, deltaX, deltaY);}
public boolean panStop(float x, float y, int pointer, int button) {return tests[testIndex].panStop(x, y, pointer, button);}
public boolean zoom(float originalDistance, float currentDistance) {return tests[testIndex].zoom(originalDistance, currentDistance);}
public boolean pinch(Vector2 initialFirstPointer, Vector2 initialSecondPointer, Vector2 firstPointer, Vector2 secondPointer) {return tests[testIndex].pinch(initialFirstPointer, initialSecondPointer, firstPointer, secondPointer);}public void create() {Vector2 trn = new Vector2(30, 50);float rot = 35;float cos = (float) Math.cos(MathUtils.degreesToRadians * rot);float sin = (float) Math.sin(MathUtils.degreesToRadians * rot);Vector2 scl = new Vector2(0.42f, 1.19f);Vector2 shear = new Vector2(0.35f, 0.71f);Matrix3 mat1 = new Matrix3();Matrix3 mat2 = new Matrix3();Affine2 afn1 = new Affine2();Affine2 afn2 = new Affine2();// check setter - identitycheckEqual(mat1, new float[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 });checkEqual(mat1, mat2.idt());checkEqual(mat1, afn1);checkEqual(mat1, afn1.idt());// check setter - translationmat1.setToTranslation(trn);checkEqual(mat1, new float[] { 1, 0, 0, 0, 1, 0, trn.x, trn.y, 1 });afn1.setToTranslation(trn);checkEqual(mat1, afn1);// check setter - scalemat1.setToScaling(scl);checkEqual(mat1, new float[] { scl.x, 0, 0, 0, scl.y, 0, 0, 0, 1 });afn1.setToScaling(scl);checkEqual(mat1, afn1);// check setter - rotationmat1.setToRotation(rot);checkEqual(mat1, new float[] { cos, sin, 0, -sin, cos, 0, 0, 0, 1 });afn1.setToRotation(rot);checkEqual(mat1, afn1);mat1.setToRotationRad(MathUtils.degreesToRadians * rot);checkEqual(mat1, afn1);afn1.setToRotationRad(MathUtils.degreesToRadians * rot);checkEqual(mat1, afn1);// check setter - shearingafn1.setToShearing(shear);checkEqual(mat1.set(afn1), new float[] { 1, shear.y, 0, shear.x, 1, 0, 0, 0, 1 });// check setter - translation x rotation x scaleafn1.setToTrnRotScl(trn, rot, scl);afn2.setToTrnRotRadScl(trn, MathUtils.degreesToRadians * rot, scl);checkEqual(afn1, afn2);afn2.setToTranslation(trn).rotate(rot).scale(scl);checkEqual(afn1, afn2);// check setter - translation x scaleafn1.setToTrnRotScl(trn, 0, scl);afn2.setToTrnScl(trn, scl);checkEqual(afn1, afn2);// check post-multiplicationmat1.idt().scale(scl).rotate(rot).translate(trn).mul(mat2.set(afn2.setToShearing(shear)));afn1.idt().scale(scl).rotate(rot).translate(trn).shear(shear);checkEqual(mat1, afn1);afn1.idt().mul(afn2.setToScaling(scl)).mul(afn2.setToRotation(rot)).mul(afn2.setToTranslation(trn)).mul(afn2.setToShearing(shear));checkEqual(mat1, afn1);// check pre-multiplicationafn1.idt().preShear(shear).preTranslate(trn).preRotate(rot).preScale(scl);checkEqual(mat1, afn1);afn1.idt().preMul(afn2.setToShearing(shear)).preMul(afn2.setToTranslation(trn)).preMul(afn2.setToRotation(rot)).preMul(afn2.setToScaling(scl));checkEqual(mat1, afn1);mat1.set(afn2.setToShearing(shear)).trn(trn).mulLeft(mat2.setToRotation(rot)).mulLeft(mat2.setToScaling(scl));checkEqual(mat1, afn1);// check determinant and inversecheckEqual(mat1.det(), afn1.det());check(afn1.det() == (afn1.m00 * afn1.m11 - afn1.m01 * afn1.m10));mat1.inv();afn2.set(afn1).inv();checkEqual(mat1, afn2);checkEqual(afn1.det(), 1 / afn2.det());// check for exception when trying to invert singular matricesboolean didThrow = false;afn1.setToShearing(1, 1);try {afn1.inv();} catch (GdxRuntimeException e) {didThrow = true;}check(didThrow);System.out.println("All tests passed.");}
private static void check(boolean condition) {if (!condition)throw new GdxRuntimeException("");}
private static void check(boolean condition, String msg) {if (!condition)throw new GdxRuntimeException(msg);}
private static void checkEqual(Matrix3 matrix, Affine2 affine) {checkEqual(matrix, new Matrix3().set(affine));}
private static void checkEqual(Affine2 a, Affine2 b) {checkEqual(new Matrix3().set(a), new Matrix3().set(b));}
private static void checkEqual(Matrix3 a, Matrix3 b) {for (int i = 0; i < 9; i++) check(MathUtils.isEqual(a.val[i], b.val[i], TOLERANCE), "matrices are not equal");}
private static void checkEqual(Matrix3 matrix, float[] vals) {for (int i = 0; i < 9; i++) check(MathUtils.isEqual(matrix.val[i], vals[i], TOLERANCE), "matrices are not equal");}
private static void checkEqual(float a, float b) {check(MathUtils.isEqual(a, b, TOLERANCE));}public void add(float value) {float[] items = this.items;if (size == items.length)items = resize(Math.max(8, (int) (size * 1.75f)));items[size++] = value;}
public void addAll(FloatArray array) {addAll(array, 0, array.size);}
public void addAll(FloatArray array, int offset, int length) {if (offset + length > array.size)throw new IllegalArgumentException("offset + length must be <= size: " + offset + " + " + length + " <= " + array.size);addAll(array.items, offset, length);}
public void addAll(float... array) {addAll(array, 0, array.length);}
public void addAll(float[] array, int offset, int length) {float[] items = this.items;int sizeNeeded = size + length;if (sizeNeeded > items.length)items = resize(Math.max(8, (int) (sizeNeeded * 1.75f)));System.arraycopy(array, offset, items, size, length);size += length;}
public float get(int index) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);return items[index];}
public void set(int index, float value) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);items[index] = value;}
public void incr(int index, float value) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);items[index] += value;}
public void mul(int index, float value) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);items[index] *= value;}
public void insert(int index, float value) {if (index > size)throw new IndexOutOfBoundsException("index can't be > size: " + index + " > " + size);float[] items = this.items;if (size == items.length)items = resize(Math.max(8, (int) (size * 1.75f)));if (ordered)System.arraycopy(items, index, items, index + 1, size - index);elseitems[size] = items[index];size++;items[index] = value;}
public void swap(int first, int second) {if (first >= size)throw new IndexOutOfBoundsException("first can't be >= size: " + first + " >= " + size);if (second >= size)throw new IndexOutOfBoundsException("second can't be >= size: " + second + " >= " + size);float[] items = this.items;float firstValue = items[first];items[first] = items[second];items[second] = firstValue;}
public boolean contains(float value) {int i = size - 1;float[] items = this.items;while (i >= 0) if (items[i--] == value)return true;return false;}
public int indexOf(float value) {float[] items = this.items;for (int i = 0, n = size; i < n; i++) if (items[i] == value)return i;return -1;}
public int lastIndexOf(char value) {float[] items = this.items;for (int i = size - 1; i >= 0; i--) if (items[i] == value)return i;return -1;}
public boolean removeValue(float value) {float[] items = this.items;for (int i = 0, n = size; i < n; i++) {if (items[i] == value) {removeIndex(i);return true;}}return false;}
public float removeIndex(int index) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);float[] items = this.items;float value = items[index];size--;if (ordered)System.arraycopy(items, index + 1, items, index, size - index);elseitems[index] = items[size];return value;}
public void removeRange(int start, int end) {if (end >= size)throw new IndexOutOfBoundsException("end can't be >= size: " + end + " >= " + size);if (start > end)throw new IndexOutOfBoundsException("start can't be > end: " + start + " > " + end);float[] items = this.items;int count = end - start + 1;if (ordered)System.arraycopy(items, start + count, items, start, size - (start + count));else {int lastIndex = this.size - 1;for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];}size -= count;}
public boolean removeAll(FloatArray array) {int size = this.size;int startSize = size;float[] items = this.items;for (int i = 0, n = array.size; i < n; i++) {float item = array.get(i);for (int ii = 0; ii < size; ii++) {if (item == items[ii]) {removeIndex(ii);size--;break;}}}return size != startSize;}
public float pop() {return items[--size];}
public float peek() {return items[size - 1];}
public float first() {if (size == 0)throw new IllegalStateException("Array is empty.");return items[0];}
public void clear() {size = 0;}
public float[] shrink() {if (items.length != size)resize(size);return items;}
public float[] ensureCapacity(int additionalCapacity) {int sizeNeeded = size + additionalCapacity;if (sizeNeeded > items.length)resize(Math.max(8, sizeNeeded));return items;}
protected float[] resize(int newSize) {float[] newItems = new float[newSize];float[] items = this.items;System.arraycopy(items, 0, newItems, 0, Math.min(size, newItems.length));this.items = newItems;return newItems;}
public void sort() {Arrays.sort(items, 0, size);}
public void reverse() {float[] items = this.items;for (int i = 0, lastIndex = size - 1, n = size / 2; i < n; i++) {int ii = lastIndex - i;float temp = items[i];items[i] = items[ii];items[ii] = temp;}}
public void shuffle() {float[] items = this.items;for (int i = size - 1; i >= 0; i--) {int ii = MathUtils.random(i);float temp = items[i];items[i] = items[ii];items[ii] = temp;}}
public void truncate(int newSize) {if (size > newSize)size = newSize;}
public float random() {if (size == 0)return 0;return items[MathUtils.random(0, size - 1)];}
public float[] toArray() {float[] array = new float[size];System.arraycopy(items, 0, array, 0, size);return array;}
public int hashCode() {if (!ordered)return super.hashCode();float[] items = this.items;int h = 1;for (int i = 0, n = size; i < n; i++) h = h * 31 + Float.floatToIntBits(items[i]);return h;}
public boolean equals(Object object) {if (object == this)return true;if (!ordered)return false;if (!(object instanceof FloatArray))return false;FloatArray array = (FloatArray) object;if (!array.ordered)return false;int n = size;if (n != array.size)return false;float[] items1 = this.items;float[] items2 = array.items;for (int i = 0; i < n; i++) if (items1[i] != items2[i])return false;return true;}
public boolean equals(Object object, float epsilon) {if (object == this)return true;if (!(object instanceof FloatArray))return false;FloatArray array = (FloatArray) object;int n = size;if (n != array.size)return false;if (!ordered)return false;if (!array.ordered)return false;float[] items1 = this.items;float[] items2 = array.items;for (int i = 0; i < n; i++) if (Math.abs(items1[i] - items2[i]) > epsilon)return false;return true;}
public String toString() {if (size == 0)return "[]";float[] items = this.items;StringBuilder buffer = new StringBuilder(32);buffer.append('[');buffer.append(items[0]);for (int i = 1; i < size; i++) {buffer.append(", ");buffer.append(items[i]);}buffer.append(']');return buffer.toString();}
public String toString(String separator) {if (size == 0)return "";float[] items = this.items;StringBuilder buffer = new StringBuilder(32);buffer.append(items[0]);for (int i = 1; i < size; i++) {buffer.append(separator);buffer.append(items[i]);}return buffer.toString();}
public static FloatArray with(float... array) {return new FloatArray(array);}protected void createWorld(World world) {{EdgeShape shape = new EdgeShape();shape.set(new Vector2(-40.0f, 0), new Vector2(40, 0));FixtureDef fd = new FixtureDef();fd.shape = shape;fd.friction = 0.3f;BodyDef bd = new BodyDef();Body ground = world.createBody(bd);ground.createFixture(fd);shape.dispose();}Vector2[] vertices = new Vector2[3];vertices[0] = new Vector2(-1, 0);vertices[1] = new Vector2(1, 0);vertices[2] = new Vector2(0, 2);PolygonShape polygon = new PolygonShape();polygon.set(vertices);FixtureDef triangleShapeDef = new FixtureDef();triangleShapeDef.shape = polygon;triangleShapeDef.density = 1.0f;triangleShapeDef.filter.groupIndex = k_smallGroup;triangleShapeDef.filter.categoryBits = k_triangleCategory;triangleShapeDef.filter.maskBits = k_triangleMask;BodyDef triangleBodyDef = new BodyDef();triangleBodyDef.type = BodyType.DynamicBody;triangleBodyDef.position.set(-5, 2);Body body1 = world.createBody(triangleBodyDef);body1.createFixture(triangleShapeDef);vertices[0].scl(2);vertices[1].scl(2);vertices[2].scl(2);polygon.set(vertices);triangleShapeDef.filter.groupIndex = k_largeGroup;triangleBodyDef.position.set(-5, 6);triangleBodyDef.fixedRotation = true;Body body2 = world.createBody(triangleBodyDef);body2.createFixture(triangleShapeDef);{BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(-5, 10);Body body = world.createBody(bd);PolygonShape p = new PolygonShape();p.setAsBox(0.5f, 1.0f);body.createFixture(p, 1);PrismaticJointDef jd = new PrismaticJointDef();jd.bodyA = body2;jd.bodyB = body;jd.enableLimit = true;jd.localAnchorA.set(0, 4);jd.localAnchorB.set(0, 0);jd.localAxisA.set(0, 1);jd.lowerTranslation = -1;jd.upperTranslation = 1;world.createJoint(jd);p.dispose();}polygon.setAsBox(1, 0.5f);FixtureDef boxShapeDef = new FixtureDef();boxShapeDef.shape = polygon;boxShapeDef.density = 1;boxShapeDef.restitution = 0.1f;boxShapeDef.filter.groupIndex = k_smallGroup;boxShapeDef.filter.categoryBits = k_boxCategory;boxShapeDef.filter.maskBits = k_boxMask;BodyDef boxBodyDef = new BodyDef();boxBodyDef.type = BodyType.DynamicBody;boxBodyDef.position.set(0, 2);Body body3 = world.createBody(boxBodyDef);body3.createFixture(boxShapeDef);polygon.setAsBox(2, 1);boxShapeDef.filter.groupIndex = k_largeGroup;boxBodyDef.position.set(0, 6);Body body4 = world.createBody(boxBodyDef);body4.createFixture(boxShapeDef);CircleShape circle = new CircleShape();circle.setRadius(1);FixtureDef circleShapeDef = new FixtureDef();circleShapeDef.shape = circle;circleShapeDef.density = 1.0f;circleShapeDef.filter.groupIndex = k_smallGroup;circleShapeDef.filter.categoryBits = k_circleCategory;circleShapeDef.filter.maskBits = k_circleMask;BodyDef circleBodyDef = new BodyDef();circleBodyDef.type = BodyType.DynamicBody;circleBodyDef.position.set(5, 2);Body body5 = world.createBody(circleBodyDef);body5.createFixture(circleShapeDef);circle.setRadius(2);circleShapeDef.filter.groupIndex = k_largeGroup;circleBodyDef.position.set(5, 6);Body body6 = world.createBody(circleBodyDef);body6.createFixture(circleShapeDef);}public void add(byte value) {byte[] items = this.items;if (size == items.length)items = resize(Math.max(8, (int) (size * 1.75f)));items[size++] = value;}
public void addAll(ByteArray array) {addAll(array, 0, array.size);}
public void addAll(ByteArray array, int offset, int length) {if (offset + length > array.size)throw new IllegalArgumentException("offset + length must be <= size: " + offset + " + " + length + " <= " + array.size);addAll(array.items, offset, length);}
public void addAll(byte... array) {addAll(array, 0, array.length);}
public void addAll(byte[] array, int offset, int length) {byte[] items = this.items;int sizeNeeded = size + length;if (sizeNeeded > items.length)items = resize(Math.max(8, (int) (sizeNeeded * 1.75f)));System.arraycopy(array, offset, items, size, length);size += length;}
public byte get(int index) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);return items[index];}
public void set(int index, byte value) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);items[index] = value;}
public void incr(int index, byte value) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);items[index] += value;}
public void mul(int index, byte value) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);items[index] *= value;}
public void insert(int index, byte value) {if (index > size)throw new IndexOutOfBoundsException("index can't be > size: " + index + " > " + size);byte[] items = this.items;if (size == items.length)items = resize(Math.max(8, (int) (size * 1.75f)));if (ordered)System.arraycopy(items, index, items, index + 1, size - index);elseitems[size] = items[index];size++;items[index] = value;}
public void swap(int first, int second) {if (first >= size)throw new IndexOutOfBoundsException("first can't be >= size: " + first + " >= " + size);if (second >= size)throw new IndexOutOfBoundsException("second can't be >= size: " + second + " >= " + size);byte[] items = this.items;byte firstValue = items[first];items[first] = items[second];items[second] = firstValue;}
public boolean contains(byte value) {int i = size - 1;byte[] items = this.items;while (i >= 0) if (items[i--] == value)return true;return false;}
public int indexOf(byte value) {byte[] items = this.items;for (int i = 0, n = size; i < n; i++) if (items[i] == value)return i;return -1;}
public int lastIndexOf(byte value) {byte[] items = this.items;for (int i = size - 1; i >= 0; i--) if (items[i] == value)return i;return -1;}
public boolean removeValue(byte value) {byte[] items = this.items;for (int i = 0, n = size; i < n; i++) {if (items[i] == value) {removeIndex(i);return true;}}return false;}
public int removeIndex(int index) {if (index >= size)throw new IndexOutOfBoundsException("index can't be >= size: " + index + " >= " + size);byte[] items = this.items;int value = items[index];size--;if (ordered)System.arraycopy(items, index + 1, items, index, size - index);elseitems[index] = items[size];return value;}
public void removeRange(int start, int end) {if (end >= size)throw new IndexOutOfBoundsException("end can't be >= size: " + end + " >= " + size);if (start > end)throw new IndexOutOfBoundsException("start can't be > end: " + start + " > " + end);byte[] items = this.items;int count = end - start + 1;if (ordered)System.arraycopy(items, start + count, items, start, size - (start + count));else {int lastIndex = this.size - 1;for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];}size -= count;}
public boolean removeAll(ByteArray array) {int size = this.size;int startSize = size;byte[] items = this.items;for (int i = 0, n = array.size; i < n; i++) {int item = array.get(i);for (int ii = 0; ii < size; ii++) {if (item == items[ii]) {removeIndex(ii);size--;break;}}}return size != startSize;}
public byte pop() {return items[--size];}
public byte peek() {return items[size - 1];}
public byte first() {if (size == 0)throw new IllegalStateException("Array is empty.");return items[0];}
public void clear() {size = 0;}
public byte[] shrink() {if (items.length != size)resize(size);return items;}
public byte[] ensureCapacity(int additionalCapacity) {int sizeNeeded = size + additionalCapacity;if (sizeNeeded > items.length)resize(Math.max(8, sizeNeeded));return items;}
protected byte[] resize(int newSize) {byte[] newItems = new byte[newSize];byte[] items = this.items;System.arraycopy(items, 0, newItems, 0, Math.min(size, newItems.length));this.items = newItems;return newItems;}
public void sort() {Arrays.sort(items, 0, size);}
public void reverse() {byte[] items = this.items;for (int i = 0, lastIndex = size - 1, n = size / 2; i < n; i++) {int ii = lastIndex - i;byte temp = items[i];items[i] = items[ii];items[ii] = temp;}}
public void shuffle() {byte[] items = this.items;for (int i = size - 1; i >= 0; i--) {int ii = MathUtils.random(i);byte temp = items[i];items[i] = items[ii];items[ii] = temp;}}
public void truncate(int newSize) {if (size > newSize)size = newSize;}
public byte random() {if (size == 0)return 0;return items[MathUtils.random(0, size - 1)];}
public byte[] toArray() {byte[] array = new byte[size];System.arraycopy(items, 0, array, 0, size);return array;}
public int hashCode() {if (!ordered)return super.hashCode();byte[] items = this.items;int h = 1;for (int i = 0, n = size; i < n; i++) h = h * 31 + items[i];return h;}
public boolean equals(Object object) {if (object == this)return true;if (!ordered)return false;if (!(object instanceof ByteArray))return false;ByteArray array = (ByteArray) object;if (!array.ordered)return false;int n = size;if (n != array.size)return false;byte[] items1 = this.items;byte[] items2 = array.items;for (int i = 0; i < n; i++) if (items1[i] != items2[i])return false;return true;}
public String toString() {if (size == 0)return "[]";byte[] items = this.items;StringBuilder buffer = new StringBuilder(32);buffer.append('[');buffer.append(items[0]);for (int i = 1; i < size; i++) {buffer.append(", ");buffer.append(items[i]);}buffer.append(']');return buffer.toString();}
public String toString(String separator) {if (size == 0)return "";byte[] items = this.items;StringBuilder buffer = new StringBuilder(32);buffer.append(items[0]);for (int i = 1; i < size; i++) {buffer.append(separator);buffer.append(items[i]);}return buffer.toString();}
public static ByteArray with(byte... array) {return new ByteArray(array);}public void draw(Batch batch, float parentAlpha) {if (drawTitleTable)super.draw(batch, parentAlpha);}
public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {toFront();return false;}
public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {if (button == 0) {int border = resizeBorder;float width = getWidth(), height = getHeight();edge = 0;if (isResizable && x >= 0 && x < width && y >= 0 && y < height) {if (x < border)edge |= Align.left;if (x > width - border)edge |= Align.right;if (y < border)edge |= Align.bottom;if (y > height - border)edge |= Align.top;if (edge != 0)border += 25;if (x < border)edge |= Align.left;if (x > width - border)edge |= Align.right;if (y < border)edge |= Align.bottom;if (y > height - border)edge |= Align.top;}if (isMovable && edge == 0 && y <= height && y >= height - getPadTop() && x >= 0 && x <= width)edge = MOVE;dragging = edge != 0;startX = x;startY = y;lastX = x;lastY = y;}return edge != 0 || isModal;}
public void touchUp(InputEvent event, float x, float y, int pointer, int button) {dragging = false;}
public void touchDragged(InputEvent event, float x, float y, int pointer) {if (!dragging)return;float width = getWidth(), height = getHeight();float windowX = getX(), windowY = getY();float minWidth = getMinWidth(), maxWidth = getMaxWidth();float minHeight = getMinHeight(), maxHeight = getMaxHeight();Stage stage = getStage();boolean clampPosition = keepWithinStage && getParent() == stage.getRoot();if ((edge & MOVE) != 0) {float amountX = x - startX, amountY = y - startY;windowX += amountX;windowY += amountY;}if ((edge & Align.left) != 0) {float amountX = x - startX;if (width - amountX < minWidth)amountX = -(minWidth - width);if (clampPosition && windowX + amountX < 0)amountX = -windowX;width -= amountX;windowX += amountX;}if ((edge & Align.bottom) != 0) {float amountY = y - startY;if (height - amountY < minHeight)amountY = -(minHeight - height);if (clampPosition && windowY + amountY < 0)amountY = -windowY;height -= amountY;windowY += amountY;}if ((edge & Align.right) != 0) {float amountX = x - lastX;if (width + amountX < minWidth)amountX = minWidth - width;if (clampPosition && windowX + width + amountX > stage.getWidth())amountX = stage.getWidth() - windowX - width;width += amountX;}if ((edge & Align.top) != 0) {float amountY = y - lastY;if (height + amountY < minHeight)amountY = minHeight - height;if (clampPosition && windowY + height + amountY > stage.getHeight())amountY = stage.getHeight() - windowY - height;height += amountY;}lastX = x;lastY = y;setBounds(Math.round(windowX), Math.round(windowY), Math.round(width), Math.round(height));}
public boolean mouseMoved(InputEvent event, float x, float y) {return isModal;}
public boolean scrolled(InputEvent event, float x, float y, int amount) {return isModal;}
public boolean keyDown(InputEvent event, int keycode) {return isModal;}
public boolean keyUp(InputEvent event, int keycode) {return isModal;}
public boolean keyTyped(InputEvent event, char character) {return isModal;}
public void setStyle(WindowStyle style) {if (style == null)throw new IllegalArgumentException("style cannot be null.");this.style = style;setBackground(style.background);titleLabel.setStyle(new LabelStyle(style.titleFont, style.titleFontColor));invalidateHierarchy();}
public WindowStyle getStyle() {return style;}
void keepWithinStage() {if (!keepWithinStage)return;Stage stage = getStage();Camera camera = stage.getCamera();if (camera instanceof OrthographicCamera) {OrthographicCamera orthographicCamera = (OrthographicCamera) camera;float parentWidth = stage.getWidth();float parentHeight = stage.getHeight();if (getX(Align.right) - camera.position.x > parentWidth / 2 / orthographicCamera.zoom)setPosition(camera.position.x + parentWidth / 2 / orthographicCamera.zoom, getY(Align.right), Align.right);if (getX(Align.left) - camera.position.x < -parentWidth / 2 / orthographicCamera.zoom)setPosition(camera.position.x - parentWidth / 2 / orthographicCamera.zoom, getY(Align.left), Align.left);if (getY(Align.top) - camera.position.y > parentHeight / 2 / orthographicCamera.zoom)setPosition(getX(Align.top), camera.position.y + parentHeight / 2 / orthographicCamera.zoom, Align.top);if (getY(Align.bottom) - camera.position.y < -parentHeight / 2 / orthographicCamera.zoom)setPosition(getX(Align.bottom), camera.position.y - parentHeight / 2 / orthographicCamera.zoom, Align.bottom);} else if (getParent() == stage.getRoot()) {float parentWidth = stage.getWidth();float parentHeight = stage.getHeight();if (getX() < 0)setX(0);if (getRight() > parentWidth)setX(parentWidth - getWidth());if (getY() < 0)setY(0);if (getTop() > parentHeight)setY(parentHeight - getHeight());}}
public void draw(Batch batch, float parentAlpha) {Stage stage = getStage();if (stage.getKeyboardFocus() == null)stage.setKeyboardFocus(this);keepWithinStage();if (style.stageBackground != null) {stageToLocalCoordinates(tmpPosition.set(0, 0));stageToLocalCoordinates(tmpSize.set(stage.getWidth(), stage.getHeight()));drawStageBackground(batch, parentAlpha, getX() + tmpPosition.x, getY() + tmpPosition.y, getX() + tmpSize.x, getY() + tmpSize.y);}super.draw(batch, parentAlpha);}
protected void drawStageBackground(Batch batch, float parentAlpha, float x, float y, float width, float height) {Color color = getColor();batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);style.stageBackground.draw(batch, x, y, width, height);}
protected void drawBackground(Batch batch, float parentAlpha, float x, float y) {super.drawBackground(batch, parentAlpha, x, y);// Manually draw the title table before clipping is done.titleTable.getColor().a = getColor().a;float padTop = getPadTop(), padLeft = getPadLeft();titleTable.setSize(getWidth() - padLeft - getPadRight(), padTop);titleTable.setPosition(padLeft, getHeight() - padTop);drawTitleTable = true;titleTable.draw(batch, parentAlpha);// Avoid drawing the title table again in drawChildren.drawTitleTable = false;}
public Actor hit(float x, float y, boolean touchable) {Actor hit = super.hit(x, y, touchable);if (hit == null && isModal && (!touchable || getTouchable() == Touchable.enabled))return this;float height = getHeight();if (hit == null || hit == this)return hit;if (y <= height && y >= height - getPadTop() && x >= 0 && x <= getWidth()) {// Hit the title bar, don't use the hit child if it is in the Window's table.Actor current = hit;while (current.getParent() != this) current = current.getParent();if (getCell(current) != null)return this;}return hit;}
public boolean isMovable() {return isMovable;}
public void setMovable(boolean isMovable) {this.isMovable = isMovable;}
public boolean isModal() {return isModal;}
public void setModal(boolean isModal) {this.isModal = isModal;}
public void setKeepWithinStage(boolean keepWithinStage) {this.keepWithinStage = keepWithinStage;}
public boolean isResizable() {return isResizable;}
public void setResizable(boolean isResizable) {this.isResizable = isResizable;}
public void setResizeBorder(int resizeBorder) {this.resizeBorder = resizeBorder;}
public boolean isDragging() {return dragging;}
public float getPrefWidth() {return Math.max(super.getPrefWidth(), titleLabel.getPrefWidth() + getPadLeft() + getPadRight());}
public Table getTitleTable() {return titleTable;}
public Label getTitleLabel() {return titleLabel;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btSolverBody obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btSolverBody(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setWorldTransform(btTransform value) {DynamicsJNI.btSolverBody_worldTransform_set(swigCPtr, this, btTransform.getCPtr(value), value);}
public btTransform getWorldTransform() {long cPtr = DynamicsJNI.btSolverBody_worldTransform_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransform(cPtr, false);}
public void setDeltaLinearVelocity(btVector3 value) {DynamicsJNI.btSolverBody_deltaLinearVelocity_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getDeltaLinearVelocity() {long cPtr = DynamicsJNI.btSolverBody_deltaLinearVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setDeltaAngularVelocity(btVector3 value) {DynamicsJNI.btSolverBody_deltaAngularVelocity_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getDeltaAngularVelocity() {long cPtr = DynamicsJNI.btSolverBody_deltaAngularVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setAngularFactor(btVector3 value) {DynamicsJNI.btSolverBody_angularFactor_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getAngularFactor() {long cPtr = DynamicsJNI.btSolverBody_angularFactor_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setLinearFactor(btVector3 value) {DynamicsJNI.btSolverBody_linearFactor_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getLinearFactor() {long cPtr = DynamicsJNI.btSolverBody_linearFactor_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setInvMass(btVector3 value) {DynamicsJNI.btSolverBody_invMass_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getInvMass() {long cPtr = DynamicsJNI.btSolverBody_invMass_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setPushVelocity(btVector3 value) {DynamicsJNI.btSolverBody_pushVelocity_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getPushVelocity() {long cPtr = DynamicsJNI.btSolverBody_pushVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setTurnVelocity(btVector3 value) {DynamicsJNI.btSolverBody_turnVelocity_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getTurnVelocity() {long cPtr = DynamicsJNI.btSolverBody_turnVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setLinearVelocity(btVector3 value) {DynamicsJNI.btSolverBody_linearVelocity_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getLinearVelocity() {long cPtr = DynamicsJNI.btSolverBody_linearVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setAngularVelocity(btVector3 value) {DynamicsJNI.btSolverBody_angularVelocity_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getAngularVelocity() {long cPtr = DynamicsJNI.btSolverBody_angularVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setExternalForceImpulse(btVector3 value) {DynamicsJNI.btSolverBody_externalForceImpulse_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getExternalForceImpulse() {long cPtr = DynamicsJNI.btSolverBody_externalForceImpulse_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setExternalTorqueImpulse(btVector3 value) {DynamicsJNI.btSolverBody_externalTorqueImpulse_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getExternalTorqueImpulse() {long cPtr = DynamicsJNI.btSolverBody_externalTorqueImpulse_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setOriginalBody(btRigidBody value) {DynamicsJNI.btSolverBody_originalBody_set(swigCPtr, this, btRigidBody.getCPtr(value), value);}
public btRigidBody getOriginalBody() {return btRigidBody.getInstance(DynamicsJNI.btSolverBody_originalBody_get(swigCPtr, this), false);}
public void getVelocityInLocalPointNoDelta(Vector3 rel_pos, Vector3 velocity) {DynamicsJNI.btSolverBody_getVelocityInLocalPointNoDelta(swigCPtr, this, rel_pos, velocity);}
public void getVelocityInLocalPointObsolete(Vector3 rel_pos, Vector3 velocity) {DynamicsJNI.btSolverBody_getVelocityInLocalPointObsolete(swigCPtr, this, rel_pos, velocity);}
public void getAngularVelocity(Vector3 angVel) {DynamicsJNI.btSolverBody_getAngularVelocity(swigCPtr, this, angVel);}
public void applyImpulse(Vector3 linearComponent, Vector3 angularComponent, float impulseMagnitude) {DynamicsJNI.btSolverBody_applyImpulse(swigCPtr, this, linearComponent, angularComponent, impulseMagnitude);}
public void internalApplyPushImpulse(Vector3 linearComponent, Vector3 angularComponent, float impulseMagnitude) {DynamicsJNI.btSolverBody_internalApplyPushImpulse(swigCPtr, this, linearComponent, angularComponent, impulseMagnitude);}
public Vector3 internalGetDeltaLinearVelocity() {return DynamicsJNI.btSolverBody_internalGetDeltaLinearVelocity(swigCPtr, this);}
public Vector3 internalGetDeltaAngularVelocity() {return DynamicsJNI.btSolverBody_internalGetDeltaAngularVelocity(swigCPtr, this);}
public Vector3 internalGetAngularFactor() {return DynamicsJNI.btSolverBody_internalGetAngularFactor(swigCPtr, this);}
public Vector3 internalGetInvMass() {return DynamicsJNI.btSolverBody_internalGetInvMass(swigCPtr, this);}
public void internalSetInvMass(Vector3 invMass) {DynamicsJNI.btSolverBody_internalSetInvMass(swigCPtr, this, invMass);}
public Vector3 internalGetPushVelocity() {return DynamicsJNI.btSolverBody_internalGetPushVelocity(swigCPtr, this);}
public Vector3 internalGetTurnVelocity() {return DynamicsJNI.btSolverBody_internalGetTurnVelocity(swigCPtr, this);}
public void internalGetVelocityInLocalPointObsolete(Vector3 rel_pos, Vector3 velocity) {DynamicsJNI.btSolverBody_internalGetVelocityInLocalPointObsolete(swigCPtr, this, rel_pos, velocity);}
public void internalGetAngularVelocity(Vector3 angVel) {DynamicsJNI.btSolverBody_internalGetAngularVelocity(swigCPtr, this, angVel);}
public void internalApplyImpulse(Vector3 linearComponent, Vector3 angularComponent, float impulseMagnitude) {DynamicsJNI.btSolverBody_internalApplyImpulse(swigCPtr, this, linearComponent, angularComponent, impulseMagnitude);}
public void writebackVelocity() {DynamicsJNI.btSolverBody_writebackVelocity(swigCPtr, this);}
public void writebackVelocityAndTransform(float timeStep, float splitImpulseTurnErp) {DynamicsJNI.btSolverBody_writebackVelocityAndTransform(swigCPtr, this, timeStep, splitImpulseTurnErp);}public boolean needsGL20() {// just because the non pot, we could change the image instead...return true;}
public void dispose() {batch.dispose();stage.dispose();skin.dispose();font.dispose();if (texture != null)texture.dispose();}
public void create() {batch = new SpriteBatch();skin = new Skin(Gdx.files.internal("data/uiskin.json"));font = new BitmapFont();stage = new Stage();Gdx.input.setInputProcessor(stage);{statusLabel = new Label("", skin);statusLabel.setWrap(true);statusLabel.setWidth(Gdx.graphics.getWidth() * 0.96f);statusLabel.setAlignment(Align.center);statusLabel.setPosition(Gdx.graphics.getWidth() * 0.5f - statusLabel.getWidth() * 0.5f, 30f);statusLabel.setColor(Color.CYAN);stage.addActor(statusLabel);}{ClickListener clickListener = new ClickListener() {
@Overridepublic void clicked(InputEvent event, float x, float y) {super.clicked(event, x, y);clickedButton = event.getListenerActor();setButtonDisabled(true);if (texture != null)texture.dispose();texture = null;text = null;String url;String httpMethod = Net.HttpMethods.GET;String requestContent = null;if (clickedButton == btnDownloadImage)url = "http://i.imgur.com/vxomF.jpg";else if (clickedButton == btnDownloadText)url = "http://www.apache.org/licenses/LICENSE-2.0.txt";else if (clickedButton == btnDownloadLarge)url = "http://libgdx.badlogicgames.com/releases/libgdx-1.2.0.zip";else if (clickedButton == btnDownloadError)url = "http://www.badlogicgames.com/doesnotexist";else if (clickedButton == btnOpenUri) {Gdx.net.openURI("http://libgdx.badlogicgames.com/");return;} else {url = "http://posttestserver.com/post.php?dump";httpMethod = Net.HttpMethods.POST;requestContent = "name1=value1&name2=value2";}httpRequest = new HttpRequest(httpMethod);httpRequest.setUrl(url);httpRequest.setContent(requestContent);Gdx.net.sendHttpRequest(httpRequest, NetAPITest.this);statusLabel.setText("Downloading data from " + httpRequest.getUrl());}};ClickListener cancelListener = new ClickListener() {
@Overridepublic void clicked(InputEvent event, float x, float y) {super.clicked(event, x, y);if (httpRequest != null) {Gdx.net.cancelHttpRequest(httpRequest);Gdx.app.log("NetAPITest", "Cancelling request " + httpRequest.getUrl());statusLabel.setText("Cancelling request " + httpRequest.getUrl());}}};btnCancel = new TextButton("Cancel", skin);btnCancel.setPosition(Gdx.graphics.getWidth() * 0.10f, 60f);btnCancel.addListener(cancelListener);stage.addActor(btnCancel);btnDownloadImage = new TextButton("GET Image", skin);btnDownloadImage.setPosition(btnCancel.getX() + btnCancel.getWidth() + 10, 60f);btnDownloadImage.addListener(clickListener);stage.addActor(btnDownloadImage);btnDownloadText = new TextButton("GET Text", skin);btnDownloadText.setPosition(btnDownloadImage.getX() + btnDownloadImage.getWidth() + 10, 60f);btnDownloadText.addListener(clickListener);stage.addActor(btnDownloadText);btnDownloadLarge = new TextButton("GET Large", skin);btnDownloadLarge.setPosition(btnDownloadText.getX() + btnDownloadText.getWidth() + 10, 60f);btnDownloadLarge.addListener(clickListener);stage.addActor(btnDownloadLarge);btnDownloadError = new TextButton("GET Error", skin);btnDownloadError.setPosition(btnDownloadLarge.getX() + btnDownloadLarge.getWidth() + 10, 60f);btnDownloadError.addListener(clickListener);stage.addActor(btnDownloadError);btnPost = new TextButton("POST", skin);btnPost.setPosition(btnDownloadError.getX() + btnDownloadError.getWidth() + 10, 60f);btnPost.addListener(clickListener);stage.addActor(btnPost);btnOpenUri = new TextButton("Open URI", skin);btnOpenUri.setPosition(btnPost.getX() + btnPost.getWidth() + 10, 60f);btnOpenUri.addListener(clickListener);stage.addActor(btnOpenUri);}}
public void clicked(InputEvent event, float x, float y) {super.clicked(event, x, y);clickedButton = event.getListenerActor();setButtonDisabled(true);if (texture != null)texture.dispose();texture = null;text = null;String url;String httpMethod = Net.HttpMethods.GET;String requestContent = null;if (clickedButton == btnDownloadImage)url = "http://i.imgur.com/vxomF.jpg";else if (clickedButton == btnDownloadText)url = "http://www.apache.org/licenses/LICENSE-2.0.txt";else if (clickedButton == btnDownloadLarge)url = "http://libgdx.badlogicgames.com/releases/libgdx-1.2.0.zip";else if (clickedButton == btnDownloadError)url = "http://www.badlogicgames.com/doesnotexist";else if (clickedButton == btnOpenUri) {Gdx.net.openURI("http://libgdx.badlogicgames.com/");return;} else {url = "http://posttestserver.com/post.php?dump";httpMethod = Net.HttpMethods.POST;requestContent = "name1=value1&name2=value2";}httpRequest = new HttpRequest(httpMethod);httpRequest.setUrl(url);httpRequest.setContent(requestContent);Gdx.net.sendHttpRequest(httpRequest, NetAPITest.this);statusLabel.setText("Downloading data from " + httpRequest.getUrl());}
public void clicked(InputEvent event, float x, float y) {super.clicked(event, x, y);if (httpRequest != null) {Gdx.net.cancelHttpRequest(httpRequest);Gdx.app.log("NetAPITest", "Cancelling request " + httpRequest.getUrl());statusLabel.setText("Cancelling request " + httpRequest.getUrl());}}
public void handleHttpResponse(HttpResponse httpResponse) {final int statusCode = httpResponse.getStatus().getStatusCode();// We are not in main thread right now so we need to post to main thread for ui updatesGdx.app.postRunnable(new Runnable() {
@Overridepublic void run() {statusLabel.setText("HTTP Request status: " + statusCode);setButtonDisabled(false);}});if (statusCode != 200) {Gdx.app.log("NetAPITest", "An error ocurred since statusCode is not OK");setText(httpResponse);return;}if (clickedButton == btnDownloadImage) {final byte[] rawImageBytes = httpResponse.getResult();Gdx.app.postRunnable(new Runnable() {
public void run() {Pixmap pixmap = new Pixmap(rawImageBytes, 0, rawImageBytes.length);texture = new Texture(pixmap);}});} else if (clickedButton == btnDownloadLarge) {Gdx.app.postRunnable(new Runnable() {
public void run() {text = "Retrieving large file...";}});final byte[] rawFileBytes = httpResponse.getResult();Gdx.app.postRunnable(new Runnable() {
public void run() {text = "Retrieved large file: " + rawFileBytes.length;}});} else {setText(httpResponse);}}
public void run() {statusLabel.setText("HTTP Request status: " + statusCode);setButtonDisabled(false);}
public void run() {Pixmap pixmap = new Pixmap(rawImageBytes, 0, rawImageBytes.length);texture = new Texture(pixmap);}
public void run() {text = "Retrieving large file...";}
public void run() {text = "Retrieved large file: " + rawFileBytes.length;}
void setText(HttpResponse httpResponse) {final String newText = httpResponse.getResultAsString();Gdx.app.postRunnable(new Runnable() {
public void run() {text = newText;}});}
public void run() {text = newText;}
void setButtonDisabled(boolean disabled) {Touchable t = disabled ? Touchable.disabled : Touchable.enabled;btnDownloadImage.setDisabled(disabled);btnDownloadImage.setTouchable(t);btnDownloadText.setDisabled(disabled);btnDownloadText.setTouchable(t);btnDownloadError.setDisabled(disabled);btnDownloadError.setTouchable(t);btnPost.setDisabled(disabled);btnPost.setTouchable(t);}
public void failed(Throwable t) {setButtonDisabled(false);statusLabel.setText("Failed to perform the HTTP Request: " + t.getMessage());t.printStackTrace();}
public void render() {Gdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);if (texture != null) {batch.begin();batch.draw(texture, Gdx.graphics.getWidth() * 0.5f - texture.getWidth() * 0.5f, 100f);batch.end();} else if (text != null) {batch.begin();font.draw(batch, text, 10, Gdx.graphics.getHeight() - 10);batch.end();}stage.act(Gdx.graphics.getDeltaTime());stage.draw();}
public void resize(int width, int height) {stage.getViewport().update(width, height, true);}
public void cancelled() {Gdx.app.postRunnable(new Runnable() {
public void run() {setButtonDisabled(false);Gdx.app.log("NetAPITest", "HTTP request cancelled");statusLabel.setText("HTTP request cancelled");}});}
public void run() {setButtonDisabled(false);Gdx.app.log("NetAPITest", "HTTP request cancelled");statusLabel.setText("HTTP request cancelled");}public void SetType(int numHashBytes) {HASH_ARRAY = (numHashBytes > 2);if (HASH_ARRAY) {kNumHashDirectBytes = 0;kMinMatchCheck = 4;kFixHashSize = kHash2Size + kHash3Size;} else {kNumHashDirectBytes = 2;kMinMatchCheck = 2 + 1;kFixHashSize = 0;}}
public void Init() {super.Init();for (int i = 0; i < _hashSizeSum; i++) _hash[i] = kEmptyHashValue;_cyclicBufferPos = 0;ReduceOffsets(-1);}
public void MovePos() {if (++_cyclicBufferPos >= _cyclicBufferSize)_cyclicBufferPos = 0;super.MovePos();if (_pos == kMaxValForNormalize)Normalize();}
public boolean Create(int historySize, int keepAddBufferBefore, int matchMaxLen, int keepAddBufferAfter) {if (historySize > kMaxValForNormalize - 256)return false;_cutValue = 16 + (matchMaxLen >> 1);int windowReservSize = (historySize + keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + 256;super.Create(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);_matchMaxLen = matchMaxLen;int cyclicBufferSize = historySize + 1;if (_cyclicBufferSize != cyclicBufferSize)_son = new int[(_cyclicBufferSize = cyclicBufferSize) * 2];int hs = kBT2HashSize;if (HASH_ARRAY) {hs = historySize - 1;hs |= (hs >> 1);hs |= (hs >> 2);hs |= (hs >> 4);hs |= (hs >> 8);hs >>= 1;hs |= 0xFFFF;if (hs > (1 << 24))hs >>= 1;_hashMask = hs;hs++;hs += kFixHashSize;}if (hs != _hashSizeSum)_hash = new int[_hashSizeSum = hs];return true;}
public int GetMatches(int[] distances) {int lenLimit;if (_pos + _matchMaxLen <= _streamPos)lenLimit = _matchMaxLen;else {lenLimit = _streamPos - _pos;if (lenLimit < kMinMatchCheck) {MovePos();return 0;}}int offset = 0;int matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;int cur = _bufferOffset + _pos;// to avoid items for len < hashSize;int maxLen = kStartMaxLen;int hashValue, hash2Value = 0, hash3Value = 0;if (HASH_ARRAY) {int temp = CrcTable[_bufferBase[cur] & 0xFF] ^ (_bufferBase[cur + 1] & 0xFF);hash2Value = temp & (kHash2Size - 1);temp ^= ((int) (_bufferBase[cur + 2] & 0xFF) << 8);hash3Value = temp & (kHash3Size - 1);hashValue = (temp ^ (CrcTable[_bufferBase[cur + 3] & 0xFF] << 5)) & _hashMask;} elsehashValue = ((_bufferBase[cur] & 0xFF) ^ ((int) (_bufferBase[cur + 1] & 0xFF) << 8));int curMatch = _hash[kFixHashSize + hashValue];if (HASH_ARRAY) {int curMatch2 = _hash[hash2Value];int curMatch3 = _hash[kHash3Offset + hash3Value];_hash[hash2Value] = _pos;_hash[kHash3Offset + hash3Value] = _pos;if (curMatch2 > matchMinPos)if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur]) {distances[offset++] = maxLen = 2;distances[offset++] = _pos - curMatch2 - 1;}if (curMatch3 > matchMinPos)if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur]) {if (curMatch3 == curMatch2)offset -= 2;distances[offset++] = maxLen = 3;distances[offset++] = _pos - curMatch3 - 1;curMatch2 = curMatch3;}if (offset != 0 && curMatch2 == curMatch) {offset -= 2;maxLen = kStartMaxLen;}}_hash[kFixHashSize + hashValue] = _pos;int ptr0 = (_cyclicBufferPos << 1) + 1;int ptr1 = (_cyclicBufferPos << 1);int len0, len1;len0 = len1 = kNumHashDirectBytes;if (kNumHashDirectBytes != 0) {if (curMatch > matchMinPos) {if (_bufferBase[_bufferOffset + curMatch + kNumHashDirectBytes] != _bufferBase[cur + kNumHashDirectBytes]) {distances[offset++] = maxLen = kNumHashDirectBytes;distances[offset++] = _pos - curMatch - 1;}}}int count = _cutValue;while (true) {if (curMatch <= matchMinPos || count-- == 0) {_son[ptr0] = _son[ptr1] = kEmptyHashValue;break;}int delta = _pos - curMatch;int cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;int pby1 = _bufferOffset + curMatch;int len = Math.min(len0, len1);if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {while (++len != lenLimit) if (_bufferBase[pby1 + len] != _bufferBase[cur + len])break;if (maxLen < len) {distances[offset++] = maxLen = len;distances[offset++] = delta - 1;if (len == lenLimit) {_son[ptr1] = _son[cyclicPos];_son[ptr0] = _son[cyclicPos + 1];break;}}}if ((_bufferBase[pby1 + len] & 0xFF) < (_bufferBase[cur + len] & 0xFF)) {_son[ptr1] = curMatch;ptr1 = cyclicPos + 1;curMatch = _son[ptr1];len1 = len;} else {_son[ptr0] = curMatch;ptr0 = cyclicPos;curMatch = _son[ptr0];len0 = len;}}MovePos();return offset;}
public void Skip(int num) {do {int lenLimit;if (_pos + _matchMaxLen <= _streamPos)lenLimit = _matchMaxLen;else {lenLimit = _streamPos - _pos;if (lenLimit < kMinMatchCheck) {MovePos();continue;}}int matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;int cur = _bufferOffset + _pos;int hashValue;if (HASH_ARRAY) {int temp = CrcTable[_bufferBase[cur] & 0xFF] ^ (_bufferBase[cur + 1] & 0xFF);int hash2Value = temp & (kHash2Size - 1);_hash[hash2Value] = _pos;temp ^= ((int) (_bufferBase[cur + 2] & 0xFF) << 8);int hash3Value = temp & (kHash3Size - 1);_hash[kHash3Offset + hash3Value] = _pos;hashValue = (temp ^ (CrcTable[_bufferBase[cur + 3] & 0xFF] << 5)) & _hashMask;} elsehashValue = ((_bufferBase[cur] & 0xFF) ^ ((int) (_bufferBase[cur + 1] & 0xFF) << 8));int curMatch = _hash[kFixHashSize + hashValue];_hash[kFixHashSize + hashValue] = _pos;int ptr0 = (_cyclicBufferPos << 1) + 1;int ptr1 = (_cyclicBufferPos << 1);int len0, len1;len0 = len1 = kNumHashDirectBytes;int count = _cutValue;while (true) {if (curMatch <= matchMinPos || count-- == 0) {_son[ptr0] = _son[ptr1] = kEmptyHashValue;break;}int delta = _pos - curMatch;int cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;int pby1 = _bufferOffset + curMatch;int len = Math.min(len0, len1);if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {while (++len != lenLimit) if (_bufferBase[pby1 + len] != _bufferBase[cur + len])break;if (len == lenLimit) {_son[ptr1] = _son[cyclicPos];_son[ptr0] = _son[cyclicPos + 1];break;}}if ((_bufferBase[pby1 + len] & 0xFF) < (_bufferBase[cur + len] & 0xFF)) {_son[ptr1] = curMatch;ptr1 = cyclicPos + 1;curMatch = _son[ptr1];len1 = len;} else {_son[ptr0] = curMatch;ptr0 = cyclicPos;curMatch = _son[ptr0];len0 = len;}}MovePos();} while (--num != 0);}
void NormalizeLinks(int[] items, int numItems, int subValue) {for (int i = 0; i < numItems; i++) {int value = items[i];if (value <= subValue)value = kEmptyHashValue;elsevalue -= subValue;items[i] = value;}}
void Normalize() {int subValue = _pos - _cyclicBufferSize;NormalizeLinks(_son, _cyclicBufferSize * 2, subValue);NormalizeLinks(_hash, _hashSizeSum, subValue);ReduceOffsets(subValue);}
public void SetCutValue(int cutValue) {_cutValue = cutValue;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(DynamicsJNI.btTypedConstraint_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btTypedConstraint obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btTypedConstraint(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btConstraintInfo1 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btTypedConstraint_btConstraintInfo1(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setNumConstraintRows(int value) {DynamicsJNI.btTypedConstraint_btConstraintInfo1_numConstraintRows_set(swigCPtr, this, value);}
public int getNumConstraintRows() {return DynamicsJNI.btTypedConstraint_btConstraintInfo1_numConstraintRows_get(swigCPtr, this);}
public void setNub(int value) {DynamicsJNI.btTypedConstraint_btConstraintInfo1_nub_set(swigCPtr, this, value);}
public int getNub() {return DynamicsJNI.btTypedConstraint_btConstraintInfo1_nub_get(swigCPtr, this);}
public static btRigidBody getFixedBody() {return btRigidBody.getInstance(DynamicsJNI.btTypedConstraint_getFixedBody(), false);}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btConstraintInfo2 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btTypedConstraint_btConstraintInfo2(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setFps(float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_fps_set(swigCPtr, this, value);}
public float getFps() {return DynamicsJNI.btTypedConstraint_btConstraintInfo2_fps_get(swigCPtr, this);}
public void setErp(float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_erp_set(swigCPtr, this, value);}
public float getErp() {return DynamicsJNI.btTypedConstraint_btConstraintInfo2_erp_get(swigCPtr, this);}
public void setJ1linearAxis(SWIGTYPE_p_float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_J1linearAxis_set(swigCPtr, this, SWIGTYPE_p_float.getCPtr(value));}
public SWIGTYPE_p_float getJ1linearAxis() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_J1linearAxis_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_float(cPtr, false);}
public void setJ1angularAxis(SWIGTYPE_p_float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_J1angularAxis_set(swigCPtr, this, SWIGTYPE_p_float.getCPtr(value));}
public SWIGTYPE_p_float getJ1angularAxis() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_J1angularAxis_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_float(cPtr, false);}
public void setJ2linearAxis(SWIGTYPE_p_float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_J2linearAxis_set(swigCPtr, this, SWIGTYPE_p_float.getCPtr(value));}
public SWIGTYPE_p_float getJ2linearAxis() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_J2linearAxis_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_float(cPtr, false);}
public void setJ2angularAxis(SWIGTYPE_p_float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_J2angularAxis_set(swigCPtr, this, SWIGTYPE_p_float.getCPtr(value));}
public SWIGTYPE_p_float getJ2angularAxis() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_J2angularAxis_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_float(cPtr, false);}
public void setRowskip(int value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_rowskip_set(swigCPtr, this, value);}
public int getRowskip() {return DynamicsJNI.btTypedConstraint_btConstraintInfo2_rowskip_get(swigCPtr, this);}
public void setConstraintError(SWIGTYPE_p_float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_constraintError_set(swigCPtr, this, SWIGTYPE_p_float.getCPtr(value));}
public SWIGTYPE_p_float getConstraintError() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_constraintError_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_float(cPtr, false);}
public void setCfm(SWIGTYPE_p_float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_cfm_set(swigCPtr, this, SWIGTYPE_p_float.getCPtr(value));}
public SWIGTYPE_p_float getCfm() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_cfm_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_float(cPtr, false);}
public void setLowerLimit(SWIGTYPE_p_float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_lowerLimit_set(swigCPtr, this, SWIGTYPE_p_float.getCPtr(value));}
public SWIGTYPE_p_float getLowerLimit() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_lowerLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_float(cPtr, false);}
public void setUpperLimit(SWIGTYPE_p_float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_upperLimit_set(swigCPtr, this, SWIGTYPE_p_float.getCPtr(value));}
public SWIGTYPE_p_float getUpperLimit() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_upperLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_float(cPtr, false);}
public void setFindex(SWIGTYPE_p_int value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_findex_set(swigCPtr, this, SWIGTYPE_p_int.getCPtr(value));}
public SWIGTYPE_p_int getFindex() {long cPtr = DynamicsJNI.btTypedConstraint_btConstraintInfo2_findex_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);}
public void setNumIterations(int value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_numIterations_set(swigCPtr, this, value);}
public int getNumIterations() {return DynamicsJNI.btTypedConstraint_btConstraintInfo2_numIterations_get(swigCPtr, this);}
public void setDamping(float value) {DynamicsJNI.btTypedConstraint_btConstraintInfo2_damping_set(swigCPtr, this, value);}
public float getDamping() {return DynamicsJNI.btTypedConstraint_btConstraintInfo2_damping_get(swigCPtr, this);}
public int getOverrideNumSolverIterations() {return DynamicsJNI.btTypedConstraint_getOverrideNumSolverIterations(swigCPtr, this);}
public void setOverrideNumSolverIterations(int overideNumIterations) {DynamicsJNI.btTypedConstraint_setOverrideNumSolverIterations(swigCPtr, this, overideNumIterations);}
public void buildJacobian() {DynamicsJNI.btTypedConstraint_buildJacobian(swigCPtr, this);}
public void setupSolverConstraint(SWIGTYPE_p_btAlignedObjectArrayT_btSolverConstraint_t ca, int solverBodyA, int solverBodyB, float timeStep) {DynamicsJNI.btTypedConstraint_setupSolverConstraint(swigCPtr, this, SWIGTYPE_p_btAlignedObjectArrayT_btSolverConstraint_t.getCPtr(ca), solverBodyA, solverBodyB, timeStep);}
public void getInfo1(btTypedConstraint.btConstraintInfo1 info) {DynamicsJNI.btTypedConstraint_getInfo1(swigCPtr, this, btTypedConstraint.btConstraintInfo1.getCPtr(info), info);}
public void getInfo2(btTypedConstraint.btConstraintInfo2 info) {DynamicsJNI.btTypedConstraint_getInfo2(swigCPtr, this, btTypedConstraint.btConstraintInfo2.getCPtr(info), info);}
public void internalSetAppliedImpulse(float appliedImpulse) {DynamicsJNI.btTypedConstraint_internalSetAppliedImpulse(swigCPtr, this, appliedImpulse);}
public float internalGetAppliedImpulse() {return DynamicsJNI.btTypedConstraint_internalGetAppliedImpulse(swigCPtr, this);}
public float getBreakingImpulseThreshold() {return DynamicsJNI.btTypedConstraint_getBreakingImpulseThreshold(swigCPtr, this);}
public void setBreakingImpulseThreshold(float threshold) {DynamicsJNI.btTypedConstraint_setBreakingImpulseThreshold(swigCPtr, this, threshold);}
public boolean isEnabled() {return DynamicsJNI.btTypedConstraint_isEnabled(swigCPtr, this);}
public void setEnabled(boolean enabled) {DynamicsJNI.btTypedConstraint_setEnabled(swigCPtr, this, enabled);}
public void solveConstraintObsolete(btSolverBody arg0, btSolverBody arg1, float arg2) {DynamicsJNI.btTypedConstraint_solveConstraintObsolete(swigCPtr, this, btSolverBody.getCPtr(arg0), arg0, btSolverBody.getCPtr(arg1), arg1, arg2);}
public btRigidBody getRigidBodyA() {return btRigidBody.getInstance(DynamicsJNI.btTypedConstraint_getRigidBodyA__SWIG_0(swigCPtr, this), false);}
public btRigidBody getRigidBodyB() {return btRigidBody.getInstance(DynamicsJNI.btTypedConstraint_getRigidBodyB__SWIG_0(swigCPtr, this), false);}
public int getUserConstraintType() {return DynamicsJNI.btTypedConstraint_getUserConstraintType(swigCPtr, this);}
public void setUserConstraintType(int userConstraintType) {DynamicsJNI.btTypedConstraint_setUserConstraintType(swigCPtr, this, userConstraintType);}
public void setUserConstraintId(int uid) {DynamicsJNI.btTypedConstraint_setUserConstraintId(swigCPtr, this, uid);}
public int getUserConstraintId() {return DynamicsJNI.btTypedConstraint_getUserConstraintId(swigCPtr, this);}
public void setUserConstraintPtr(long ptr) {DynamicsJNI.btTypedConstraint_setUserConstraintPtr(swigCPtr, this, ptr);}
public long getUserConstraintPtr() {return DynamicsJNI.btTypedConstraint_getUserConstraintPtr(swigCPtr, this);}
public void setJointFeedback(btJointFeedback jointFeedback) {DynamicsJNI.btTypedConstraint_setJointFeedback(swigCPtr, this, btJointFeedback.getCPtr(jointFeedback), jointFeedback);}
public btJointFeedback getJointFeedback() {long cPtr = DynamicsJNI.btTypedConstraint_getJointFeedback__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : new btJointFeedback(cPtr, false);}
public int getUid() {return DynamicsJNI.btTypedConstraint_getUid(swigCPtr, this);}
public boolean needsFeedback() {return DynamicsJNI.btTypedConstraint_needsFeedback(swigCPtr, this);}
public void enableFeedback(boolean needsFeedback) {DynamicsJNI.btTypedConstraint_enableFeedback(swigCPtr, this, needsFeedback);}
public float getAppliedImpulse() {return DynamicsJNI.btTypedConstraint_getAppliedImpulse(swigCPtr, this);}
public int getConstraintType() {return DynamicsJNI.btTypedConstraint_getConstraintType(swigCPtr, this);}
public void setDbgDrawSize(float dbgDrawSize) {DynamicsJNI.btTypedConstraint_setDbgDrawSize(swigCPtr, this, dbgDrawSize);}
public float getDbgDrawSize() {return DynamicsJNI.btTypedConstraint_getDbgDrawSize(swigCPtr, this);}
public void setParam(int num, float value, int axis) {DynamicsJNI.btTypedConstraint_setParam__SWIG_0(swigCPtr, this, num, value, axis);}
public void setParam(int num, float value) {DynamicsJNI.btTypedConstraint_setParam__SWIG_1(swigCPtr, this, num, value);}
public float getParam(int num, int axis) {return DynamicsJNI.btTypedConstraint_getParam__SWIG_0(swigCPtr, this, num, axis);}
public float getParam(int num) {return DynamicsJNI.btTypedConstraint_getParam__SWIG_1(swigCPtr, this, num);}
public int calculateSerializeBufferSize() {return DynamicsJNI.btTypedConstraint_calculateSerializeBufferSize(swigCPtr, this);}
public String serialize(long dataBuffer, SWIGTYPE_p_btSerializer serializer) {return DynamicsJNI.btTypedConstraint_serialize(swigCPtr, this, dataBuffer, SWIGTYPE_p_btSerializer.getCPtr(serializer));}private MeshBuilder getBuilder(final VertexAttributes attributes) {for (final MeshBuilder mb : builders) if (mb.getAttributes().equals(attributes) && mb.lastIndex() < Short.MAX_VALUE / 2)return mb;final MeshBuilder result = new MeshBuilder();result.begin(attributes);builders.add(result);return result;}
public void begin() {if (model != null)throw new GdxRuntimeException("Call end() first");node = null;model = new Model();builders.clear();}
public Model end() {if (model == null)throw new GdxRuntimeException("Call begin() first");final Model result = model;endnode();model = null;for (final MeshBuilder mb : builders) mb.end();builders.clear();rebuildReferences(result);return result;}
private void endnode() {if (node != null) {node = null;}}
protected Node node(final Node node) {if (model == null)throw new GdxRuntimeException("Call begin() first");endnode();model.nodes.add(node);this.node = node;return node;}
public Node node() {final Node node = new Node();node(node);node.id = "node" + model.nodes.size;return node;}
public Node node(final String id, final Model model) {final Node node = new Node();node.id = id;node.addChildren(model.nodes);node(node);for (final Disposable disposable : model.getManagedDisposables()) manage(disposable);return node;}
public void manage(final Disposable disposable) {if (model == null)throw new GdxRuntimeException("Call begin() first");model.manageDisposable(disposable);}
public void part(final MeshPart meshpart, final Material material) {if (node == null)node();node.parts.add(new NodePart(meshpart, material));}
public MeshPart part(final String id, final Mesh mesh, int primitiveType, int offset, int size, final Material material) {final MeshPart meshPart = new MeshPart();meshPart.id = id;meshPart.primitiveType = primitiveType;meshPart.mesh = mesh;meshPart.offset = offset;meshPart.size = size;part(meshPart, material);return meshPart;}
public MeshPart part(final String id, final Mesh mesh, int primitiveType, final Material material) {return part(id, mesh, primitiveType, 0, mesh.getNumIndices(), material);}
public MeshPartBuilder part(final String id, int primitiveType, final VertexAttributes attributes, final Material material) {final MeshBuilder builder = getBuilder(attributes);part(builder.part(id, primitiveType), material);return builder;}
public MeshPartBuilder part(final String id, int primitiveType, final long attributes, final Material material) {return part(id, primitiveType, MeshBuilder.createAttributes(attributes), material);}
public Model createBox(float width, float height, float depth, final Material material, final long attributes) {return createBox(width, height, depth, GL20.GL_TRIANGLES, material, attributes);}
public Model createBox(float width, float height, float depth, int primitiveType, final Material material, final long attributes) {begin();part("box", primitiveType, attributes, material).box(width, height, depth);return end();}
public Model createRect(float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11, float x01, float y01, float z01, float normalX, float normalY, float normalZ, final Material material, final long attributes) {return createRect(x00, y00, z00, x10, y10, z10, x11, y11, z11, x01, y01, z01, normalX, normalY, normalZ, GL20.GL_TRIANGLES, material, attributes);}
public Model createRect(float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11, float x01, float y01, float z01, float normalX, float normalY, float normalZ, int primitiveType, final Material material, final long attributes) {begin();part("rect", primitiveType, attributes, material).rect(x00, y00, z00, x10, y10, z10, x11, y11, z11, x01, y01, z01, normalX, normalY, normalZ);return end();}
public Model createCylinder(float width, float height, float depth, int divisions, final Material material, final long attributes) {return createCylinder(width, height, depth, divisions, GL20.GL_TRIANGLES, material, attributes);}
public Model createCylinder(float width, float height, float depth, int divisions, int primitiveType, final Material material, final long attributes) {return createCylinder(width, height, depth, divisions, primitiveType, material, attributes, 0, 360);}
public Model createCylinder(float width, float height, float depth, int divisions, final Material material, final long attributes, float angleFrom, float angleTo) {return createCylinder(width, height, depth, divisions, GL20.GL_TRIANGLES, material, attributes, angleFrom, angleTo);}
public Model createCylinder(float width, float height, float depth, int divisions, int primitiveType, final Material material, final long attributes, float angleFrom, float angleTo) {begin();part("cylinder", primitiveType, attributes, material).cylinder(width, height, depth, divisions, angleFrom, angleTo);return end();}
public Model createCone(float width, float height, float depth, int divisions, final Material material, final long attributes) {return createCone(width, height, depth, divisions, GL20.GL_TRIANGLES, material, attributes);}
public Model createCone(float width, float height, float depth, int divisions, int primitiveType, final Material material, final long attributes) {return createCone(width, height, depth, divisions, primitiveType, material, attributes, 0, 360);}
public Model createCone(float width, float height, float depth, int divisions, final Material material, final long attributes, float angleFrom, float angleTo) {return createCone(width, height, depth, divisions, GL20.GL_TRIANGLES, material, attributes, angleFrom, angleTo);}
public Model createCone(float width, float height, float depth, int divisions, int primitiveType, final Material material, final long attributes, float angleFrom, float angleTo) {begin();part("cone", primitiveType, attributes, material).cone(width, height, depth, divisions, angleFrom, angleTo);return end();}
public Model createSphere(float width, float height, float depth, int divisionsU, int divisionsV, final Material material, final long attributes) {return createSphere(width, height, depth, divisionsU, divisionsV, GL20.GL_TRIANGLES, material, attributes);}
public Model createSphere(float width, float height, float depth, int divisionsU, int divisionsV, int primitiveType, final Material material, final long attributes) {return createSphere(width, height, depth, divisionsU, divisionsV, primitiveType, material, attributes, 0, 360, 0, 180);}
public Model createSphere(float width, float height, float depth, int divisionsU, int divisionsV, final Material material, final long attributes, float angleUFrom, float angleUTo, float angleVFrom, float angleVTo) {return createSphere(width, height, depth, divisionsU, divisionsV, GL20.GL_TRIANGLES, material, attributes, angleUFrom, angleUTo, angleVFrom, angleVTo);}
public Model createSphere(float width, float height, float depth, int divisionsU, int divisionsV, int primitiveType, final Material material, final long attributes, float angleUFrom, float angleUTo, float angleVFrom, float angleVTo) {begin();part("cylinder", primitiveType, attributes, material).sphere(width, height, depth, divisionsU, divisionsV, angleUFrom, angleUTo, angleVFrom, angleVTo);return end();}
public Model createCapsule(float radius, float height, int divisions, final Material material, final long attributes) {return createCapsule(radius, height, divisions, GL20.GL_TRIANGLES, material, attributes);}
public Model createCapsule(float radius, float height, int divisions, int primitiveType, final Material material, final long attributes) {begin();part("capsule", primitiveType, attributes, material).capsule(radius, height, divisions);return end();}
public static void rebuildReferences(final Model model) {model.materials.clear();model.meshes.clear();model.meshParts.clear();for (final Node node : model.nodes) rebuildReferences(model, node);}
private static void rebuildReferences(final Model model, final Node node) {for (final NodePart mpm : node.parts) {if (!model.materials.contains(mpm.material, true))model.materials.add(mpm.material);if (!model.meshParts.contains(mpm.meshPart, true)) {model.meshParts.add(mpm.meshPart);if (!model.meshes.contains(mpm.meshPart.mesh, true))model.meshes.add(mpm.meshPart.mesh);model.manageDisposable(mpm.meshPart.mesh);}}for (final Node child : node.getChildren()) rebuildReferences(model, child);}
public Model createXYZCoordinates(float axisLength, float capLength, float stemThickness, int divisions, int primitiveType, Material material, long attributes) {begin();MeshPartBuilder partBuilder;Node node = node();partBuilder = part("xyz", primitiveType, attributes, material);partBuilder.setColor(Color.RED);partBuilder.arrow(0, 0, 0, axisLength, 0, 0, capLength, stemThickness, divisions);partBuilder.setColor(Color.GREEN);partBuilder.arrow(0, 0, 0, 0, axisLength, 0, capLength, stemThickness, divisions);partBuilder.setColor(Color.BLUE);partBuilder.arrow(0, 0, 0, 0, 0, axisLength, capLength, stemThickness, divisions);return end();}
public Model createXYZCoordinates(float axisLength, Material material, long attributes) {return createXYZCoordinates(axisLength, 0.1f, 0.1f, 5, GL20.GL_TRIANGLES, material, attributes);}
public Model createArrow(float x1, float y1, float z1, float x2, float y2, float z2, float capLength, float stemThickness, int divisions, int primitiveType, Material material, long attributes) {begin();part("arrow", primitiveType, attributes, material).arrow(x1, y1, z1, x2, y2, z2, capLength, stemThickness, divisions);return end();}
public Model createArrow(Vector3 from, Vector3 to, Material material, long attributes) {return createArrow(from.x, from.y, from.z, to.x, to.y, to.z, 0.1f, 0.1f, 5, GL20.GL_TRIANGLES, material, attributes);}
public Model createLineGrid(int xDivisions, int zDivisions, float xSize, float zSize, Material material, long attributes) {begin();MeshPartBuilder partBuilder = part("lines", GL20.GL_LINES, attributes, material);float xlength = xDivisions * xSize, zlength = zDivisions * zSize, hxlength = xlength / 2, hzlength = zlength / 2;float x1 = -hxlength, y1 = 0, z1 = hzlength, x2 = -hxlength, y2 = 0, z2 = -hzlength;for (int i = 0; i <= xDivisions; ++i) {partBuilder.line(x1, y1, z1, x2, y2, z2);x1 += xSize;x2 += xSize;}x1 = -hxlength;y1 = 0;z1 = -hzlength;x2 = hxlength;y2 = 0;z2 = -hzlength;for (int j = 0; j <= zDivisions; ++j) {partBuilder.line(x1, y1, z1, x2, y2, z2);z1 += zSize;z2 += zSize;}return end();}public String path() {return file.getPath().replace('\\', '/');}
public String name() {return file.getName();}
public String extension() {String name = file.getName();int dotIndex = name.lastIndexOf('.');if (dotIndex == -1)return "";return name.substring(dotIndex + 1);}
public String nameWithoutExtension() {String name = file.getName();int dotIndex = name.lastIndexOf('.');if (dotIndex == -1)return name;return name.substring(0, dotIndex);}
public FileType type() {return type;}
public File file() {return file;}
public InputStream read() {if (type == FileType.Classpath && !file.exists()) {InputStream input = FileDescriptor.class.getResourceAsStream("/" + file.getPath().replace('\\', '/'));if (input == null)throw new RuntimeException("File not found: " + file + " (" + type + ")");return input;}try {return new FileInputStream(file());} catch (FileNotFoundException ex) {if (file().isDirectory())throw new RuntimeException("Cannot open a stream to a directory: " + file + " (" + type + ")", ex);throw new RuntimeException("Error reading file: " + file + " (" + type + ")", ex);}}
public Reader reader() {return new InputStreamReader(read());}
public Reader reader(String charset) {try {return new InputStreamReader(read(), charset);} catch (UnsupportedEncodingException ex) {throw new RuntimeException("Error reading file: " + this, ex);}}
public BufferedReader reader(int bufferSize) {return new BufferedReader(new InputStreamReader(read()), bufferSize);}
public BufferedReader reader(int bufferSize, String charset) {try {return new BufferedReader(new InputStreamReader(read(), charset), bufferSize);} catch (UnsupportedEncodingException ex) {throw new RuntimeException("Error reading file: " + this, ex);}}
public String readString() {return readString(null);}
public String readString(String charset) {StringBuilder output = new StringBuilder(512);InputStreamReader reader = null;try {if (charset == null)reader = new InputStreamReader(read());elsereader = new InputStreamReader(read(), charset);char[] buffer = new char[256];while (true) {int length = reader.read(buffer);if (length == -1)break;output.append(buffer, 0, length);}} catch (IOException ex) {throw new RuntimeException("Error reading layout file: " + this, ex);} finally {try {if (reader != null)reader.close();} catch (IOException ignored) {}}return output.toString();}
public byte[] readBytes() {int length = (int) length();if (length == 0)length = 512;byte[] buffer = new byte[length];int position = 0;InputStream input = read();try {while (true) {int count = input.read(buffer, position, buffer.length - position);if (count == -1)break;position += count;if (position == buffer.length) {// Grow buffer.byte[] newBuffer = new byte[buffer.length * 2];System.arraycopy(buffer, 0, newBuffer, 0, position);buffer = newBuffer;}}} catch (IOException ex) {throw new RuntimeException("Error reading file: " + this, ex);} finally {try {if (input != null)input.close();} catch (IOException ignored) {}}if (position < buffer.length) {// Shrink buffer.byte[] newBuffer = new byte[position];System.arraycopy(buffer, 0, newBuffer, 0, position);buffer = newBuffer;}return buffer;}
public int readBytes(byte[] bytes, int offset, int size) {InputStream input = read();int position = 0;try {while (true) {int count = input.read(bytes, offset + position, size - position);if (count <= 0)break;position += count;}} catch (IOException ex) {throw new RuntimeException("Error reading file: " + this, ex);} finally {try {if (input != null)input.close();} catch (IOException ignored) {}}return position - offset;}
public OutputStream write(boolean append) {if (type == FileType.Classpath)throw new RuntimeException("Cannot write to a classpath file: " + file);parent().mkdirs();try {return new FileOutputStream(file(), append);} catch (FileNotFoundException ex) {if (file().isDirectory())throw new RuntimeException("Cannot open a stream to a directory: " + file + " (" + type + ")", ex);throw new RuntimeException("Error writing file: " + file + " (" + type + ")", ex);}}
public void write(InputStream input, boolean append) {OutputStream output = null;try {output = write(append);byte[] buffer = new byte[4096];while (true) {int length = input.read(buffer);if (length == -1)break;output.write(buffer, 0, length);}} catch (Exception ex) {throw new RuntimeException("Error stream writing to file: " + file + " (" + type + ")", ex);} finally {try {if (input != null)input.close();} catch (Exception ignored) {}try {if (output != null)output.close();} catch (Exception ignored) {}}}
public Writer writer(boolean append) {return writer(append, null);}
public Writer writer(boolean append, String charset) {if (type == FileType.Classpath)throw new RuntimeException("Cannot write to a classpath file: " + file);parent().mkdirs();try {FileOutputStream output = new FileOutputStream(file(), append);if (charset == null)return new OutputStreamWriter(output);elsereturn new OutputStreamWriter(output, charset);} catch (IOException ex) {if (file().isDirectory())throw new RuntimeException("Cannot open a stream to a directory: " + file + " (" + type + ")", ex);throw new RuntimeException("Error writing file: " + file + " (" + type + ")", ex);}}
public void writeString(String string, boolean append) {writeString(string, append, null);}
public void writeString(String string, boolean append, String charset) {Writer writer = null;try {writer = writer(append, charset);writer.write(string);} catch (Exception ex) {throw new RuntimeException("Error writing file: " + file + " (" + type + ")", ex);} finally {try {if (writer != null)writer.close();} catch (Exception ignored) {}}}
public void writeBytes(byte[] bytes, boolean append) {OutputStream output = write(append);try {output.write(bytes);} catch (IOException ex) {throw new RuntimeException("Error writing file: " + file + " (" + type + ")", ex);} finally {try {output.close();} catch (IOException ignored) {}}}
public FileDescriptor[] list() {if (type == FileType.Classpath)throw new RuntimeException("Cannot list a classpath directory: " + file);String[] relativePaths = file().list();if (relativePaths == null)return new FileDescriptor[0];FileDescriptor[] handles = new FileDescriptor[relativePaths.length];for (int i = 0, n = relativePaths.length; i < n; i++) handles[i] = child(relativePaths[i]);return handles;}
public FileDescriptor[] list(String suffix) {if (type == FileType.Classpath)throw new RuntimeException("Cannot list a classpath directory: " + file);String[] relativePaths = file().list();if (relativePaths == null)return new FileDescriptor[0];FileDescriptor[] handles = new FileDescriptor[relativePaths.length];int count = 0;for (int i = 0, n = relativePaths.length; i < n; i++) {String path = relativePaths[i];if (!path.endsWith(suffix))continue;handles[count] = child(path);count++;}if (count < relativePaths.length) {FileDescriptor[] newHandles = new FileDescriptor[count];System.arraycopy(handles, 0, newHandles, 0, count);handles = newHandles;}return handles;}
public boolean isDirectory() {if (type == FileType.Classpath)return false;return file().isDirectory();}
public FileDescriptor child(String name) {if (file.getPath().length() == 0)return new FileDescriptor(new File(name), type);return new FileDescriptor(new File(file, name), type);}
public FileDescriptor parent() {File parent = file.getParentFile();if (parent == null) {if (type == FileType.Absolute)parent = new File("/");elseparent = new File("");}return new FileDescriptor(parent, type);}
public boolean mkdirs() {if (type == FileType.Classpath)throw new RuntimeException("Cannot mkdirs with a classpath file: " + file);return file().mkdirs();}
public boolean exists() {if (type == FileType.Classpath)return FileDescriptor.class.getResource("/" + file.getPath().replace('\\', '/')) != null;return file().exists();}
public boolean delete() {if (type == FileType.Classpath)throw new RuntimeException("Cannot delete a classpath file: " + file);return file().delete();}
public boolean deleteDirectory() {if (type == FileType.Classpath)throw new RuntimeException("Cannot delete a classpath file: " + file);return deleteDirectory(file());}
public void copyTo(FileDescriptor dest) {if (!isDirectory()) {if (dest.isDirectory())dest = dest.child(name());copyFile(this, dest);return;}if (dest.exists()) {if (!dest.isDirectory())throw new RuntimeException("Destination exists but is not a directory: " + dest);} else {dest.mkdirs();if (!dest.isDirectory())throw new RuntimeException("Destination directory cannot be created: " + dest);}dest = dest.child(name());copyDirectory(this, dest);}
public void moveTo(FileDescriptor dest) {if (type == FileType.Classpath)throw new RuntimeException("Cannot move a classpath file: " + file);copyTo(dest);delete();}
public long length() {if (type == FileType.Classpath || !file.exists()) {InputStream input = read();try {return input.available();} catch (Exception ignored) {} finally {try {input.close();} catch (IOException ignored) {}}return 0;}return file().length();}
public long lastModified() {return file().lastModified();}
public String toString() {return file.getPath();}
public static FileDescriptor tempFile(String prefix) {try {return new FileDescriptor(File.createTempFile(prefix, null));} catch (IOException ex) {throw new RuntimeException("Unable to create temp file.", ex);}}
public static FileDescriptor tempDirectory(String prefix) {try {File file = File.createTempFile(prefix, null);if (!file.delete())throw new IOException("Unable to delete temp file: " + file);if (!file.mkdir())throw new IOException("Unable to create temp directory: " + file);return new FileDescriptor(file);} catch (IOException ex) {throw new RuntimeException("Unable to create temp file.", ex);}}
private static boolean deleteDirectory(File file) {if (file.exists()) {File[] files = file.listFiles();if (files != null) {for (int i = 0, n = files.length; i < n; i++) {if (files[i].isDirectory())deleteDirectory(files[i]);elsefiles[i].delete();}}}return file.delete();}
private static void copyFile(FileDescriptor source, FileDescriptor dest) {try {dest.write(source.read(), false);} catch (Exception ex) {throw new RuntimeException("Error copying source file: " + source.file + " (" + source.type + ")\n" + "To destination: " + dest.file + " (" + dest.type + ")", ex);}}
private static void copyDirectory(FileDescriptor sourceDir, FileDescriptor destDir) {destDir.mkdirs();FileDescriptor[] files = sourceDir.list();for (int i = 0, n = files.length; i < n; i++) {FileDescriptor srcFile = files[i];FileDescriptor destFile = destDir.child(srcFile.name());if (srcFile.isDirectory())copyDirectory(srcFile, destFile);elsecopyFile(srcFile, destFile);}}public void render() {if (renderMethod == 0)renderNormal();;if (renderMethod == 1)renderSprites();}
private void renderNormal() {Gdx.gl.glClearColor(0.7f, 0.7f, 0.7f, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);float begin = 0;float end = 0;float draw1 = 0;long start = TimeUtils.nanoTime();spriteCache.begin();begin = (TimeUtils.nanoTime() - start) / 1000000000.0f;start = TimeUtils.nanoTime();spriteCache.draw(normalCacheID);draw1 = (TimeUtils.nanoTime() - start) / 1000000000.0f;start = TimeUtils.nanoTime();spriteCache.end();end = (TimeUtils.nanoTime() - start) / 1000000000.0f;if (TimeUtils.nanoTime() - startTime > 1000000000) {// ", " + draw2 + ", " + drawText + ", " + end );frames = 0;startTime = TimeUtils.nanoTime();}frames++;}
private void renderSprites() {Gdx.gl.glClearColor(0.7f, 0.7f, 0.7f, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);float begin = 0;float end = 0;float draw1 = 0;float draw2 = 0;float drawText = 0;long start = TimeUtils.nanoTime();spriteCache.begin();begin = (TimeUtils.nanoTime() - start) / 1000000000.0f;start = TimeUtils.nanoTime();spriteCache.draw(spriteCacheID);draw1 = (TimeUtils.nanoTime() - start) / 1000000000.0f;start = TimeUtils.nanoTime();spriteCache.end();end = (TimeUtils.nanoTime() - start) / 1000000000.0f;if (TimeUtils.nanoTime() - startTime > 1000000000) {// ", " + draw2 + ", " + drawText + ", " + end );frames = 0;startTime = TimeUtils.nanoTime();}frames++;}
public void create() {spriteCache = new SpriteCache(1000, true);texture = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);Pixmap pixmap = new Pixmap(32, 32, Format.RGBA8888);pixmap.setColor(1, 1, 0, 0.5f);pixmap.fill();texture2 = new Texture(pixmap);pixmap.dispose();sprites = new float[SPRITES * 6];sprites2 = new float[SPRITES * 6];Sprite[] sprites3 = new Sprite[SPRITES * 2];for (int i = 0; i < sprites.length; i += 6) {sprites[i] = (int) (Math.random() * (Gdx.graphics.getWidth() - 32));sprites[i + 1] = (int) (Math.random() * (Gdx.graphics.getHeight() - 32));sprites[i + 2] = 0;sprites[i + 3] = 0;sprites[i + 4] = 32;sprites[i + 5] = 32;sprites2[i] = (int) (Math.random() * (Gdx.graphics.getWidth() - 32));sprites2[i + 1] = (int) (Math.random() * (Gdx.graphics.getHeight() - 32));sprites2[i + 2] = 0;sprites2[i + 3] = 0;sprites2[i + 4] = 32;sprites2[i + 5] = 32;}for (int i = 0; i < SPRITES * 2; i++) {int x = (int) (Math.random() * (Gdx.graphics.getWidth() - 32));int y = (int) (Math.random() * (Gdx.graphics.getHeight() - 32));if (i >= SPRITES)sprites3[i] = new Sprite(texture2, 32, 32);elsesprites3[i] = new Sprite(texture, 32, 32);sprites3[i].setPosition(x, y);sprites3[i].setOrigin(16, 16);}float scale = 1;float angle = 15;spriteCache.beginCache();for (int i = 0; i < sprites2.length; i += 6) spriteCache.add(texture2, sprites2[i], sprites2[i + 1], 16, 16, 32, 32, scale, scale, angle, 0, 0, 32, 32, false, false);for (int i = 0; i < sprites.length; i += 6) spriteCache.add(texture, sprites[i], sprites[i + 1], 16, 16, 32, 32, scale, scale, angle, 0, 0, 32, 32, false, false);normalCacheID = spriteCache.endCache();angle = -15;spriteCache.beginCache();for (int i = SPRITES; i < SPRITES << 1; i++) {sprites3[i].setRotation(angle);sprites3[i].setScale(scale);spriteCache.add(sprites3[i]);}for (int i = 0; i < SPRITES; i++) {sprites3[i].setRotation(angle);sprites3[i].setScale(scale);spriteCache.add(sprites3[i]);}spriteCacheID = spriteCache.endCache();Gdx.input.setInputProcessor(this);}
public boolean keyDown(int keycode) {if (keycode != Input.Keys.SPACE)return false;float scale = MathUtils.random(0.75f, 1.25f);float angle = MathUtils.random(1, 360);spriteCache.beginCache(normalCacheID);for (int i = 0; i < sprites2.length; i += 6) spriteCache.add(texture2, sprites2[i], sprites2[i + 1], 16, 16, 32, 32, scale, scale, angle, 0, 0, 32, 32, false, false);for (int i = 0; i < sprites.length; i += 6) spriteCache.add(texture, sprites[i], sprites[i + 1], 16, 16, 32, 32, scale, scale, angle, 0, 0, 32, 32, false, false);spriteCache.endCache();return false;}
public boolean touchUp(int x, int y, int pointer, int button) {renderMethod = (renderMethod + 1) % 2;return false;}
public void dispose() {texture.dispose();texture2.dispose();spriteCache.dispose();}public void run() {justTouched = false;if (keyJustPressed) {keyJustPressed = false;for (int i = 0; i < justPressedKeys.length; i++) {justPressedKeys[i] = false;}}if (processor != null) {if (touchEvent != null) {touchX[touchEvent.pointer] = touchEvent.x;touchY[touchEvent.pointer] = touchEvent.y;switch(touchEvent.type) {case TouchEvent.TOUCH_DOWN:processor.touchDown(touchEvent.x, touchEvent.y, touchEvent.pointer, Input.Buttons.LEFT);isTouched[touchEvent.pointer] = true;justTouched = true;break;case TouchEvent.TOUCH_UP:processor.touchUp(touchEvent.x, touchEvent.y, touchEvent.pointer, Input.Buttons.LEFT);isTouched[touchEvent.pointer] = false;break;case TouchEvent.TOUCH_DRAGGED:processor.touchDragged(touchEvent.x, touchEvent.y, touchEvent.pointer);break;}}if (keyEvent != null) {switch(keyEvent.type) {case KeyEvent.KEY_DOWN:processor.keyDown(keyEvent.keyCode);if (!keys[keyEvent.keyCode]) {keyCount++;keys[keyEvent.keyCode] = true;}keyJustPressed = true;justPressedKeys[keyEvent.keyCode] = true;break;case KeyEvent.KEY_UP:processor.keyUp(keyEvent.keyCode);if (keys[keyEvent.keyCode]) {keyCount--;keys[keyEvent.keyCode] = false;}break;case KeyEvent.KEY_TYPED:processor.keyTyped(keyEvent.keyChar);break;}}} else {if (touchEvent != null) {touchX[touchEvent.pointer] = touchEvent.x;touchY[touchEvent.pointer] = touchEvent.y;if (touchEvent.type == TouchEvent.TOUCH_DOWN) {isTouched[touchEvent.pointer] = true;justTouched = true;}if (touchEvent.type == TouchEvent.TOUCH_UP) {isTouched[touchEvent.pointer] = false;}}if (keyEvent != null) {if (keyEvent.type == KeyEvent.KEY_DOWN) {if (!keys[keyEvent.keyCode]) {keyCount++;keys[keyEvent.keyCode] = true;}keyJustPressed = true;justPressedKeys[keyEvent.keyCode] = true;}if (keyEvent.type == KeyEvent.KEY_UP) {if (keys[keyEvent.keyCode]) {keyCount--;keys[keyEvent.keyCode] = false;}}}}}
public void run() {while (true) {try {connected = false;if (listener != null)listener.onDisconnected();System.out.println("listening, port " + port);Socket socket = null;socket = serverSocket.accept();socket.setTcpNoDelay(true);socket.setSoTimeout(3000);connected = true;if (listener != null)listener.onConnected();DataInputStream in = new DataInputStream(socket.getInputStream());multiTouch = in.readBoolean();while (true) {int event = in.readInt();KeyEvent keyEvent = null;TouchEvent touchEvent = null;switch(event) {case RemoteSender.ACCEL:accel[0] = in.readFloat();accel[1] = in.readFloat();accel[2] = in.readFloat();break;case RemoteSender.COMPASS:compass[0] = in.readFloat();compass[1] = in.readFloat();compass[2] = in.readFloat();break;case RemoteSender.SIZE:remoteWidth = in.readFloat();remoteHeight = in.readFloat();break;case RemoteSender.KEY_DOWN:keyEvent = new KeyEvent();keyEvent.keyCode = in.readInt();keyEvent.type = KeyEvent.KEY_DOWN;break;case RemoteSender.KEY_UP:keyEvent = new KeyEvent();keyEvent.keyCode = in.readInt();keyEvent.type = KeyEvent.KEY_UP;break;case RemoteSender.KEY_TYPED:keyEvent = new KeyEvent();keyEvent.keyChar = in.readChar();keyEvent.type = KeyEvent.KEY_TYPED;break;case RemoteSender.TOUCH_DOWN:touchEvent = new TouchEvent();touchEvent.x = (int) ((in.readInt() / remoteWidth) * Gdx.graphics.getWidth());touchEvent.y = (int) ((in.readInt() / remoteHeight) * Gdx.graphics.getHeight());touchEvent.pointer = in.readInt();touchEvent.type = TouchEvent.TOUCH_DOWN;break;case RemoteSender.TOUCH_UP:touchEvent = new TouchEvent();touchEvent.x = (int) ((in.readInt() / remoteWidth) * Gdx.graphics.getWidth());touchEvent.y = (int) ((in.readInt() / remoteHeight) * Gdx.graphics.getHeight());touchEvent.pointer = in.readInt();touchEvent.type = TouchEvent.TOUCH_UP;break;case RemoteSender.TOUCH_DRAGGED:touchEvent = new TouchEvent();touchEvent.x = (int) ((in.readInt() / remoteWidth) * Gdx.graphics.getWidth());touchEvent.y = (int) ((in.readInt() / remoteHeight) * Gdx.graphics.getHeight());touchEvent.pointer = in.readInt();touchEvent.type = TouchEvent.TOUCH_DRAGGED;break;}Gdx.app.postRunnable(new EventTrigger(touchEvent, keyEvent));}} catch (IOException e) {e.printStackTrace();}}}
public boolean isConnected() {return connected;}
public float getAccelerometerX() {return accel[0];}
public float getAccelerometerY() {return accel[1];}
public float getAccelerometerZ() {return accel[2];}
public int getX() {return touchX[0];}
public int getX(int pointer) {return touchX[pointer];}
public int getY() {return touchY[0];}
public int getY(int pointer) {return touchY[pointer];}
public boolean isTouched() {return isTouched[0];}
public boolean justTouched() {return justTouched;}
public boolean isTouched(int pointer) {return isTouched[pointer];}
public boolean isButtonPressed(int button) {if (button != Buttons.LEFT)return false;for (int i = 0; i < isTouched.length; i++) if (isTouched[i])return true;return false;}
public boolean isKeyPressed(int key) {if (key == Input.Keys.ANY_KEY) {return keyCount > 0;}if (key < 0 || key > 255) {return false;}return keys[key];}
public boolean isKeyJustPressed(int key) {if (key == Input.Keys.ANY_KEY) {return keyJustPressed;}if (key < 0 || key > 255) {return false;}return justPressedKeys[key];}
public void getTextInput(TextInputListener listener, String title, String text, String hint) {Gdx.app.getInput().getTextInput(listener, title, text, hint);}
public void setOnscreenKeyboardVisible(boolean visible) {}
public void vibrate(int milliseconds) {}
public void vibrate(long[] pattern, int repeat) {}
public void cancelVibrate() {}
public float getAzimuth() {return compass[0];}
public float getPitch() {return compass[1];}
public float getRoll() {return compass[2];}
public void setCatchBackKey(boolean catchBack) {}
public boolean isCatchBackKey() {return false;}
public void setCatchMenuKey(boolean catchMenu) {}
public boolean isCatchMenuKey() {return false;}
public void setInputProcessor(InputProcessor processor) {this.processor = processor;}
public InputProcessor getInputProcessor() {return this.processor;}
public String[] getIPs() {return ips;}
public boolean isPeripheralAvailable(Peripheral peripheral) {if (peripheral == Peripheral.Accelerometer)return true;if (peripheral == Peripheral.Compass)return true;if (peripheral == Peripheral.MultitouchScreen)return multiTouch;return false;}
public int getRotation() {return 0;}
public Orientation getNativeOrientation() {return Orientation.Landscape;}
public void setCursorCatched(boolean catched) {}
public boolean isCursorCatched() {return false;}
public int getDeltaX() {// TODO Auto-generated method stubreturn 0;}
public int getDeltaX(int pointer) {return 0;}
public int getDeltaY() {return 0;}
public int getDeltaY(int pointer) {return 0;}
public void setCursorPosition(int x, int y) {}
public long getCurrentEventTime() {// TODO Auto-generated method stubreturn 0;}
public void getRotationMatrix(float[] matrix) {}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btGeneric6DofSpring2ConstraintDoubleData2 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btGeneric6DofSpring2ConstraintDoubleData2(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setTypeConstraintData(btTypedConstraintDoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_typeConstraintData_set(swigCPtr, this, btTypedConstraintDoubleData.getCPtr(value), value);}
public btTypedConstraintDoubleData getTypeConstraintData() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_typeConstraintData_get(swigCPtr, this);return (cPtr == 0) ? null : new btTypedConstraintDoubleData(cPtr, false);}
public void setRbAFrame(btTransformDoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_rbAFrame_set(swigCPtr, this, btTransformDoubleData.getCPtr(value), value);}
public btTransformDoubleData getRbAFrame() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_rbAFrame_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformDoubleData(cPtr, false);}
public void setRbBFrame(btTransformDoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_rbBFrame_set(swigCPtr, this, btTransformDoubleData.getCPtr(value), value);}
public btTransformDoubleData getRbBFrame() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_rbBFrame_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformDoubleData(cPtr, false);}
public void setLinearUpperLimit(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearUpperLimit_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearUpperLimit() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearUpperLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearLowerLimit(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearLowerLimit_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearLowerLimit() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearLowerLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearBounce(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearBounce_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearBounce() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearBounce_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearStopERP(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearStopERP_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearStopERP() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearStopERP_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearStopCFM(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearStopCFM_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearStopCFM() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearStopCFM_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearMotorERP(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearMotorERP_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearMotorERP() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearMotorERP_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearMotorCFM(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearMotorCFM_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearMotorCFM() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearMotorCFM_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearTargetVelocity(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearTargetVelocity_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearTargetVelocity() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearTargetVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearMaxMotorForce(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearMaxMotorForce_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearMaxMotorForce() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearMaxMotorForce_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearServoTarget(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearServoTarget_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearServoTarget() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearServoTarget_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearSpringStiffness(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearSpringStiffness_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearSpringStiffness() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearSpringStiffness_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearSpringDamping(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearSpringDamping_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearSpringDamping() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearSpringDamping_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearEquilibriumPoint(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearEquilibriumPoint_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getLinearEquilibriumPoint() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearEquilibriumPoint_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setLinearEnableMotor(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearEnableMotor_set(swigCPtr, this, value);}
public String getLinearEnableMotor() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearEnableMotor_get(swigCPtr, this);}
public void setLinearServoMotor(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearServoMotor_set(swigCPtr, this, value);}
public String getLinearServoMotor() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearServoMotor_get(swigCPtr, this);}
public void setLinearEnableSpring(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearEnableSpring_set(swigCPtr, this, value);}
public String getLinearEnableSpring() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearEnableSpring_get(swigCPtr, this);}
public void setLinearSpringStiffnessLimited(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearSpringStiffnessLimited_set(swigCPtr, this, value);}
public String getLinearSpringStiffnessLimited() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearSpringStiffnessLimited_get(swigCPtr, this);}
public void setLinearSpringDampingLimited(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearSpringDampingLimited_set(swigCPtr, this, value);}
public String getLinearSpringDampingLimited() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_linearSpringDampingLimited_get(swigCPtr, this);}
public void setPadding1(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_padding1_set(swigCPtr, this, value);}
public String getPadding1() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_padding1_get(swigCPtr, this);}
public void setAngularUpperLimit(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularUpperLimit_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularUpperLimit() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularUpperLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularLowerLimit(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularLowerLimit_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularLowerLimit() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularLowerLimit_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularBounce(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularBounce_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularBounce() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularBounce_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularStopERP(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularStopERP_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularStopERP() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularStopERP_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularStopCFM(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularStopCFM_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularStopCFM() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularStopCFM_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularMotorERP(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularMotorERP_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularMotorERP() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularMotorERP_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularMotorCFM(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularMotorCFM_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularMotorCFM() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularMotorCFM_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularTargetVelocity(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularTargetVelocity_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularTargetVelocity() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularTargetVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularMaxMotorForce(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularMaxMotorForce_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularMaxMotorForce() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularMaxMotorForce_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularServoTarget(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularServoTarget_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularServoTarget() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularServoTarget_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularSpringStiffness(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularSpringStiffness_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularSpringStiffness() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularSpringStiffness_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularSpringDamping(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularSpringDamping_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularSpringDamping() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularSpringDamping_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularEquilibriumPoint(btVector3DoubleData value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularEquilibriumPoint_set(swigCPtr, this, btVector3DoubleData.getCPtr(value), value);}
public btVector3DoubleData getAngularEquilibriumPoint() {long cPtr = DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularEquilibriumPoint_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3DoubleData(cPtr, false);}
public void setAngularEnableMotor(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularEnableMotor_set(swigCPtr, this, value);}
public String getAngularEnableMotor() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularEnableMotor_get(swigCPtr, this);}
public void setAngularServoMotor(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularServoMotor_set(swigCPtr, this, value);}
public String getAngularServoMotor() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularServoMotor_get(swigCPtr, this);}
public void setAngularEnableSpring(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularEnableSpring_set(swigCPtr, this, value);}
public String getAngularEnableSpring() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularEnableSpring_get(swigCPtr, this);}
public void setAngularSpringStiffnessLimited(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularSpringStiffnessLimited_set(swigCPtr, this, value);}
public String getAngularSpringStiffnessLimited() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularSpringStiffnessLimited_get(swigCPtr, this);}
public void setAngularSpringDampingLimited(String value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularSpringDampingLimited_set(swigCPtr, this, value);}
public String getAngularSpringDampingLimited() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_angularSpringDampingLimited_get(swigCPtr, this);}
public void setRotateOrder(int value) {DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_rotateOrder_set(swigCPtr, this, value);}
public int getRotateOrder() {return DynamicsJNI.btGeneric6DofSpring2ConstraintDoubleData2_rotateOrder_get(swigCPtr, this);}public void create() {font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);batch = new SpriteBatch();if (Gdx.files.isExternalStorageAvailable()) {message += "External storage available\n";message += "External storage path: " + Gdx.files.getExternalStoragePath() + "\n";try {InputStream in = Gdx.files.internal("data/cube.obj").read();StreamUtils.closeQuietly(in);message += "Open internal success\n";} catch (Throwable e) {message += "Couldn't open internal data/cube.obj\n" + e.getMessage() + "\n";}BufferedWriter out = null;try {out = new BufferedWriter(new OutputStreamWriter(Gdx.files.external("test.txt").write(false)));out.write("test");message += "Write external success\n";} catch (GdxRuntimeException ex) {message += "Couldn't open externalstorage/test.txt\n";} catch (IOException e) {message += "Couldn't write externalstorage/test.txt\n";} finally {StreamUtils.closeQuietly(out);}try {InputStream in = Gdx.files.external("test.txt").read();StreamUtils.closeQuietly(in);message += "Open external success\n";} catch (Throwable e) {message += "Couldn't open internal externalstorage/test.txt\n" + e.getMessage() + "\n";}BufferedReader in = null;try {in = new BufferedReader(new InputStreamReader(Gdx.files.external("test.txt").read()));if (!in.readLine().equals("test"))message += "Read result wrong\n";elsemessage += "Read external success\n";} catch (GdxRuntimeException ex) {message += "Couldn't open externalstorage/test.txt\n";} catch (IOException e) {message += "Couldn't read externalstorage/test.txt\n";} finally {StreamUtils.closeQuietly(in);}if (!Gdx.files.external("test.txt").delete())message += "Couldn't delete externalstorage/test.txt";} else {message += "External storage not available";}if (Gdx.files.isLocalStorageAvailable()) {message += "Local storage available\n";message += "Local storage path: " + Gdx.files.getLocalStoragePath() + "\n";BufferedWriter out = null;try {out = new BufferedWriter(new OutputStreamWriter(Gdx.files.local("test.txt").write(false)));out.write("test");message += "Write local success\n";} catch (GdxRuntimeException ex) {message += "Couldn't open localstorage/test.txt\n";} catch (IOException e) {message += "Couldn't write localstorage/test.txt\n";} finally {StreamUtils.closeQuietly(out);}try {InputStream in = Gdx.files.local("test.txt").read();StreamUtils.closeQuietly(in);message += "Open local success\n";} catch (Throwable e) {message += "Couldn't open localstorage/test.txt\n" + e.getMessage() + "\n";}BufferedReader in = null;try {in = new BufferedReader(new InputStreamReader(Gdx.files.local("test.txt").read()));if (!in.readLine().equals("test"))message += "Read result wrong\n";elsemessage += "Read local success\n";} catch (GdxRuntimeException ex) {message += "Couldn't open localstorage/test.txt\n";} catch (IOException e) {message += "Couldn't read localstorage/test.txt\n";} finally {StreamUtils.closeQuietly(in);}try {byte[] testBytes = Gdx.files.local("test.txt").readBytes();if (Arrays.equals("test".getBytes(), testBytes))message += "Read into byte array success\n";elsefail();} catch (Throwable e) {message += "Couldn't read localstorage/test.txt\n" + e.getMessage() + "\n";}if (!Gdx.files.local("test.txt").delete())message += "Couldn't delete localstorage/test.txt";}try {testClasspath();testInternal();testExternal();testAbsolute();testLocal();} catch (IOException ex) {throw new RuntimeException(ex);}}
private void testClasspath() {// no classpath support on iosif (Gdx.app.getType() == ApplicationType.iOS)return;FileHandle handle = Gdx.files.classpath("com/badlogic/gdx/utils/arial-15.png");if (!handle.exists())fail();if (handle.isDirectory())fail();try {handle.delete();fail();} catch (Exception expected) {}try {handle.list();fail();} catch (Exception expected) {}try {handle.read().close();fail();} catch (Exception ignored) {}FileHandle dir = Gdx.files.classpath("com/badlogic/gdx/utils");if (dir.isDirectory())fail();FileHandle child = dir.child("arial-15.fnt");if (!child.name().equals("arial-15.fnt"))fail();if (!child.nameWithoutExtension().equals("arial-15"))fail();if (!child.extension().equals("fnt"))fail();handle.read().close();if (handle.readBytes().length != handle.length())fail();}
private void testInternal() {FileHandle handle = Gdx.files.internal("data/badlogic.jpg");if (!handle.exists())fail("Couldn't find internal file");if (handle.isDirectory())fail("Internal file shouldn't be a directory");try {handle.delete();fail("Shouldn't be able to delete internal file");} catch (Exception expected) {}if (handle.list().length != 0)fail("File length shouldn't be 0");if (Gdx.app.getType() != ApplicationType.Android) {if (!handle.parent().exists())fail("Parent doesn't exist");}try {handle.read().close();fail();} catch (Exception ignored) {}FileHandle dir;if (Gdx.app.getType() == ApplicationType.Android || Gdx.app.getType() == ApplicationType.iOS)dir = Gdx.files.internal("data");elsedir = Gdx.files.internal("../gdx-tests-android/assets/data");if (Gdx.app.getType() != ApplicationType.Android) {if (!dir.exists())fail();}if (!dir.isDirectory())fail();if (dir.list().length == 0)fail();FileHandle child = dir.child("badlogic.jpg");if (!child.name().equals("badlogic.jpg"))fail();if (!child.nameWithoutExtension().equals("badlogic"))fail();if (!child.extension().equals("jpg"))fail();if (Gdx.app.getType() != ApplicationType.Android) {if (!child.parent().exists())fail();}FileHandle copy = Gdx.files.external("badlogic.jpg-copy");copy.delete();if (copy.exists())fail();handle.copyTo(copy);if (!copy.exists())fail();if (copy.length() != 68465)fail();copy.delete();if (copy.exists())fail();handle.read().close();if (handle.readBytes().length != handle.length())fail();}
private void testExternal() {String path = "meow";FileHandle handle = Gdx.files.external(path);handle.delete();if (handle.exists())fail();if (handle.isDirectory())fail();if (handle.delete())fail();if (handle.list().length != 0)fail();if (handle.child("meow").exists())fail();if (!handle.parent().exists())fail();try {handle.read().close();fail();} catch (Exception ignored) {}handle.mkdirs();if (!handle.exists())fail();if (!handle.isDirectory())fail();if (handle.list().length != 0)fail();handle.child("meow").mkdirs();if (handle.list().length != 1)fail();FileHandle child = handle.list()[0];if (!child.name().equals("meow"))fail();if (!child.parent().exists())fail();if (!handle.deleteDirectory())fail();if (handle.exists())fail();OutputStream output = handle.write(false);output.write("moo".getBytes());output.close();if (!handle.exists())fail();if (handle.length() != 3)fail();FileHandle copy = Gdx.files.external(path + "-copy");copy.delete();if (copy.exists())fail();handle.copyTo(copy);if (!copy.exists())fail();if (copy.length() != 3)fail();FileHandle move = Gdx.files.external(path + "-move");move.delete();if (move.exists())fail();copy.moveTo(move);if (!move.exists())fail();if (move.length() != 3)fail();move.deleteDirectory();if (move.exists())fail();InputStream input = handle.read();byte[] bytes = new byte[6];if (input.read(bytes) != 3)fail();input.close();if (!new String(bytes, 0, 3).equals("moo"))fail();output = handle.write(true);output.write("cow".getBytes());output.close();if (handle.length() != 6)fail();input = handle.read();if (input.read(bytes) != 6)fail();input.close();if (!new String(bytes, 0, 6).equals("moocow"))fail();if (handle.isDirectory())fail();if (handle.list().length != 0)fail();if (!handle.name().equals("meow"))fail();if (!handle.nameWithoutExtension().equals("meow"))fail();if (!handle.extension().equals(""))fail();handle.deleteDirectory();if (handle.exists())fail();if (handle.isDirectory())fail();handle.delete();handle.deleteDirectory();}
private void testAbsolute() {String path = new File(Gdx.files.getExternalStoragePath(), "meow").getAbsolutePath();FileHandle handle = Gdx.files.absolute(path);handle.delete();if (handle.exists())fail();if (handle.isDirectory())fail();if (handle.delete())fail();if (handle.list().length != 0)fail();if (handle.child("meow").exists())fail();if (!handle.parent().exists())fail();try {handle.read().close();fail();} catch (Exception ignored) {}handle.mkdirs();if (!handle.exists())fail();if (!handle.isDirectory())fail();if (handle.list().length != 0)fail();handle.child("meow").mkdirs();if (handle.list().length != 1)fail();FileHandle child = handle.list()[0];if (!child.name().equals("meow"))fail();if (!child.parent().exists())fail();if (!handle.deleteDirectory())fail();if (handle.exists())fail();OutputStream output = handle.write(false);output.write("moo".getBytes());output.close();if (!handle.exists())fail();if (handle.length() != 3)fail();FileHandle copy = Gdx.files.absolute(path + "-copy");copy.delete();if (copy.exists())fail();handle.copyTo(copy);if (!copy.exists())fail();if (copy.length() != 3)fail();FileHandle move = Gdx.files.absolute(path + "-move");move.delete();if (move.exists())fail();copy.moveTo(move);if (!move.exists())fail();if (move.length() != 3)fail();move.deleteDirectory();if (move.exists())fail();InputStream input = handle.read();byte[] bytes = new byte[6];if (input.read(bytes) != 3)fail();input.close();if (!new String(bytes, 0, 3).equals("moo"))fail();output = handle.write(true);output.write("cow".getBytes());output.close();if (handle.length() != 6)fail();input = handle.read();if (input.read(bytes) != 6)fail();input.close();if (!new String(bytes, 0, 6).equals("moocow"))fail();if (handle.isDirectory())fail();if (handle.list().length != 0)fail();if (!handle.name().equals("meow"))fail();if (!handle.nameWithoutExtension().equals("meow"))fail();if (!handle.extension().equals(""))fail();handle.deleteDirectory();if (handle.exists())fail();if (handle.isDirectory())fail();handle.delete();handle.deleteDirectory();}
private void testLocal() {String path = "meow";FileHandle handle = Gdx.files.local(path);handle.delete();if (handle.exists())fail();if (handle.isDirectory())fail();if (handle.delete())fail();if (handle.list().length != 0)fail();if (handle.child("meow").exists())fail();if (!handle.parent().exists())fail();try {handle.read().close();fail();} catch (Exception ignored) {}handle.mkdirs();if (!handle.exists())fail();if (!handle.isDirectory())fail();if (handle.list().length != 0)fail();handle.child("meow").mkdirs();if (handle.list().length != 1)fail();FileHandle child = handle.list()[0];if (!child.name().equals("meow"))fail();if (!child.parent().exists())fail();if (!handle.deleteDirectory())fail();if (handle.exists())fail();OutputStream output = handle.write(false);output.write("moo".getBytes());output.close();if (!handle.exists())fail();if (handle.length() != 3)fail();FileHandle copy = Gdx.files.local(path + "-copy");copy.delete();if (copy.exists())fail();handle.copyTo(copy);if (!copy.exists())fail();if (copy.length() != 3)fail();FileHandle move = Gdx.files.local(path + "-move");move.delete();if (move.exists())fail();copy.moveTo(move);if (!move.exists())fail();if (move.length() != 3)fail();move.deleteDirectory();if (move.exists())fail();InputStream input = handle.read();byte[] bytes = new byte[6];if (input.read(bytes) != 3)fail();input.close();if (!new String(bytes, 0, 3).equals("moo"))fail();output = handle.write(true);output.write("cow".getBytes());output.close();if (handle.length() != 6)fail();input = handle.read();if (input.read(bytes) != 6)fail();input.close();if (!new String(bytes, 0, 6).equals("moocow"))fail();if (handle.isDirectory())fail();if (handle.list().length != 0)fail();if (!handle.name().equals("meow"))fail();if (!handle.nameWithoutExtension().equals("meow"))fail();if (!handle.extension().equals(""))fail();handle.deleteDirectory();if (handle.exists())fail();if (handle.isDirectory())fail();handle.delete();handle.deleteDirectory();}
private void fail() {throw new RuntimeException();}
private void fail(String msg) {throw new RuntimeException(msg);}
public void render() {Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);batch.begin();font.draw(batch, message, 20, Gdx.graphics.getHeight() - 20);batch.end();}
public void dispose() {batch.dispose();font.dispose();}public void mousePressed(MouseEvent event) {movingIndex = overIndex;moveAll = event.isControlDown();if (moveAll) {moveAllProportionally = event.isShiftDown();moveAllPrevY = event.getY();}}
public void mouseReleased(MouseEvent event) {movingIndex = -1;moveAll = false;}
public void mouseClicked(MouseEvent event) {if (event.getClickCount() == 2) {if (overIndex <= 0 || overIndex >= points.size())return;points.remove(overIndex);pointsChanged();repaint();return;}if (movingIndex != -1)return;if (overIndex != -1)return;int mouseX = event.getX();int mouseY = event.getY();if (mouseX < chartX || mouseX > chartX + chartWidth)return;if (mouseY < chartY || mouseY > chartY + chartHeight)return;Point newPoint = pixelToPoint(mouseX, mouseY);int i = 0;Point lastPoint = null;for (Point point : points) {if (point.x > newPoint.x) {if (Math.abs(point.x - newPoint.x) < 0.001f)return;if (lastPoint != null && Math.abs(lastPoint.x - newPoint.x) < 0.001f)return;points.add(i, newPoint);overIndex = i;pointsChanged();repaint();return;}lastPoint = point;i++;}overIndex = points.size();points.add(newPoint);pointsChanged();repaint();}
public void mouseDragged(MouseEvent event) {if (movingIndex == -1 || movingIndex >= points.size())return;if (moveAll) {int newY = event.getY();float deltaY = (moveAllPrevY - newY) / (float) chartHeight * maxY;for (Point point : points) {point.y = Math.min(maxY, Math.max(0, point.y + (moveAllProportionally ? deltaY * point.y : deltaY)));}moveAllPrevY = newY;} else {float nextX = movingIndex == points.size() - 1 ? maxX : points.get(movingIndex + 1).x - 0.001f;if (movingIndex == 0)nextX = 0;float prevX = movingIndex == 0 ? 0 : points.get(movingIndex - 1).x + 0.001f;Point point = points.get(movingIndex);point.x = Math.min(nextX, Math.max(prevX, (event.getX() - chartX) / (float) chartWidth * maxX));point.y = Math.min(maxY, Math.max(0, chartHeight - (event.getY() - chartY)) / (float) chartHeight * maxY);}pointsChanged();repaint();}
public void mouseMoved(MouseEvent event) {int mouseX = event.getX();int mouseY = event.getY();int oldIndex = overIndex;overIndex = -1;int pointSize = isExpanded ? POINT_SIZE_EXPANDED : POINT_SIZE;int i = 0;for (Point point : points) {int x = chartX + (int) (chartWidth * (point.x / (float) maxX));int y = chartY + chartHeight - (int) (chartHeight * (point.y / (float) maxY));if (Math.abs(x - mouseX) <= pointSize && Math.abs(y - mouseY) <= pointSize) {overIndex = i;break;}i++;}if (overIndex != oldIndex)repaint();}
public void addPoint(float x, float y) {points.add(new Point(x, y));}
public void pointsChanged() {}
public float[] getValuesX() {float[] values = new float[points.size()];int i = 0;for (Point point : points) values[i++] = point.x;return values;}
public float[] getValuesY() {float[] values = new float[points.size()];int i = 0;for (Point point : points) values[i++] = point.y;return values;}
public void setValues(float[] x, float[] y) {points.clear();for (int i = 0; i < x.length; i++) points.add(new Point(x[i], y[i]));}
Point pixelToPoint(float x, float y) {Point point = new Point();point.x = Math.min(maxX, Math.max(0, x - chartX) / (float) chartWidth * maxX);point.y = Math.min(maxY, Math.max(0, chartHeight - (y - chartY)) / (float) chartHeight * maxY);return point;}
Point pointToPixel(Point point) {Point pixel = new Point();pixel.x = chartX + (int) (chartWidth * (point.x / (float) maxX));pixel.y = chartY + chartHeight - (int) (chartHeight * (point.y / (float) maxY));return pixel;}
protected void paintComponent(Graphics graphics) {// setBackground(Color.red);super.paintComponent(graphics);Graphics2D g = (Graphics2D) graphics;FontMetrics metrics = g.getFontMetrics();if (numberHeight == 0) {numberHeight = getFont().layoutGlyphVector(g.getFontRenderContext(), new char[] { '0' }, 0, 1, Font.LAYOUT_LEFT_TO_RIGHT).getGlyphPixelBounds(0, g.getFontRenderContext(), 0, 0).height;}int width = getWidth();if (!isExpanded)width = Math.min(150, width);width = Math.max(100, width);int height = getHeight();int maxAxisLabelWidth;int yAxisWidth;if (isExpanded) {maxAxisLabelWidth = metrics.stringWidth("100%");yAxisWidth = maxAxisLabelWidth + 8;chartX = yAxisWidth;chartY = numberHeight / 2 + 1;chartWidth = width - yAxisWidth - 2;chartHeight = height - chartY - numberHeight - 8;} else {maxAxisLabelWidth = 0;yAxisWidth = 2;chartX = yAxisWidth;chartY = 2;chartWidth = width - yAxisWidth - 2;chartHeight = height - chartY - 3;}g.setColor(Color.white);g.fillRect(chartX, chartY, chartWidth, chartHeight);g.setColor(Color.black);g.drawRect(chartX, chartY, chartWidth, chartHeight);maxX = 1;{int y = height;if (isExpanded)y -= numberHeight;elsey += 5;int xSplit = (int) Math.min(10, chartWidth / (maxAxisLabelWidth * 1.5f));for (int i = 0; i <= xSplit; i++) {float percent = i / (float) xSplit;String label = axisLabel(maxX * percent);int labelWidth = metrics.stringWidth(label);int x = (int) (yAxisWidth + chartWidth * percent);if (i != 0 && i != xSplit) {g.setColor(Color.lightGray);g.drawLine(x, chartY + 1, x, chartY + chartHeight);g.setColor(Color.black);}g.drawLine(x, y - 4, x, y - 8);if (isExpanded) {x -= labelWidth / 2;if (i == xSplit)x = Math.min(x, width - labelWidth);g.drawString(label, x, y + numberHeight);}}}maxY = 1;{int ySplit = isExpanded ? Math.min(10, chartHeight / (numberHeight * 3)) : 4;for (int i = 0; i <= ySplit; i++) {float percent = i / (float) ySplit;String label = axisLabel(maxY * percent);int labelWidth = metrics.stringWidth(label);int y = (int) (chartY + chartHeight - chartHeight * percent);if (isExpanded)g.drawString(label, yAxisWidth - 6 - labelWidth, y + numberHeight / 2);if (i != 0 && i != ySplit) {g.setColor(Color.lightGray);g.drawLine(chartX, y, chartX + chartWidth - 1, y);g.setColor(Color.black);}g.drawLine(yAxisWidth - 4, y, yAxisWidth, y);}}{int titleWidth = metrics.stringWidth(title);int x = yAxisWidth + chartWidth / 2 - titleWidth / 2;int y = chartY + chartHeight / 2 - numberHeight / 2;g.setColor(Color.white);g.fillRect(x - 2, y - 2, titleWidth + 4, numberHeight + 4);g.setColor(Color.lightGray);g.drawString(title, x, y + numberHeight);}g.setColor(Color.blue);g.setStroke(new BasicStroke(isExpanded ? 3 : 2));int lastX = -1, lastY = -1;for (Point point : points) {Point pixel = pointToPixel(point);if (lastX != -1)g.drawLine(lastX, lastY, (int) pixel.x, (int) pixel.y);lastX = (int) pixel.x;lastY = (int) pixel.y;}g.drawLine(lastX, lastY, chartX + chartWidth - 1, lastY);for (int i = 0, n = points.size(); i < n; i++) {Point point = points.get(i);Point pixel = pointToPixel(point);if (overIndex == i)g.setColor(Color.red);elseg.setColor(Color.black);String label = valueLabel(point.y);int labelWidth = metrics.stringWidth(label);int pointSize = isExpanded ? POINT_SIZE_EXPANDED : POINT_SIZE;int x = (int) pixel.x - pointSize / 2;int y = (int) pixel.y - pointSize / 2;g.fillOval(x, y, pointSize, pointSize);if (isExpanded) {g.setColor(Color.black);x = Math.max(chartX + 2, Math.min(chartX + chartWidth - labelWidth, x));y -= 3;if (y < chartY + numberHeight + 3)y += 27;else if (n > 1) {Point comparePoint = i == n - 1 ? points.get(i - 1) : points.get(i + 1);if (y < chartY + chartHeight - 27 && comparePoint.y > point.y)y += 27;}g.drawString(label, x, y);}}}
private String valueLabel(float value) {value = (int) (value * 1000) / 10f;if (value % 1 == 0)return String.valueOf((int) value) + '%';elsereturn String.valueOf(value) + '%';}
private String axisLabel(float value) {value = (int) (value * 100);if (value % 1 == 0)return String.valueOf((int) value) + '%';elsereturn String.valueOf(value) + '%';}
public boolean isExpanded() {return isExpanded;}
public void setExpanded(boolean isExpanded) {this.isExpanded = isExpanded;}
public void setTitle(String title) {this.title = title;}private void set(DynamicsInfluencer influencer) {//Clearfor (int i = velocityTableModel.getRowCount() - 1; i >= 0; i--) {velocityTableModel.removeRow(i);}velocities.clear();//Addfor (int i = 0, c = influencer.velocities.size; i < c; ++i) {velocities.add(new VelocityWrapper((DynamicsModifier) influencer.velocities.items[i], true));velocityTableModel.addRow(new Object[] { "Velocity " + i, true });}DefaultComboBoxModel model = (DefaultComboBoxModel) velocityBox.getModel();model.removeAllElements();for (Object velocityObject : getAvailableVelocities(editor.getControllerType())) {model.addElement(velocityObject);}}
private Object[] getAvailableVelocities(ControllerType type) {if (type == ControllerType.Billboard || type == ControllerType.PointSprite) {return new String[] { VEL_TYPE_ROTATIONAL_2D, VEL_TYPE_CENTRIPETAL, VEL_TYPE_TANGENTIAL, VEL_TYPE_POLAR, VEL_TYPE_BROWNIAN };} else if (type == ControllerType.ModelInstance || type == ControllerType.ParticleController) {return new String[] { VEL_TYPE_ROTATIONAL_3D, VEL_TYPE_CENTRIPETAL, VEL_TYPE_TANGENTIAL, VEL_TYPE_POLAR, VEL_TYPE_BROWNIAN, VEL_TYPE_FACE };}return null;}
protected void initializeComponents() {super.initializeComponents();JPanel velocitiesPanel = new JPanel();velocitiesPanel.setLayout(new GridBagLayout());{JPanel sideButtons = new JPanel(new GridBagLayout());velocitiesPanel.add(sideButtons, new GridBagConstraints(1, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));{sideButtons.add(velocityBox = new JComboBox(new DefaultComboBoxModel()), new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));}{JButton newButton = new JButton("New");sideButtons.add(newButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));newButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent event) {createVelocity(velocityBox.getSelectedItem());}});}{JButton deleteButton = new JButton("Delete");sideButtons.add(deleteButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));deleteButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent event) {deleteVelocity();}});}}JScrollPane scroll = new JScrollPane();velocitiesPanel.add(scroll, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 6), 0, 0));velocityTable = new JTable() {
public Class getColumnClass(int column) {return column == 1 ? Boolean.class : super.getColumnClass(column);}
@Overridepublic Dimension getPreferredScrollableViewportSize() {Dimension dim = super.getPreferredScrollableViewportSize();dim.height = getPreferredSize().height;return dim;}};velocityTable.getTableHeader().setReorderingAllowed(false);velocityTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);scroll.setViewportView(velocityTable);velocityTableModel = new DefaultTableModel(new String[0][0], new String[] { "Velocity", "Active" });velocityTable.setModel(velocityTableModel);velocityTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
public void valueChanged(ListSelectionEvent event) {if (event.getValueIsAdjusting())return;velocitySelected();}});velocityTableModel.addTableModelListener(new TableModelListener() {
public void tableChanged(TableModelEvent event) {if (event.getColumn() != 1)return;velocityChecked(event.getFirstRow(), (Boolean) velocityTable.getValueAt(event.getFirstRow(), 1));}});//Velocity valuesemptyPanel = new ParticleValuePanel(editor, "", "", true, false);strengthVelocityPanel = new StrengthVelocityPanel(editor, null, "Life", "", "");angularVelocityPanel = new AngularVelocityPanel(editor, null, "Life", "", "");strengthVelocityPanel.setVisible(false);angularVelocityPanel.setVisible(false);emptyPanel.setVisible(false);strengthVelocityPanel.setIsAlwayShown(true);angularVelocityPanel.setIsAlwayShown(true);emptyPanel.setIsAlwayShown(true);emptyPanel.setValue(null);//Assembleint i = 0;addContent(i++, 0, velocitiesPanel);addContent(i++, 0, strengthVelocityPanel);addContent(i++, 0, angularVelocityPanel);addContent(i++, 0, emptyPanel);}
public void actionPerformed(ActionEvent event) {createVelocity(velocityBox.getSelectedItem());}
public void actionPerformed(ActionEvent event) {deleteVelocity();}
public Class getColumnClass(int column) {return column == 1 ? Boolean.class : super.getColumnClass(column);}
public Dimension getPreferredScrollableViewportSize() {Dimension dim = super.getPreferredScrollableViewportSize();dim.height = getPreferredSize().height;return dim;}
public void valueChanged(ListSelectionEvent event) {if (event.getValueIsAdjusting())return;velocitySelected();}
public void tableChanged(TableModelEvent event) {if (event.getColumn() != 1)return;velocityChecked(event.getFirstRow(), (Boolean) velocityTable.getValueAt(event.getFirstRow(), 1));}
protected void velocityChecked(int index, boolean isChecked) {ParticleController controller = editor.getEmitter();DynamicsInfluencer influencer = (DynamicsInfluencer) controller.findInfluencer(DynamicsInfluencer.class);influencer.velocities.clear();velocities.get(index).isActive = isChecked;for (VelocityWrapper wrapper : velocities) {if (wrapper.isActive)influencer.velocities.add(wrapper.velocityValue);}//Restart the effect and reinit the controllereditor.restart();}
protected void velocitySelected() {//Show the velocity value panelint index = velocityTable.getSelectedRow();if (index == -1)return;DynamicsModifier velocityValue = velocities.get(index).velocityValue;EditorPanel velocityPanel = getVelocityPanel(velocityValue);//Show the selected velocityif (selectedVelocityPanel != null && selectedVelocityPanel != velocityPanel)selectedVelocityPanel.setVisible(false);velocityPanel.setVisible(true);velocityPanel.showContent(true);selectedVelocityPanel = velocityPanel;}
private EditorPanel getVelocityPanel(DynamicsModifier velocityValue) {EditorPanel panel = null;//Billboardsif (velocityValue instanceof DynamicsModifier.Rotational2D) {strengthVelocityPanel.setValue((DynamicsModifier.Strength) velocityValue);strengthVelocityPanel.setName("Angular Velocity");strengthVelocityPanel.setDescription("The angular speed around the billboard facing direction, in degrees/sec .");panel = strengthVelocityPanel;} else if (velocityValue instanceof CentripetalAcceleration) {strengthVelocityPanel.setValue((DynamicsModifier.CentripetalAcceleration) velocityValue);strengthVelocityPanel.setName("Centripetal Acceleration");strengthVelocityPanel.setDescription("A directional acceleration, the direction is towards the origin (global), or towards the emitter position (local), in world units/sec2 .");panel = strengthVelocityPanel;} else if (velocityValue instanceof TangentialAcceleration) {angularVelocityPanel.setValue((DynamicsModifier.Angular) velocityValue);angularVelocityPanel.setName("Tangetial Velocity");angularVelocityPanel.setDescription("A directional acceleration (axis and magnitude), the final direction is the cross product between particle position and the axis, in world units/sec2 .");panel = angularVelocityPanel;} else if (velocityValue instanceof PolarAcceleration) {angularVelocityPanel.setValue((DynamicsModifier.Angular) velocityValue);angularVelocityPanel.setName("Polar Velocity");angularVelocityPanel.setDescription("A directional acceleration (axis and magnitude), in world units/sec2 .");panel = angularVelocityPanel;} else if (velocityValue instanceof BrownianAcceleration) {strengthVelocityPanel.setValue((DynamicsModifier.Strength) velocityValue);strengthVelocityPanel.setName("Brownian Velocity");strengthVelocityPanel.setDescription("A directional acceleration which has random direction at each update, in world units/sec2.");panel = strengthVelocityPanel;} else if (velocityValue instanceof Rotational3D) {angularVelocityPanel.setValue((DynamicsModifier.Angular) velocityValue);angularVelocityPanel.setName("Angular Velocity");angularVelocityPanel.setDescription("An angular velocity (axis and magnitude), in degree/sec2.");panel = angularVelocityPanel;} else if (velocityValue instanceof FaceDirection) {emptyPanel.setName("Face");emptyPanel.setDescription("Rotates the model to face its current velocity (Do not add any other angular velocity when using this).");panel = emptyPanel;}return panel;}
private DynamicsModifier createVelocityValue(Object selectedItem) {DynamicsModifier velocityValue = null;if (selectedItem == VEL_TYPE_ROTATIONAL_2D)velocityValue = new DynamicsModifier.Rotational2D();else if (selectedItem == VEL_TYPE_ROTATIONAL_3D)velocityValue = new DynamicsModifier.Rotational3D();else if (selectedItem == VEL_TYPE_CENTRIPETAL)velocityValue = new DynamicsModifier.CentripetalAcceleration();else if (selectedItem == VEL_TYPE_TANGENTIAL)velocityValue = new DynamicsModifier.TangentialAcceleration();else if (selectedItem == VEL_TYPE_POLAR)velocityValue = new DynamicsModifier.PolarAcceleration();else if (selectedItem == VEL_TYPE_BROWNIAN)velocityValue = new DynamicsModifier.BrownianAcceleration();else if (selectedItem == VEL_TYPE_FACE)velocityValue = new DynamicsModifier.FaceDirection();return velocityValue;}
protected void deleteVelocity() {int row = velocityTable.getSelectedRow();if (row == -1)return;//Remove the velocity from the tableParticleController controller = editor.getEmitter();DynamicsInfluencer influencer = (DynamicsInfluencer) controller.findInfluencer(DynamicsInfluencer.class);influencer.velocities.removeValue(velocities.removeIndex(row).velocityValue, true);velocityTableModel.removeRow(row);//Restart the effect and reinit the controllereditor.restart();selectedVelocityPanel.setVisible(false);selectedVelocityPanel = null;}
protected void createVelocity(Object selectedItem) {//Add the velocity to the table and to the influencerParticleController controller = editor.getEmitter();DynamicsInfluencer influencer = (DynamicsInfluencer) controller.findInfluencer(DynamicsInfluencer.class);VelocityWrapper wrapper = new VelocityWrapper(createVelocityValue(selectedItem), true);velocities.add(wrapper);influencer.velocities.add(wrapper.velocityValue);int index = velocities.size - 1;velocityTableModel.addRow(new Object[] { "Velocity " + index, true });//Reiniteditor.restart();//Select new velocityvelocityTable.getSelectionModel().setSelectionInterval(index, index);revalidate();repaint();}public String getPreloaderBaseURL() {return GWT.getHostPageBaseURL() + "assets/";}
public void onModuleLoad() {GwtApplication.agentInfo = computeAgentInfo();this.listener = getApplicationListener();this.config = getConfig();this.log = config.log;addEventListeners();if (config.rootPanel != null) {this.root = config.rootPanel;} else {Element element = Document.get().getElementById("embed-" + GWT.getModuleName());if (element == null) {VerticalPanel panel = new VerticalPanel();panel.setWidth("" + config.width + "px");panel.setHeight("" + config.height + "px");panel.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);panel.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);RootPanel.get().add(panel);RootPanel.get().setWidth("" + config.width + "px");RootPanel.get().setHeight("" + config.height + "px");this.root = panel;} else {VerticalPanel panel = new VerticalPanel();panel.setWidth("" + config.width + "px");panel.setHeight("" + config.height + "px");panel.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);panel.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);element.appendChild(panel.getElement());root = panel;}}// initialize SoundManager2SoundManager.init(GWT.getModuleBaseURL(), 9, config.preferFlash, new SoundManager.SoundManagerCallback() {
@Overridepublic void onready() {final PreloaderCallback callback = getPreloaderCallback();preloader = createPreloader();preloader.preload("assets.txt", new PreloaderCallback() {
@Overridepublic void error(String file) {callback.error(file);}
@Overridepublic void update(PreloaderState state) {callback.update(state);if (state.hasEnded()) {getRootPanel().clear();if (loadingListener != null)loadingListener.beforeSetup();setupLoop();if (loadingListener != null)loadingListener.afterSetup();}}});}
@Overridepublic void ontimeout(String status, String errorType) {error("SoundManager", status + " " + errorType);}});}
public void onready() {final PreloaderCallback callback = getPreloaderCallback();preloader = createPreloader();preloader.preload("assets.txt", new PreloaderCallback() {
@Overridepublic void error(String file) {callback.error(file);}
@Overridepublic void update(PreloaderState state) {callback.update(state);if (state.hasEnded()) {getRootPanel().clear();if (loadingListener != null)loadingListener.beforeSetup();setupLoop();if (loadingListener != null)loadingListener.afterSetup();}}});}
public void error(String file) {callback.error(file);}
public void update(PreloaderState state) {callback.update(state);if (state.hasEnded()) {getRootPanel().clear();if (loadingListener != null)loadingListener.beforeSetup();setupLoop();if (loadingListener != null)loadingListener.afterSetup();}}
public void ontimeout(String status, String errorType) {error("SoundManager", status + " " + errorType);}
void setupLoop() {// setup modulestry {graphics = new GwtGraphics(root, config);} catch (Throwable e) {root.clear();root.add(new Label("Sorry, your browser doesn't seem to support WebGL"));return;}lastWidth = graphics.getWidth();lastHeight = graphics.getHeight();Gdx.app = this;Gdx.audio = new GwtAudio();Gdx.graphics = graphics;Gdx.gl20 = graphics.getGL20();Gdx.gl = Gdx.gl20;Gdx.files = new GwtFiles(preloader);this.input = new GwtInput(graphics.canvas);Gdx.input = this.input;this.net = new GwtNet();Gdx.net = this.net;this.clipboard = new GwtClipboard();// tell listener about app creationtry {listener.create();listener.resize(graphics.getWidth(), graphics.getHeight());} catch (Throwable t) {error("GwtApplication", "exception: " + t.getMessage(), t);t.printStackTrace();throw new RuntimeException(t);}AnimationScheduler.get().requestAnimationFrame(new AnimationCallback() {
@Overridepublic void execute(double timestamp) {try {mainLoop();} catch (Throwable t) {error("GwtApplication", "exception: " + t.getMessage(), t);throw new RuntimeException(t);}AnimationScheduler.get().requestAnimationFrame(this, graphics.canvas);}}, graphics.canvas);}
public void execute(double timestamp) {try {mainLoop();} catch (Throwable t) {error("GwtApplication", "exception: " + t.getMessage(), t);throw new RuntimeException(t);}AnimationScheduler.get().requestAnimationFrame(this, graphics.canvas);}
void mainLoop() {graphics.update();if (Gdx.graphics.getWidth() != lastWidth || Gdx.graphics.getHeight() != lastHeight) {GwtApplication.this.listener.resize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());lastWidth = graphics.getWidth();lastHeight = graphics.getHeight();Gdx.gl.glViewport(0, 0, lastWidth, lastHeight);}runnablesHelper.addAll(runnables);runnables.clear();for (int i = 0; i < runnablesHelper.size; i++) {runnablesHelper.get(i).run();}runnablesHelper.clear();graphics.frameId++;listener.render();input.reset();}
public Panel getRootPanel() {return root;}
public Preloader createPreloader() {return new Preloader(getPreloaderBaseURL());}
public PreloaderCallback getPreloaderCallback() {final Panel preloaderPanel = new VerticalPanel();preloaderPanel.setStyleName("gdx-preloader");final Image logo = new Image(GWT.getModuleBaseURL() + "logo.png");logo.setStyleName("logo");preloaderPanel.add(logo);final Panel meterPanel = new SimplePanel();meterPanel.setStyleName("gdx-meter");meterPanel.addStyleName("red");final InlineHTML meter = new InlineHTML();final Style meterStyle = meter.getElement().getStyle();meterStyle.setWidth(0, Unit.PCT);meterPanel.add(meter);preloaderPanel.add(meterPanel);getRootPanel().add(preloaderPanel);return new PreloaderCallback() {
@Overridepublic void error(String file) {System.out.println("error: " + file);}
@Overridepublic void update(PreloaderState state) {meterStyle.setWidth(100f * state.getProgress(), Unit.PCT);}};}
public void error(String file) {System.out.println("error: " + file);}
public void update(PreloaderState state) {meterStyle.setWidth(100f * state.getProgress(), Unit.PCT);}
public Graphics getGraphics() {return graphics;}
public Audio getAudio() {return Gdx.audio;}
public Input getInput() {return Gdx.input;}
public Files getFiles() {return Gdx.files;}
public Net getNet() {return Gdx.net;}
private void checkLogLabel() {if (log == null) {log = new TextArea();log.setSize(graphics.getWidth() + "px", "200px");log.setReadOnly(true);root.add(log);}}
public void log(String tag, String message) {if (logLevel >= LOG_INFO) {checkLogLabel();log.setText(log.getText() + "\n" + tag + ": " + message);log.setCursorPos(log.getText().length() - 1);System.out.println(tag + ": " + message);}}
public void log(String tag, String message, Throwable exception) {if (logLevel >= LOG_INFO) {checkLogLabel();log.setText(log.getText() + "\n" + tag + ": " + message + "\n" + getMessages(exception) + "\n");log.setCursorPos(log.getText().length() - 1);System.out.println(tag + ": " + message + "\n" + exception.getMessage());System.out.println(getStackTrace(exception));}}
public void error(String tag, String message) {if (logLevel >= LOG_ERROR) {checkLogLabel();log.setText(log.getText() + "\n" + tag + ": " + message + "\n");log.setCursorPos(log.getText().length() - 1);System.err.println(tag + ": " + message);}}
public void error(String tag, String message, Throwable exception) {if (logLevel >= LOG_ERROR) {checkLogLabel();log.setText(log.getText() + "\n" + tag + ": " + message + "\n" + getMessages(exception) + "\n");log.setCursorPos(log.getText().length() - 1);System.err.println(tag + ": " + message + "\n" + exception.getMessage() + "\n");System.out.println(getStackTrace(exception));}}
public void debug(String tag, String message) {if (logLevel >= LOG_DEBUG) {checkLogLabel();log.setText(log.getText() + "\n" + tag + ": " + message + "\n");log.setCursorPos(log.getText().length() - 1);System.out.println(tag + ": " + message + "\n");}}
public void debug(String tag, String message, Throwable exception) {if (logLevel >= LOG_DEBUG) {checkLogLabel();log.setText(log.getText() + "\n" + tag + ": " + message + "\n" + getMessages(exception) + "\n");log.setCursorPos(log.getText().length() - 1);System.out.println(tag + ": " + message + "\n" + exception.getMessage());System.out.println(getStackTrace(exception));}}
private String getMessages(Throwable e) {StringBuffer buffer = new StringBuffer();while (e != null) {buffer.append(e.getMessage() + "\n");e = e.getCause();}return buffer.toString();}
private String getStackTrace(Throwable e) {StringBuffer buffer = new StringBuffer();for (StackTraceElement trace : e.getStackTrace()) {buffer.append(trace.toString() + "\n");}return buffer.toString();}
public void setLogLevel(int logLevel) {this.logLevel = logLevel;}
public int getLogLevel() {return logLevel;}
public ApplicationType getType() {return ApplicationType.WebGL;}
public int getVersion() {return 0;}
public long getJavaHeap() {return 0;}
public long getNativeHeap() {return 0;}
public Preferences getPreferences(String name) {Preferences pref = prefs.get(name);if (pref == null) {pref = new GwtPreferences(name);prefs.put(name, pref);}return pref;}
public Clipboard getClipboard() {return clipboard;}
public void postRunnable(Runnable runnable) {runnables.add(runnable);}
public void exit() {}
public static AgentInfo agentInfo() {return agentInfo;}
public String getBaseUrl() {return preloader.baseUrl;}
public Preloader getPreloader() {return preloader;}
public CanvasElement getCanvasElement() {return graphics.canvas;}
public LoadingListener getLoadingListener() {return loadingListener;}
public void setLoadingListener(LoadingListener loadingListener) {this.loadingListener = loadingListener;}
public void addLifecycleListener(LifecycleListener listener) {synchronized (lifecycleListeners) {lifecycleListeners.add(listener);}}
public void removeLifecycleListener(LifecycleListener listener) {synchronized (lifecycleListeners) {lifecycleListeners.removeValue(listener, true);}}
private void onVisibilityChange(boolean visible) {if (visible) {for (LifecycleListener listener : lifecycleListeners) {listener.resume();}listener.resume();} else {for (LifecycleListener listener : lifecycleListeners) {listener.pause();}listener.pause();}}public String toString() {String s = "";s += "[" + ex.x + "," + ey.x + "]\n";s += "[" + ex.y + "," + ey.y + "]";return s;}
public final Mat22 set(final Mat22 m) {ex.x = m.ex.x;ex.y = m.ex.y;ey.x = m.ey.x;ey.y = m.ey.y;return this;}
public final Mat22 set(final float exx, final float col2x, final float exy, final float col2y) {ex.x = exx;ex.y = exy;ey.x = col2x;ey.y = col2y;return this;}
public final Mat22 clone() {return new Mat22(ex, ey);}
public final void set(final float angle) {final float c = MathUtils.cos(angle), s = MathUtils.sin(angle);ex.x = c;ey.x = -s;ex.y = s;ey.y = c;}
public final void setIdentity() {ex.x = 1.0f;ey.x = 0.0f;ex.y = 0.0f;ey.y = 1.0f;}
public final void setZero() {ex.x = 0.0f;ey.x = 0.0f;ex.y = 0.0f;ey.y = 0.0f;}
public final float getAngle() {return MathUtils.atan2(ex.y, ex.x);}
public final void set(final Vec2 c1, final Vec2 c2) {ex.x = c1.x;ey.x = c2.x;ex.y = c1.y;ey.y = c2.y;}
public final Mat22 invert() {final float a = ex.x, b = ey.x, c = ex.y, d = ey.y;final Mat22 B = new Mat22();float det = a * d - b * c;if (det != 0) {det = 1.0f / det;}B.ex.x = det * d;B.ey.x = -det * b;B.ex.y = -det * c;B.ey.y = det * a;return B;}
public final Mat22 invertLocal() {final float a = ex.x, b = ey.x, c = ex.y, d = ey.y;float det = a * d - b * c;if (det != 0) {det = 1.0f / det;}ex.x = det * d;ey.x = -det * b;ex.y = -det * c;ey.y = det * a;return this;}
public final void invertToOut(final Mat22 out) {final float a = ex.x, b = ey.x, c = ex.y, d = ey.y;float det = a * d - b * c;// b2Assert(det != 0.0f);det = 1.0f / det;out.ex.x = det * d;out.ey.x = -det * b;out.ex.y = -det * c;out.ey.y = det * a;}
public final Mat22 abs() {return new Mat22(MathUtils.abs(ex.x), MathUtils.abs(ey.x), MathUtils.abs(ex.y), MathUtils.abs(ey.y));}
public final void absLocal() {ex.absLocal();ey.absLocal();}
public static final Mat22 abs(final Mat22 R) {return R.abs();}
public static void absToOut(final Mat22 R, final Mat22 out) {out.ex.x = MathUtils.abs(R.ex.x);out.ex.y = MathUtils.abs(R.ex.y);out.ey.x = MathUtils.abs(R.ey.x);out.ey.y = MathUtils.abs(R.ey.y);}
public final Vec2 mul(final Vec2 v) {return new Vec2(ex.x * v.x + ey.x * v.y, ex.y * v.x + ey.y * v.y);}
public final void mulToOut(final Vec2 v, final Vec2 out) {final float tempy = ex.y * v.x + ey.y * v.y;out.x = ex.x * v.x + ey.x * v.y;out.y = tempy;}
public final void mulToOutUnsafe(final Vec2 v, final Vec2 out) {assert (v != out);out.x = ex.x * v.x + ey.x * v.y;out.y = ex.y * v.x + ey.y * v.y;}
public final Mat22 mul(final Mat22 R) {/* * Mat22 C = new Mat22();C.set(this.mul(R.ex), this.mul(R.ey));return C; */final Mat22 C = new Mat22();C.ex.x = ex.x * R.ex.x + ey.x * R.ex.y;C.ex.y = ex.y * R.ex.x + ey.y * R.ex.y;C.ey.x = ex.x * R.ey.x + ey.x * R.ey.y;C.ey.y = ex.y * R.ey.x + ey.y * R.ey.y;// C.set(ex,col2);return C;}
public final Mat22 mulLocal(final Mat22 R) {mulToOut(R, this);return this;}
public final void mulToOut(final Mat22 R, final Mat22 out) {final float tempy1 = this.ex.y * R.ex.x + this.ey.y * R.ex.y;final float tempx1 = this.ex.x * R.ex.x + this.ey.x * R.ex.y;out.ex.x = tempx1;out.ex.y = tempy1;final float tempy2 = this.ex.y * R.ey.x + this.ey.y * R.ey.y;final float tempx2 = this.ex.x * R.ey.x + this.ey.x * R.ey.y;out.ey.x = tempx2;out.ey.y = tempy2;}
public final void mulToOutUnsafe(final Mat22 R, final Mat22 out) {assert (out != R);assert (out != this);out.ex.x = this.ex.x * R.ex.x + this.ey.x * R.ex.y;out.ex.y = this.ex.y * R.ex.x + this.ey.y * R.ex.y;out.ey.x = this.ex.x * R.ey.x + this.ey.x * R.ey.y;out.ey.y = this.ex.y * R.ey.x + this.ey.y * R.ey.y;}
public final Mat22 mulTrans(final Mat22 B) {/* * Vec2 c1 = new Vec2(Vec2.dot(this.ex, B.ex), Vec2.dot(this.ey, B.ex)); Vec2 c2 = new * Vec2(Vec2.dot(this.ex, B.ey), Vec2.dot(this.ey, B.ey)); Mat22 C = new Mat22(); C.set(c1, c2); * return C; */final Mat22 C = new Mat22();C.ex.x = Vec2.dot(this.ex, B.ex);C.ex.y = Vec2.dot(this.ey, B.ex);C.ey.x = Vec2.dot(this.ex, B.ey);C.ey.y = Vec2.dot(this.ey, B.ey);return C;}
public final Mat22 mulTransLocal(final Mat22 B) {mulTransToOut(B, this);return this;}
public final void mulTransToOut(final Mat22 B, final Mat22 out) {/* * out.ex.x = Vec2.dot(this.ex, B.ex); out.ex.y = Vec2.dot(this.ey, B.ex); out.ey.x = * Vec2.dot(this.ex, B.ey); out.ey.y = Vec2.dot(this.ey, B.ey); */final float x1 = this.ex.x * B.ex.x + this.ex.y * B.ex.y;final float y1 = this.ey.x * B.ex.x + this.ey.y * B.ex.y;final float x2 = this.ex.x * B.ey.x + this.ex.y * B.ey.y;final float y2 = this.ey.x * B.ey.x + this.ey.y * B.ey.y;out.ex.x = x1;out.ey.x = x2;out.ex.y = y1;out.ey.y = y2;}
public final void mulTransToOutUnsafe(final Mat22 B, final Mat22 out) {assert (B != out);assert (this != out);out.ex.x = this.ex.x * B.ex.x + this.ex.y * B.ex.y;out.ey.x = this.ex.x * B.ey.x + this.ex.y * B.ey.y;out.ex.y = this.ey.x * B.ex.x + this.ey.y * B.ex.y;out.ey.y = this.ey.x * B.ey.x + this.ey.y * B.ey.y;}
public final Vec2 mulTrans(final Vec2 v) {// return new Vec2(Vec2.dot(v, ex), Vec2.dot(v, col2));return new Vec2((v.x * ex.x + v.y * ex.y), (v.x * ey.x + v.y * ey.y));}
public final void mulTransToOut(final Vec2 v, final Vec2 out) {/* * out.x = Vec2.dot(v, ex); out.y = Vec2.dot(v, col2); */final float tempx = v.x * ex.x + v.y * ex.y;out.y = v.x * ey.x + v.y * ey.y;out.x = tempx;}
public final Mat22 add(final Mat22 B) {// return new Mat22(ex.add(B.ex), col2.add(B.ey));Mat22 m = new Mat22();m.ex.x = ex.x + B.ex.x;m.ex.y = ex.y + B.ex.y;m.ey.x = ey.x + B.ey.x;m.ey.y = ey.y + B.ey.y;return m;}
public final Mat22 addLocal(final Mat22 B) {// col2.addLocal(B.ey);ex.x += B.ex.x;ex.y += B.ex.y;ey.x += B.ey.x;ey.y += B.ey.y;return this;}
public final Vec2 solve(final Vec2 b) {final float a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;float det = a11 * a22 - a12 * a21;if (det != 0.0f) {det = 1.0f / det;}final Vec2 x = new Vec2(det * (a22 * b.x - a12 * b.y), det * (a11 * b.y - a21 * b.x));return x;}
public final void solveToOut(final Vec2 b, final Vec2 out) {final float a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;float det = a11 * a22 - a12 * a21;if (det != 0.0f) {det = 1.0f / det;}final float tempy = det * (a11 * b.y - a21 * b.x);out.x = det * (a22 * b.x - a12 * b.y);out.y = tempy;}
public static final Vec2 mul(final Mat22 R, final Vec2 v) {// return R.mul(v);return new Vec2(R.ex.x * v.x + R.ey.x * v.y, R.ex.y * v.x + R.ey.y * v.y);}
public static final void mulToOut(final Mat22 R, final Vec2 v, final Vec2 out) {final float tempy = R.ex.y * v.x + R.ey.y * v.y;out.x = R.ex.x * v.x + R.ey.x * v.y;out.y = tempy;}
public static final void mulToOutUnsafe(final Mat22 R, final Vec2 v, final Vec2 out) {assert (v != out);out.x = R.ex.x * v.x + R.ey.x * v.y;out.y = R.ex.y * v.x + R.ey.y * v.y;}
public static final Mat22 mul(final Mat22 A, final Mat22 B) {// return A.mul(B);final Mat22 C = new Mat22();C.ex.x = A.ex.x * B.ex.x + A.ey.x * B.ex.y;C.ex.y = A.ex.y * B.ex.x + A.ey.y * B.ex.y;C.ey.x = A.ex.x * B.ey.x + A.ey.x * B.ey.y;C.ey.y = A.ex.y * B.ey.x + A.ey.y * B.ey.y;return C;}
public static final void mulToOut(final Mat22 A, final Mat22 B, final Mat22 out) {final float tempy1 = A.ex.y * B.ex.x + A.ey.y * B.ex.y;final float tempx1 = A.ex.x * B.ex.x + A.ey.x * B.ex.y;final float tempy2 = A.ex.y * B.ey.x + A.ey.y * B.ey.y;final float tempx2 = A.ex.x * B.ey.x + A.ey.x * B.ey.y;out.ex.x = tempx1;out.ex.y = tempy1;out.ey.x = tempx2;out.ey.y = tempy2;}
public static final void mulToOutUnsafe(final Mat22 A, final Mat22 B, final Mat22 out) {assert (out != A);assert (out != B);out.ex.x = A.ex.x * B.ex.x + A.ey.x * B.ex.y;out.ex.y = A.ex.y * B.ex.x + A.ey.y * B.ex.y;out.ey.x = A.ex.x * B.ey.x + A.ey.x * B.ey.y;out.ey.y = A.ex.y * B.ey.x + A.ey.y * B.ey.y;}
public static final Vec2 mulTrans(final Mat22 R, final Vec2 v) {return new Vec2((v.x * R.ex.x + v.y * R.ex.y), (v.x * R.ey.x + v.y * R.ey.y));}
public static final void mulTransToOut(final Mat22 R, final Vec2 v, final Vec2 out) {float outx = v.x * R.ex.x + v.y * R.ex.y;out.y = v.x * R.ey.x + v.y * R.ey.y;out.x = outx;}
public static final void mulTransToOutUnsafe(final Mat22 R, final Vec2 v, final Vec2 out) {assert (out != v);out.y = v.x * R.ey.x + v.y * R.ey.y;out.x = v.x * R.ex.x + v.y * R.ex.y;}
public static final Mat22 mulTrans(final Mat22 A, final Mat22 B) {final Mat22 C = new Mat22();C.ex.x = A.ex.x * B.ex.x + A.ex.y * B.ex.y;C.ex.y = A.ey.x * B.ex.x + A.ey.y * B.ex.y;C.ey.x = A.ex.x * B.ey.x + A.ex.y * B.ey.y;C.ey.y = A.ey.x * B.ey.x + A.ey.y * B.ey.y;return C;}
public static final void mulTransToOut(final Mat22 A, final Mat22 B, final Mat22 out) {final float x1 = A.ex.x * B.ex.x + A.ex.y * B.ex.y;final float y1 = A.ey.x * B.ex.x + A.ey.y * B.ex.y;final float x2 = A.ex.x * B.ey.x + A.ex.y * B.ey.y;final float y2 = A.ey.x * B.ey.x + A.ey.y * B.ey.y;out.ex.x = x1;out.ex.y = y1;out.ey.x = x2;out.ey.y = y2;}
public static final void mulTransToOutUnsafe(final Mat22 A, final Mat22 B, final Mat22 out) {assert (A != out);assert (B != out);out.ex.x = A.ex.x * B.ex.x + A.ex.y * B.ex.y;out.ex.y = A.ey.x * B.ex.x + A.ey.y * B.ex.y;out.ey.x = A.ex.x * B.ey.x + A.ex.y * B.ey.y;out.ey.y = A.ey.x * B.ey.x + A.ey.y * B.ey.y;}
public static final Mat22 createRotationalTransform(float angle) {Mat22 mat = new Mat22();final float c = MathUtils.cos(angle);final float s = MathUtils.sin(angle);mat.ex.x = c;mat.ey.x = -s;mat.ex.y = s;mat.ey.y = c;return mat;}
public static final void createRotationalTransform(float angle, Mat22 out) {final float c = MathUtils.cos(angle);final float s = MathUtils.sin(angle);out.ex.x = c;out.ey.x = -s;out.ex.y = s;out.ey.y = c;}
public static final Mat22 createScaleTransform(float scale) {Mat22 mat = new Mat22();mat.ex.x = scale;mat.ey.y = scale;return mat;}
public static final void createScaleTransform(float scale, Mat22 out) {out.ex.x = scale;out.ey.y = scale;}
public int hashCode() {final int prime = 31;int result = 1;result = prime * result + ((ex == null) ? 0 : ex.hashCode());result = prime * result + ((ey == null) ? 0 : ey.hashCode());return result;}
public boolean equals(Object obj) {if (this == obj)return true;if (obj == null)return false;if (getClass() != obj.getClass())return false;Mat22 other = (Mat22) obj;if (ex == null) {if (other.ex != null)return false;} else if (!ex.equals(other.ex))return false;if (ey == null) {if (other.ey != null)return false;} else if (!ey.equals(other.ey))return false;return true;}public void setColor(Color tint) {color = tint.toFloatBits();}
public void setColor(float r, float g, float b, float a) {int intBits = (int) (255 * a) << 24 | (int) (255 * b) << 16 | (int) (255 * g) << 8 | (int) (255 * r);color = NumberUtils.intToFloatColor(intBits);}
public void setColor(float color) {this.color = color;}
public Color getColor() {int intBits = NumberUtils.floatToIntColor(color);Color color = this.tempColor;color.r = (intBits & 0xff) / 255f;color.g = ((intBits >>> 8) & 0xff) / 255f;color.b = ((intBits >>> 16) & 0xff) / 255f;color.a = ((intBits >>> 24) & 0xff) / 255f;return color;}
public void beginCache() {if (currentCache != null)throw new IllegalStateException("endCache must be called before begin.");int verticesPerImage = mesh.getNumIndices() > 0 ? 4 : 6;currentCache = new Cache(caches.size, mesh.getVerticesBuffer().limit());caches.add(currentCache);mesh.getVerticesBuffer().compact();}
public void beginCache(int cacheID) {if (currentCache != null)throw new IllegalStateException("endCache must be called before begin.");if (cacheID == caches.size - 1) {Cache oldCache = caches.removeIndex(cacheID);mesh.getVerticesBuffer().limit(oldCache.offset);beginCache();return;}currentCache = caches.get(cacheID);mesh.getVerticesBuffer().position(currentCache.offset);}
public int endCache() {if (currentCache == null)throw new IllegalStateException("beginCache must be called before endCache.");Cache cache = currentCache;int cacheCount = mesh.getVerticesBuffer().position() - cache.offset;if (cache.textures == null) {// New cache.cache.maxCount = cacheCount;cache.textureCount = textures.size;cache.textures = textures.toArray(Texture.class);cache.counts = new int[cache.textureCount];for (int i = 0, n = counts.size; i < n; i++) cache.counts[i] = counts.get(i);mesh.getVerticesBuffer().flip();} else {// Redefine existing cache.if (cacheCount > cache.maxCount) {throw new GdxRuntimeException("If a cache is not the last created, it cannot be redefined with more entries than when it was first created: " + cacheCount + " (" + cache.maxCount + " max)");}cache.textureCount = textures.size;if (cache.textures.length < cache.textureCount)cache.textures = new Texture[cache.textureCount];for (int i = 0, n = cache.textureCount; i < n; i++) cache.textures[i] = textures.get(i);if (cache.counts.length < cache.textureCount)cache.counts = new int[cache.textureCount];for (int i = 0, n = cache.textureCount; i < n; i++) cache.counts[i] = counts.get(i);FloatBuffer vertices = mesh.getVerticesBuffer();vertices.position(0);Cache lastCache = caches.get(caches.size - 1);vertices.limit(lastCache.offset + lastCache.maxCount);}currentCache = null;textures.clear();counts.clear();return cache.id;}
public void clear() {caches.clear();mesh.getVerticesBuffer().clear().flip();}
public void add(Texture texture, float[] vertices, int offset, int length) {if (currentCache == null)throw new IllegalStateException("beginCache must be called before add.");int verticesPerImage = mesh.getNumIndices() > 0 ? 4 : 6;int count = length / (verticesPerImage * VERTEX_SIZE) * 6;int lastIndex = textures.size - 1;if (lastIndex < 0 || textures.get(lastIndex) != texture) {textures.add(texture);counts.add(count);} elsecounts.incr(lastIndex, count);mesh.getVerticesBuffer().put(vertices, offset, length);}
public void add(Texture texture, float x, float y) {final float fx2 = x + texture.getWidth();final float fy2 = y + texture.getHeight();tempVertices[0] = x;tempVertices[1] = y;tempVertices[2] = color;tempVertices[3] = 0;tempVertices[4] = 1;tempVertices[5] = x;tempVertices[6] = fy2;tempVertices[7] = color;tempVertices[8] = 0;tempVertices[9] = 0;tempVertices[10] = fx2;tempVertices[11] = fy2;tempVertices[12] = color;tempVertices[13] = 1;tempVertices[14] = 0;if (mesh.getNumIndices() > 0) {tempVertices[15] = fx2;tempVertices[16] = y;tempVertices[17] = color;tempVertices[18] = 1;tempVertices[19] = 1;add(texture, tempVertices, 0, 20);} else {tempVertices[15] = fx2;tempVertices[16] = fy2;tempVertices[17] = color;tempVertices[18] = 1;tempVertices[19] = 0;tempVertices[20] = fx2;tempVertices[21] = y;tempVertices[22] = color;tempVertices[23] = 1;tempVertices[24] = 1;tempVertices[25] = x;tempVertices[26] = y;tempVertices[27] = color;tempVertices[28] = 0;tempVertices[29] = 1;add(texture, tempVertices, 0, 30);}}
public void add(Texture texture, float x, float y, int srcWidth, int srcHeight, float u, float v, float u2, float v2, float color) {final float fx2 = x + srcWidth;final float fy2 = y + srcHeight;tempVertices[0] = x;tempVertices[1] = y;tempVertices[2] = color;tempVertices[3] = u;tempVertices[4] = v;tempVertices[5] = x;tempVertices[6] = fy2;tempVertices[7] = color;tempVertices[8] = u;tempVertices[9] = v2;tempVertices[10] = fx2;tempVertices[11] = fy2;tempVertices[12] = color;tempVertices[13] = u2;tempVertices[14] = v2;if (mesh.getNumIndices() > 0) {tempVertices[15] = fx2;tempVertices[16] = y;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v;add(texture, tempVertices, 0, 20);} else {tempVertices[15] = fx2;tempVertices[16] = fy2;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v2;tempVertices[20] = fx2;tempVertices[21] = y;tempVertices[22] = color;tempVertices[23] = u2;tempVertices[24] = v;tempVertices[25] = x;tempVertices[26] = y;tempVertices[27] = color;tempVertices[28] = u;tempVertices[29] = v;add(texture, tempVertices, 0, 30);}}
public void add(Texture texture, float x, float y, int srcX, int srcY, int srcWidth, int srcHeight) {float invTexWidth = 1.0f / texture.getWidth();float invTexHeight = 1.0f / texture.getHeight();final float u = srcX * invTexWidth;final float v = (srcY + srcHeight) * invTexHeight;final float u2 = (srcX + srcWidth) * invTexWidth;final float v2 = srcY * invTexHeight;final float fx2 = x + srcWidth;final float fy2 = y + srcHeight;tempVertices[0] = x;tempVertices[1] = y;tempVertices[2] = color;tempVertices[3] = u;tempVertices[4] = v;tempVertices[5] = x;tempVertices[6] = fy2;tempVertices[7] = color;tempVertices[8] = u;tempVertices[9] = v2;tempVertices[10] = fx2;tempVertices[11] = fy2;tempVertices[12] = color;tempVertices[13] = u2;tempVertices[14] = v2;if (mesh.getNumIndices() > 0) {tempVertices[15] = fx2;tempVertices[16] = y;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v;add(texture, tempVertices, 0, 20);} else {tempVertices[15] = fx2;tempVertices[16] = fy2;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v2;tempVertices[20] = fx2;tempVertices[21] = y;tempVertices[22] = color;tempVertices[23] = u2;tempVertices[24] = v;tempVertices[25] = x;tempVertices[26] = y;tempVertices[27] = color;tempVertices[28] = u;tempVertices[29] = v;add(texture, tempVertices, 0, 30);}}
public void add(Texture texture, float x, float y, float width, float height, int srcX, int srcY, int srcWidth, int srcHeight, boolean flipX, boolean flipY) {float invTexWidth = 1.0f / texture.getWidth();float invTexHeight = 1.0f / texture.getHeight();float u = srcX * invTexWidth;float v = (srcY + srcHeight) * invTexHeight;float u2 = (srcX + srcWidth) * invTexWidth;float v2 = srcY * invTexHeight;final float fx2 = x + width;final float fy2 = y + height;if (flipX) {float tmp = u;u = u2;u2 = tmp;}if (flipY) {float tmp = v;v = v2;v2 = tmp;}tempVertices[0] = x;tempVertices[1] = y;tempVertices[2] = color;tempVertices[3] = u;tempVertices[4] = v;tempVertices[5] = x;tempVertices[6] = fy2;tempVertices[7] = color;tempVertices[8] = u;tempVertices[9] = v2;tempVertices[10] = fx2;tempVertices[11] = fy2;tempVertices[12] = color;tempVertices[13] = u2;tempVertices[14] = v2;if (mesh.getNumIndices() > 0) {tempVertices[15] = fx2;tempVertices[16] = y;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v;add(texture, tempVertices, 0, 20);} else {tempVertices[15] = fx2;tempVertices[16] = fy2;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v2;tempVertices[20] = fx2;tempVertices[21] = y;tempVertices[22] = color;tempVertices[23] = u2;tempVertices[24] = v;tempVertices[25] = x;tempVertices[26] = y;tempVertices[27] = color;tempVertices[28] = u;tempVertices[29] = v;add(texture, tempVertices, 0, 30);}}
public void add(Texture texture, float x, float y, float originX, float originY, float width, float height, float scaleX, float scaleY, float rotation, int srcX, int srcY, int srcWidth, int srcHeight, boolean flipX, boolean flipY) {// bottom left and top right corner points relative to originfinal float worldOriginX = x + originX;final float worldOriginY = y + originY;float fx = -originX;float fy = -originY;float fx2 = width - originX;float fy2 = height - originY;// scaleif (scaleX != 1 || scaleY != 1) {fx *= scaleX;fy *= scaleY;fx2 *= scaleX;fy2 *= scaleY;}// construct corner points, start from top left and go counter clockwisefinal float p1x = fx;final float p1y = fy;final float p2x = fx;final float p2y = fy2;final float p3x = fx2;final float p3y = fy2;final float p4x = fx2;final float p4y = fy;float x1;float y1;float x2;float y2;float x3;float y3;float x4;float y4;// rotateif (rotation != 0) {final float cos = MathUtils.cosDeg(rotation);final float sin = MathUtils.sinDeg(rotation);x1 = cos * p1x - sin * p1y;y1 = sin * p1x + cos * p1y;x2 = cos * p2x - sin * p2y;y2 = sin * p2x + cos * p2y;x3 = cos * p3x - sin * p3y;y3 = sin * p3x + cos * p3y;x4 = x1 + (x3 - x2);y4 = y3 - (y2 - y1);} else {x1 = p1x;y1 = p1y;x2 = p2x;y2 = p2y;x3 = p3x;y3 = p3y;x4 = p4x;y4 = p4y;}x1 += worldOriginX;y1 += worldOriginY;x2 += worldOriginX;y2 += worldOriginY;x3 += worldOriginX;y3 += worldOriginY;x4 += worldOriginX;y4 += worldOriginY;float invTexWidth = 1.0f / texture.getWidth();float invTexHeight = 1.0f / texture.getHeight();float u = srcX * invTexWidth;float v = (srcY + srcHeight) * invTexHeight;float u2 = (srcX + srcWidth) * invTexWidth;float v2 = srcY * invTexHeight;if (flipX) {float tmp = u;u = u2;u2 = tmp;}if (flipY) {float tmp = v;v = v2;v2 = tmp;}tempVertices[0] = x1;tempVertices[1] = y1;tempVertices[2] = color;tempVertices[3] = u;tempVertices[4] = v;tempVertices[5] = x2;tempVertices[6] = y2;tempVertices[7] = color;tempVertices[8] = u;tempVertices[9] = v2;tempVertices[10] = x3;tempVertices[11] = y3;tempVertices[12] = color;tempVertices[13] = u2;tempVertices[14] = v2;if (mesh.getNumIndices() > 0) {tempVertices[15] = x4;tempVertices[16] = y4;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v;add(texture, tempVertices, 0, 20);} else {tempVertices[15] = x3;tempVertices[16] = y3;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v2;tempVertices[20] = x4;tempVertices[21] = y4;tempVertices[22] = color;tempVertices[23] = u2;tempVertices[24] = v;tempVertices[25] = x1;tempVertices[26] = y1;tempVertices[27] = color;tempVertices[28] = u;tempVertices[29] = v;add(texture, tempVertices, 0, 30);}}
public void add(TextureRegion region, float x, float y) {add(region, x, y, region.getRegionWidth(), region.getRegionHeight());}
public void add(TextureRegion region, float x, float y, float width, float height) {final float fx2 = x + width;final float fy2 = y + height;final float u = region.u;final float v = region.v2;final float u2 = region.u2;final float v2 = region.v;tempVertices[0] = x;tempVertices[1] = y;tempVertices[2] = color;tempVertices[3] = u;tempVertices[4] = v;tempVertices[5] = x;tempVertices[6] = fy2;tempVertices[7] = color;tempVertices[8] = u;tempVertices[9] = v2;tempVertices[10] = fx2;tempVertices[11] = fy2;tempVertices[12] = color;tempVertices[13] = u2;tempVertices[14] = v2;if (mesh.getNumIndices() > 0) {tempVertices[15] = fx2;tempVertices[16] = y;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v;add(region.texture, tempVertices, 0, 20);} else {tempVertices[15] = fx2;tempVertices[16] = fy2;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v2;tempVertices[20] = fx2;tempVertices[21] = y;tempVertices[22] = color;tempVertices[23] = u2;tempVertices[24] = v;tempVertices[25] = x;tempVertices[26] = y;tempVertices[27] = color;tempVertices[28] = u;tempVertices[29] = v;add(region.texture, tempVertices, 0, 30);}}
public void add(TextureRegion region, float x, float y, float originX, float originY, float width, float height, float scaleX, float scaleY, float rotation) {// bottom left and top right corner points relative to originfinal float worldOriginX = x + originX;final float worldOriginY = y + originY;float fx = -originX;float fy = -originY;float fx2 = width - originX;float fy2 = height - originY;// scaleif (scaleX != 1 || scaleY != 1) {fx *= scaleX;fy *= scaleY;fx2 *= scaleX;fy2 *= scaleY;}// construct corner points, start from top left and go counter clockwisefinal float p1x = fx;final float p1y = fy;final float p2x = fx;final float p2y = fy2;final float p3x = fx2;final float p3y = fy2;final float p4x = fx2;final float p4y = fy;float x1;float y1;float x2;float y2;float x3;float y3;float x4;float y4;// rotateif (rotation != 0) {final float cos = MathUtils.cosDeg(rotation);final float sin = MathUtils.sinDeg(rotation);x1 = cos * p1x - sin * p1y;y1 = sin * p1x + cos * p1y;x2 = cos * p2x - sin * p2y;y2 = sin * p2x + cos * p2y;x3 = cos * p3x - sin * p3y;y3 = sin * p3x + cos * p3y;x4 = x1 + (x3 - x2);y4 = y3 - (y2 - y1);} else {x1 = p1x;y1 = p1y;x2 = p2x;y2 = p2y;x3 = p3x;y3 = p3y;x4 = p4x;y4 = p4y;}x1 += worldOriginX;y1 += worldOriginY;x2 += worldOriginX;y2 += worldOriginY;x3 += worldOriginX;y3 += worldOriginY;x4 += worldOriginX;y4 += worldOriginY;final float u = region.u;final float v = region.v2;final float u2 = region.u2;final float v2 = region.v;tempVertices[0] = x1;tempVertices[1] = y1;tempVertices[2] = color;tempVertices[3] = u;tempVertices[4] = v;tempVertices[5] = x2;tempVertices[6] = y2;tempVertices[7] = color;tempVertices[8] = u;tempVertices[9] = v2;tempVertices[10] = x3;tempVertices[11] = y3;tempVertices[12] = color;tempVertices[13] = u2;tempVertices[14] = v2;if (mesh.getNumIndices() > 0) {tempVertices[15] = x4;tempVertices[16] = y4;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v;add(region.texture, tempVertices, 0, 20);} else {tempVertices[15] = x3;tempVertices[16] = y3;tempVertices[17] = color;tempVertices[18] = u2;tempVertices[19] = v2;tempVertices[20] = x4;tempVertices[21] = y4;tempVertices[22] = color;tempVertices[23] = u2;tempVertices[24] = v;tempVertices[25] = x1;tempVertices[26] = y1;tempVertices[27] = color;tempVertices[28] = u;tempVertices[29] = v;add(region.texture, tempVertices, 0, 30);}}
public void add(Sprite sprite) {if (mesh.getNumIndices() > 0) {add(sprite.getTexture(), sprite.getVertices(), 0, SPRITE_SIZE);return;}float[] spriteVertices = sprite.getVertices();// temp0,1,2=sprite0,1,2System.arraycopy(spriteVertices, 0, tempVertices, 0, 3 * VERTEX_SIZE);// temp3=sprite2System.arraycopy(spriteVertices, 2 * VERTEX_SIZE, tempVertices, 3 * VERTEX_SIZE, VERTEX_SIZE);// temp4=sprite3System.arraycopy(spriteVertices, 3 * VERTEX_SIZE, tempVertices, 4 * VERTEX_SIZE, VERTEX_SIZE);// temp5=sprite0System.arraycopy(spriteVertices, 0, tempVertices, 5 * VERTEX_SIZE, VERTEX_SIZE);add(sprite.getTexture(), tempVertices, 0, 30);}
public void begin() {if (drawing)throw new IllegalStateException("end must be called before begin.");renderCalls = 0;combinedMatrix.set(projectionMatrix).mul(transformMatrix);Gdx.gl20.glDepthMask(false);if (customShader != null) {customShader.begin();customShader.setUniformMatrix("u_proj", projectionMatrix);customShader.setUniformMatrix("u_trans", transformMatrix);customShader.setUniformMatrix("u_projTrans", combinedMatrix);customShader.setUniformi("u_texture", 0);mesh.bind(customShader);} else {shader.begin();shader.setUniformMatrix("u_projectionViewMatrix", combinedMatrix);shader.setUniformi("u_texture", 0);mesh.bind(shader);}drawing = true;}
public void end() {if (!drawing)throw new IllegalStateException("begin must be called before end.");drawing = false;shader.end();GL20 gl = Gdx.gl20;gl.glDepthMask(true);if (customShader != null)mesh.unbind(customShader);elsemesh.unbind(shader);}
public void draw(int cacheID) {if (!drawing)throw new IllegalStateException("SpriteCache.begin must be called before draw.");Cache cache = caches.get(cacheID);int verticesPerImage = mesh.getNumIndices() > 0 ? 4 : 6;int offset = cache.offset / (verticesPerImage * VERTEX_SIZE) * 6;Texture[] textures = cache.textures;int[] counts = cache.counts;int textureCount = cache.textureCount;for (int i = 0; i < textureCount; i++) {int count = counts[i];textures[i].bind();if (customShader != null)mesh.render(customShader, GL20.GL_TRIANGLES, offset, count);elsemesh.render(shader, GL20.GL_TRIANGLES, offset, count);offset += count;}renderCalls += textureCount;totalRenderCalls += textureCount;}
public void draw(int cacheID, int offset, int length) {if (!drawing)throw new IllegalStateException("SpriteCache.begin must be called before draw.");Cache cache = caches.get(cacheID);offset = offset * 6 + cache.offset;length *= 6;Texture[] textures = cache.textures;int[] counts = cache.counts;int textureCount = cache.textureCount;for (int i = 0; i < textureCount; i++) {textures[i].bind();int count = counts[i];if (count > length) {i = textureCount;count = length;} elselength -= count;if (customShader != null)mesh.render(customShader, GL20.GL_TRIANGLES, offset, count);elsemesh.render(shader, GL20.GL_TRIANGLES, offset, count);offset += count;}renderCalls += cache.textureCount;totalRenderCalls += textureCount;}
public void dispose() {mesh.dispose();if (shader != null)shader.dispose();}
public Matrix4 getProjectionMatrix() {return projectionMatrix;}
public void setProjectionMatrix(Matrix4 projection) {if (drawing)throw new IllegalStateException("Can't set the matrix within begin/end.");projectionMatrix.set(projection);}
public Matrix4 getTransformMatrix() {return transformMatrix;}
public void setTransformMatrix(Matrix4 transform) {if (drawing)throw new IllegalStateException("Can't set the matrix within begin/end.");transformMatrix.set(transform);}
static ShaderProgram createDefaultShader() {String vertexShader = //"attribute vec4 " + ShaderProgram.POSITION_ATTRIBUTE + ";\n" + "attribute vec4 " + ShaderProgram.COLOR_ATTRIBUTE + //";\n" + "attribute vec2 " + ShaderProgram.TEXCOORD_ATTRIBUTE + //"0;\n" + //"uniform mat4 u_projectionViewMatrix;\n" + //"varying vec4 v_color;\n" + //"varying vec2 v_texCoords;\n" + //"\n" + //"void main()\n" + //"{\n" + "   v_color = " + ShaderProgram.COLOR_ATTRIBUTE + //";\n" + //"   v_color.a = v_color.a * (255.0/254.0);\n" + "   v_texCoords = " + ShaderProgram.TEXCOORD_ATTRIBUTE + //"0;\n" + "   gl_Position =  u_projectionViewMatrix * " + ShaderProgram.POSITION_ATTRIBUTE + //";\n" + "}\n";String fragmentShader = //"#ifdef GL_ES\n" + //"precision mediump float;\n" + //"#endif\n" + //"varying vec4 v_color;\n" + //"varying vec2 v_texCoords;\n" + //"uniform sampler2D u_texture;\n" + //"void main()\n" + //"{\n" + //"  gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n" + "}";ShaderProgram shader = new ShaderProgram(vertexShader, fragmentShader);if (shader.isCompiled() == false)throw new IllegalArgumentException("Error compiling shader: " + shader.getLog());return shader;}
public void setShader(ShaderProgram shader) {customShader = shader;}